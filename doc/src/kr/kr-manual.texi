@c -*-texinfo-*-
@c This is part of the Garnet Reference Manual.
@c See the file garnet.texi for copying conditions.

@node KR: Constraint-Based Knowledge Representation
@chapter KR: Constraint-Based Knowledge Representation
@cindex kr
@cindex Knowledge representation

KR is a very efficient knowledge representation language implemented
in Common Lisp. It provides powerful frame-based knowledge
representation with user-defined inheritance and relations, and an
integrated object-oriented programming system. In addition, the
system supports a constraint maintenance mechanism which allows any
value to be computed from a combination of other values. KR is simple
and compact and does not include some of the more complex
functionality often found in other knowledge representation systems.
Because of its simplicity, however, it is highly optimized and offers
good performance. These qualities make it suitable for many
applications that require a mixture of good performance and flexible
knowledge representation.

@menu

* KR: Introduction::

@end menu


@c Don't use this yet.
@c @include kr-manual-header.texi


@subsection KR: Introduction
@node KR: Introduction


This document is the reference manual for the KR system. KR
implements objects, also known as @emph{schemata}, which can contain any
amount of information and which can be connected in arbitrary ways.
All Garnet objects are implemented as KR schemata. KR @cite{kr} can
also be used as a very efficient frame-based representation system.
Simplicity and efficiency are its main design goals and differentiate
it sharply from more conventional frame systems, as discussed in
@cite{KR-KER}.

In addition to the basic representation of knowledge as a network of
schemata, KR provides object-oriented programming and an integrated
constraint maintenance system. Constraint maintenance is implemented
through @emph(formulas), which constrain certain values to
combinations of other values. The constraint system is closely
integrated with the basic object system and is part of the same
program interface.

Close integration between objects and constraint maintenance yields
several advantages. First of all, constraint maintenance is seen as a
natural extension of object representation; the same access functions
work on regular values and on values constrained by a formula.
Second, the full power of the representation language is available in
the specification of constraints. Third, since the two mechanisms are
integrated at a fairly low level, the constraint maintenance system
offers very good performance. These advantages make the KR constraint
maintenance system a practical tool for the development of
applications that require flexibility, expressive power, and
performance comparable to that obtained with conventional data
structures.

In addition to being one of the building blocks of the Garnet project,
KR can be used as a self-contained knowledge representation system.
Besides Garnet, KR is used in the Chinese Tutor @cite{CHINESE-TUTOR}
@cite{CHINESE-TUTOR-SHANGHAI}, an intelligent tutoring system designed
to teach Chinese to English speakers, and in speech understanding
research @cite{MINDS} currently underway at Carnegie Mellon.

This document describes version @value{GARNETVER} of KR, which is part
of release @value{GARNETVER} of the Garnet system. Several aspects of
this version differ from previous versions of the system, such as the
ones described in previous reports @cite{KRTR2} @cite{KR}. The
present document overrides all previous descriptions.

The orientation of this manual is for users of KR as an object system.
Users who are more interested in using KR as a knowledge representation
system should consult a previous paper @cite{kr-ker}. This manual begins
with a description of the features of the system that beginners are most
likely to need. Some of the less common features are only presented near
the end of the document, in order to avoid obscuring the description with
irrelevant details. Sections 6 and 7 contain the detailed description of
the program interface of KR. This is a complete description of the system
and its features. Most application programs will only need a small number
of features, described in section 6.

@section Structure of the System
@node Structure of the System


KR is an object system implemented in Common Lisp @cite{CommonLisp}. It
includes three closely integrated components: @emph{object-oriented}
programming), @emph{constraint maintenance}, and @emph{knowledge representation}.

The first component of KR is an object oriented programming system based on
the prototype-instance paradigm. Schemata can be used as objects, and
inheritance can be used to determine their properties and behavior.
Objects can be sent @emph{messages}, which are implemented as procedural
attachments to certain slots; messages are inherited through the same
mechanism as values.

Instead of the class-instance paradigm, common in object-oriented
programming languages, KR implements the more flexible prototype-instance
paradigm @cite{liebermanprototypes}, which allows properties of instances
to be determined dynamically by their prototypes. This means that the
class structure of a system can be modified dynamically as needed, without
any need for recompilation.

The second component of KR implements constraint maintenance. Constraint
maintenance is implemented through @emph{formulas}, which may be attached to
slots and determine their values based on the values of other slots in the
system.

Constraint maintenance is closely integrated with the other components.
The user, for example, does not need to know which slots in a schema
contain ordinary values and which ones are constrained by a formula, since
the same access primitives may be used in both cases.

The third component, frame-based knowledge representation, stores knowledge
as a network of chunks of information. Networks in KR are built out of
unstructured chunks, i.e., @emph{schemata}. Each schema can store
arbitrary pieces of information, and is not restricted to a particular
format or data structure. Information is encoded via attribute-value
pairs.

Values in a schema can be interpreted as links to other schemata. This
enables the system to support complex network structures, which can be
freely extended and modified by application programs. KR provides simple
ways to specify the structure of a network and the relationship among its
components.

@section Basic Concepts
@node Basic Concepts

This section describes the basic elements of KR, i.e., objects. More
details about the design philosophy of the system and some of the
internal implementation may be found in @cite{KR}, which describes a
previous version of the system that did not support constraint
maintenance.

@subsection Main Concepts: Schema, Slot, Value
@node Main Concepts: Schema, Slot, Value


An object in KR is known as a @emph{schema}. A schema  is the
basic unit of representation and consists of an optional @emph{name}, a
set of @emph{slots}, and a @emph{value} for each slot. The user can
assemble networks of schemata by placing a schema as the value in a slot of
another schema; this causes the two schemata to become linked.

@cindex{schema}

A schema may be namedor unnamed. Named schemata are readily
accessible and are most useful for interactive situations or as the
top levels of a hierarchy, since their names act as global handles.
Unnamed schemata do not have meaningful
external names. They are, however, more compact than named schemata
and account for the vast majority of schemata created by most
applications. Unnamed schemata are automatically garbage-collected
when no longer needed, whereas named schemata have to be destroyed
explicitly by the user.

@cindex schema names
@cindex named schemata
@cindex unnamed schemata

The name of a named schema is a symbol. When a named schema is created, KR
automatically creates a special variable by the same name  and assigns the schema itself as the value of the special
variable. This makes named schemata convenient to use.

@cindex{schemata and variables}

A schema may have any number of @emph{slots}, which are simply
attribute-value pairs. The slot name indicates the attribute name;
the slot value (if there is one) indicates its value. Slot names are
keywords, and thus always begin with a colon. All slots in a schema
must have distinct names, but different schemata may very well have
slots with the same name.

@cindex{slot}
@cindex{slot names}

Each slot may contain only one value. A value is the actual data item
stored in the schema, and may be of any Lisp type. KR provides
functions to add, delete, and retrieve the value from a given slot in
a schema.



@cindex{value}

The printed representation of a schema shows the schema name followed by
slot/value pairs, each on a separate line. The whole schema is surrounded
by curly braces. For example,
@example
{#k<fido>
  :owner =  #k<john>
  :color =  #k<brown>
  :age =  5
}
@end example

The schema is named FIDO and contains three slots named
@code{:owner}, @code{:color}, and @code{:age}. The slot @code{:age} contains one
value, the integer 5.

The default printed name of a schema is of the form @code{#k<name>}, where
@emph{name} is the actual name of the schema. This representation makes it
very easy to distinguish KR schemata from other objects. Note, however,
that this convention is only used when printing, and is not used when
typing the name of a schema.



In order to illustrate the main features of the system, we will repeatedly
use a few schemata. We present the definition of those schemata at this
point and will later refer to them as needed. These schemata might be part
of some graphical package, and are used here purely for explanation
purposes. In practice, there is no need to define such schemata in a
Garnet application, since the Opal component of Garnet (see the Opal
manual) already provides a complete graphical object system.


The following KR code is the complete definition of the example schemata:
@anchor{kr-examples}

@example

(create-instance 'my-graphical-object nil
  (:color :blue))

(create-instance 'box-object my-graphical-object
  (:thickness 1))

(create-instance 'rectangle-1 box-object
  (:x 10)
  (:y 20))

(create-instance 'rectangle-2 box-object
  (:x 34)
  (:y (o-formula (+ (gvl :left-obj :y) 15)))
  (:left-obj rectangle-1))
@end example

@cindex rectangle-2
@cindex rectangle-1
@cindex box-object
@cindex my-graphical-object

The exact meaning of the expressions above will become clear after we
describe the functional interface of the system. Briefly, however,
the example can be summarized as follows. The schema
@code{my-graphical-object} is at the top of a hierarchy of graphical
objects. The schema @code{box-object} represents an intermediate level
in the hierarchy, and describes the general features of all graphical
objects which are rectangular boxes. @code{box-object} is placed below
@code{my-graphical-object} in the hierarchy, and its @code{:is-a} slot
points to the schema @code{my-graphical-object}. This is done
automatically by the macro create-instance.

Finally, two rectangles (@code{rectangle-1} and @code{rectangle-2}) are
created and placed below @code{box-object} in the hierarchy. @code{rectangle-1}
defines the values of the two slots @code{:x} and @code{:y} directly, whereas
@code{rectangle-2} uses a formula for its @code{:y} slot. The formula states
that the value of @code{:y} is constrained to be the @code{:y} value of another
schema plus 15. The other schema can be located by following the
@code{:left-obj} slot of @code{rectangle-2}, as specified in the formula, and
initially corresponds to @code{rectangle-1}.

@ref{fig:ex1} shows the four schemata after the
definitions above have been executed. Relations are indicated by an
arrow going from a schema to the ones to which it is related.

@float Figure,fig:ex1
@center @image{schemata, 5.5in}
@caption{The resulting network of schemata}
@anchor{all-schemata}
@end float

Asking the system to print out the current status of schema
@code{rectangle-2} would produce the following output:

@example
{#k<RECTANGLE-2>
  :IS-A =  #k<BOX-OBJECT>
  :LEFT-OBJ =  #k<RECTANGLE-1>
  :Y =  #k<F2289>(NIL . NIL)
  :X =  34
}
@end example

Note that slot @code{:y} contains a formula, which is printed as
@code{#k<F2289>(NIL . NIL)}. This is simply an internal representation for
the formula and will yield the correct value of @code{:y} when needed.


@node Inheritance
@subsection Inheritance

The primary function of values is to provide information about the object
represented by a schema. In the previous example, for instance, asking the
system for the @code{:x} value of @code{rectangle-1} would simply return the
value @code{10}.

Values  can also perform another function,
however: They can establish @emph{connections between schemata}.
Consider the @code{:left-obj} slot in the example above: if we interpret
@code{rectangle-1} as a schema name, then the slot tells us that the
schema @code{rectangle-2} is somehow related to the schema
@code{rectangle-1}. Graphically, this will mean that the position of
@code{rectangle-2} is partially determined by that of @code{rectangle-1}.

@cindex{values as links}

KR also makes it possible to use values to perform @emph{inheritance},
i.e., to control the way information is inherited by a particular
schema from other schemata to which it is connected.  Inheritance
allows information to be arranged in a hierarchical fashion, with
lower-level schemata inheriting most of their general features from
higher-level nodes and possibly providing local refinements or
modifications. A connection that enables inheritance of values is
called an @emph{inheritance relation} . Inheritance relations always
contain a list of values; in many cases, this is a list of only one
value.

@cindex{inheritance}
@cindex{relation}

The most common example of inheritance is provided by the @code{:is-a}
relation . If schema A is connected to schema B by the
@code{:is-a} relation,@footnote{In other words, if schema B appears as a value
in the @code{:is-a} slot of schema A.} then values that are not present in A
may be inherited from B.

@cindex{is-a relation}

Consider the schema @code{rectangle-1} in our example. If we were to ask
"What is the color of @code{rectangle-1}?", we would not be able to find the
answer by just looking at the schema itself. But since we stated that
@code{rectangle-1} is a box object, which is itself a graphical object,
the value can be inherited from the schema @code{my-graphical-object}
through two levels of @code{:is-a}. The answer would thus be
"@code{rectangle-1} is blue."  Inheritance is possible in this case because
the slot @code{:is-a} is pre-defined by the system as a relation.

@section Object-Oriented Programming
@anchor{object-oriented-prog}
@node Object-Oriented Programming

This section describes the object-oriented programming component of
KR. This component entails two concepts: the concept of message
sending, and the concept of prototype/instance.

@cindex{object-oriented programming}

@node Objects
@subsection Objects


The fundamental data structure in KR is the @emph{schema}, which is equivalently
referred to as an @emph{object}. Objects consist of data
(represented by values in slots) and methods (represented by
procedural attachments, again stored as values in slots). Methods are
similar to functions, except that a method can do something different
depending on the object that it is called on.
A procedural attachment is invoked by "sending  a
message" to an  object; this means that a method by the
appropriate name is sought and executed. Different objects often
provide different methods by the same name, and thus respond to the
same message by performing different actions.

@cindex{sending messages}
@cindex{messages}

The data and methods associated with an object can be either stored
within the object or inherited. This allows the behavior of objects
to be built up from that of other objects. The object-oriented
component of KR allows some combination of methods , since a method is allowed to invoke the corresponding
method from an ancestor schema and to explicitly refer to the object
which is handling the message. Method combination, however, is not as
developed as in full-fledged object-oriented programming systems such
as CLOS @cite{CLOS-X3J13}.

@cindex{method combination}

@node  Prototypes vs.Classes
@subsection Prototypes vs. Classes


The notion of  @emph{prototype} in KR is superficially similar to that of @emph{class} in
conventional object-oriented programming languages, since a prototype
object can be used to partially determine the behavior of other
objects (its @emph{instances}) . A prototype, however,
plays a less restricting role than a class. Unlike classes,
prototypes simply provide a place from which the values of certain
slots may be inherited. The number and types of slots which actually
appear in an instance is not in any way restricted by the
prototype . The same is true for
methods, which are simply represented as values in a slot.

@cindex{prototype/instance}
@cindex{prototypes}
@cindex{instance}
@cindex{objects and inheritance}

Prototypes in KR serve two specific functions: they provide an
initialization method , and they provide
default  constraints .
When a KR schema is created via the function
@code{create-instance} , and its prototype has an
@code{:initialize}  method, the method is invoked
on the instance itself. This results in a uniform mechanism for handling
object-dependent initialization tasks.

@cindex{object initialization}
@cindex{default constraints}
@cindex{object constraints}
@cindex{create-instance}
@cindex{initialize method}

@subsection Inheritance of Formulas
@node  Inheritance of Formulas

@cindex Formulas
@cindex Inheritance

If a prototype provides a constraint for a certain slot, and the slot
is not explicitly redefined in an instance, the formula which
implements the constraint is copied down and installed in the instance
itself. The formula, however, is not actually copied down until a
value is requested for that slot (e.g., when @code{gv} is used).  This
is a convenient mechanism through which a prototype may partially
determine the behavior of its instances. Note that this behavior can
be overridden both at instance-creation time (by explicitly specifying
values for the instance) and at any later point in time.

@cindex{inherited formulas}



@section Constraint Maintenance


This section describes the constraint maintenance component of KR.
The purpose of constraint maintenance is to ensure that changes to a
schema are automatically propagated to other schemata which depend on
it.



@node  ValuePropagation
@subsection Value Propagation

The KR constraint system  offers two distinct
mechanisms to cause changes in a part of network to propagate to other
parts of the network. The first mechanism, @emph{value propagation}, ensures
that the network is kept in a consistent state after a change. The second
mechanism, @emph{demon invocation}, allows certain actions to be triggered
when parts of a network are modified. Demons are described in section
@ref{demons}.

@cindex{constraint maintenance}

Value propagation is based on the notion of @emph{dependency} of a value
on another. Value dependencies are embodied in formulas. Whenever a
value in a slot is changed, all slots whose values depend on it are
immediately invalidated, although not necessarily re-evaluated. This
strategy, known as lazy evaluation, does not immediately recompute the
values in the dependent slots, and thus it typically does less
work  than an
eager  re-evaluation strategy. The system simply
guarantees that correct
values are recomputed when actually needed.

@cindex{lazy evaluation}
@cindex{eager evaluation}

@node Formulas
@subsection Formulas

@cindex{Formulas}

Formulas represent one-directional connections between a
@emph{dependent value} and any number of @emph{depended values}. Formulas
specify an expression which computes the dependent value based upon the
depended values, as well as a permanent dependency which causes the
dependent value to be recomputed whenever any of the other values change.

Formulas can contain arbitrary Lisp expressions, which generally
reference at least one particular depended value. The Lisp
expression is used to recompute the value of the formula whenever a
change in one of the depended values makes it necessary.

Formulas are not recomputed immediately  when one of
the depended values changes. This reduces the amount of unnecessary
computation. Moreover, formulas are not recomputed every time their value
is accessed. Each formula, instead, keeps a cache of the last value it
computed. Unless the formula is marked invalid, and thus needs to be
recomputed, the cached value  is simply reused. This
factor causes a dramatic improvement in the performance of the constraint
maintenance system, since under ordinary circumstances the rate of change
is low and most changes are local in nature.

@cindex{lazy evaluation}
@cindex{cached values}

@float Figure,fig:ex1
@center @image{formulas, 5.5in}
@caption{Successive changes in depended values}
@anchor{formulas}
@end float


@ref{fig:ex1}, part @b{(a)}, shows an example of a formula
installed on slot @code{:y} of schema @code{point-2}. The formula depends on
two values, i.e., the value of slots @code{:y1} and @code{:y2} in schema
@code{point-1}. The formula specifies that slot @code{:y} is constrained to be
the sum of the two values divided by 2, i.e., the average of the two
values. @ref{fig:ex1}, part @b{(b)}, shows the internal state of
the formula in a steady-state situation where the formula contains a valid
cached value. Under these circumstances, any request for the value of slot
@code{:y} would simply return the cached value, without recomputing the
formula.

Parts @b{(c)} and @b{(d)} show the effects of changes to the depended
values. Changes are illustrated by small rectangles surrounding the
modified information. The first change is to slot @code{:y1} and
causes the value in the formula to be marked invalid.  Note that the
formula is not actually recomputed at this point, and the cached value
is left untouched. The second change is to slot @code{:y2} and does
not cause any action to occur, since the formula is already marked
invalid.

@cindex{value propagation}

Finally, part @b{(e)} shows what happens when the value in slot @code{:y} is
eventually needed. The value of the formula is recomputed and again cached
locally; the cache is marked as valid. The system is then back to steady
state. Note that the formula was recomputed only once, when needed, rather
than eagerly after each value changed.



@node Circular Dependencies
@subsection Circular Dependencies

Constraints may involve circular chains  of
dependency. Slot A, for instance, might depend on slot B, which in turn
depends on slot A; see section @ref{degrees} for an example of a situation
where this arises fairly naturally. Circular dependencies may also be used to
provide a limited emulation of two-way constraint maintenance.

@cindex{circular constraints}

KR is able to deal with circular dependencies without any trouble. This is
handled during formula evaluation; if a formula is evaluated and requests a
value which depends of the formula itself, the cycle is broken and the
cached value of the formula is used instead. This algorithm guarantees
that the network is left in a consistent state, even though the final
result may of course depend on where evaluation started from.



@node Dependency Paths
@subsection Dependency Paths

Typical formulas contain embedded references to other values and
schemata. The formula in Figure @ref{formulas}, for example, contains
an indirect reference to schema @code{point-1} through the contents of
the @code{:other} slot. Such references are known as
dependency  paths .
Whenever a formula is evaluated, its dependency paths are used to
recompute the updated value.

@cindex{dependency paths}
@cindex{paths in formulas}

It is possible for a dependency path to become temporarily unavailable.
This would happen, for instance, if schema @code{point-1} in Figure
@ref{formulas} was deleted, or if slot @code{:other} in schema
@code{point-2} was temporarily set to @value(nil). KR handles such
situations automatically. If a formula needs to be evaluated but one
of its dependency paths is broken, the current cached value of the
formula is simply reused. This makes it completely safe to modify
schemata that happen to be involved in a dependency path, since the
system handles the situation gracefully.



@node Constraints and Multiple Values
@subsection Constraints and Multiple Values

Unlike earlier versions of KR, version @value{GARNETVER} supports constraints
on multiple values  in a slot. The functional
interface, however, is not complete and therefore certain operations are
not fully supported at the time of this writing. Functions which support
constraints on multiple values are easily identified because they accept a
@emph{position} parameter which determines what value is affected.

@cindex{multiple values}

The interaction between constraints and multiple values will be completely
specified in future versions of KR. For the time being, most applications
should simply be aware that constraints on the first value in a slot are
supported universally, whereas some of the functionality may be unavailable
for constraints on values other than the first one.
