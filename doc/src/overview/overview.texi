@chapter Overview
@node Overview

@rmacro redtext{text}
@tex
  \\def\\rgbMyRed{1 0 0}
  \\def\\maincolor{\\rgbMyRed}
  \\pdfsetcolor{\\maincolor}
@end tex

\text\

@tex
  \\def\\rgbMyBlack{0 0 0}
  \\def\\maincolor{\\rgbMyBlack}
  \\pdfsetcolor{\\maincolor}
@end tex

@end rmacro



@section Introduction
@node Introduction
The Garnet research project in the School of Computer Science at Carnegie
Mellon University is creating a comprehensive set of tools which make it
significantly easier to create graphical, highly-interactive user
interfaces. The lower levels of Garnet are called the ``Garnet Toolkit,''
and these provide mechanisms that allow programmers to code user interfaces
much more easily. The higher level tools allow both programmers and
non-programmers to create user interfaces by just drawing pictures of what
the interface should look like. 
Garnet stands for @b{G}enerating an
@b{A}malgam of @b{R}eal-time, @b{N}ovel @b{E}ditors and @b{T}oolkits.

At the time of this writing, the Garnet toolkit is in use by about
80 projects throughout the world.
This document contains an overview, tutorial, and a full set of reference
manuals for the Garnet System. 

@b[This manual describes version 3.0 of Garnet. It replaces all
previous versions and the change documents for versions 1.3, 1.4, 2.0, 2.1,
and 2.2.]

Garnet is written in Common Lisp and can be used with either Unix systems
running X windows or on the Mac. Therefore,
Garnet is quite portable to various environments.
It works in virtually any Common Lisp environment, including Allegro (Franz),
Lucid, CMU, Harlequin, CLISP, AKCL, and Macintosh Common Lisps.
The computers we
know about it running on include Sun, DEC, HP, Apollo, IBM RT, IBM
6000, TI, SGI, NeXTs running X11, PC's running Linux, Macs,
and there may be others. Currently,
Garnet supports X11 R4 through R6 using the standard CLX interface.
Garnet does @emph{not} use the standard Common Lisp Object System (CLOS) or
any X toolkit (such as Xtk or CLIM).

Garnet has also been implemented using the native Macintosh QuickDraw and
operating system.
To run the Macintosh version of Garnet, you need to have System 7.0 or
later, Macintosh Common Lisp (MCL) version 2.0.1 or later, and at
least 8Mb of RAM. The system takes about 10 megabytes of disk space
on a Mac, not including the documentation (which takes an additional 8
megabytes). We find that performance of Garnet on MCL is acceptable
on Quadra's, and fine on a Quadra 840 A/V. It is really too slow on a
Mac II. To do anything useful, you probably need 12mb of memory. A
PowerPC Mac does not work well for Lisp (see discussion on
@code{comp.lang.lisp.mcl}).

More details about Garnet are available in the Garnet FAQ:
@code{ftp://a.gp.cs.cmu.edu/usr/garnet/garnet/FAQ}
which is posted periodically.

This document is a technical reference manual for the entire Garnet system.
There have been many conference and journal papers about Garnet
(see section @ref{articles} for a complete bibliography).
The best overview of Garnet is @ref{GarnetIEEE}. Section @ref{articles}
includes instructions for retrieving some Garnet papers via FTP.

@cindex{amulet}
A new project named Amulet is actively developing a system with features
similar to those in Garnet, but implemented in C++. Section @ref[future]
discusses how to get more information about the Amulet project.


@section Garnet Bulletin Board
@node Garnet Bulletin Board
@cindex{bugs (reporting)}
@cindex{garnet-users}
@cindex{bboard}

There is an international bboard for Garnet users named
@code{comp.windows.garnet}. Topics discussed on this bboard include user
questions and software releases. There is also a mailing list called
@code{garnet-users@@cs.cmu.edu} which carries exactly the same messages as the
bboard. If you cannot read the bboard in your area, please send mail
to @code{garnet-users-request@@cs.cmu.edu} to get on the mailing list.

You can report bugs to @code{garnet-bugs@@cs.cmu.edu} which is read only by
the Garnet developers.


 
@section Important Features of Garnet
@node Important Features of Garnet
@cindex{Features}
Garnet has been designed as part of a research project, so it contains a
number of novel and unique features. Some of these are:
@itemize
The Lapidary tool is the only interactive tool that allows
application-specific graphics and new widgets to be created without
programming.

The Garnet Toolkit is designed to support the @emph{entire} user interface of an
application; both the contents of the application window and its menus and
dialog boxes. For example, Garnet directly supports selecting graphical
objects with the mouse, moving them around, and changing their size.

It is @emph{look-and-feel independent}. Garnet allows the programmer to
define a new graphical style, and use that throughout a system. Alternatively,
a pre-defined or standard style can be used, if desired.

It uses a @emph{prototype-instance} object model instead of the more conventional
class-instance model, so that the programmer can create a @emph{prototype} of
a part of the interface, and then create instances of it. If the prototype
is changed, then the instances are updated automatically.
Garnet's custom object system is called KR. Garnet does not use CLOS.

@emph{Constraints} are integrated with the object system, so any slot
(also called an ``instance variable'') of any object can contain a
formula rather than a value. When a value that the formula references
changes, the formula is re-evaluated automatically. Constraints can be
used to keep lines attached to boxes, labels centered within
rectangles, etc. (see Figure @ref{toolkit-SampleFig}). Constraints can also be
used to keep application-specific values connected with the values of
graphical objects, menus, scroll bars or gauges in the user interface.

Objects are @emph{automatically refreshed} when they change. Pictures are
displayed by creating graphical objects which are retained. If a slot of
an object is changed, the system automatically redraws the object and any
other objects that overlap it. Also, the system handles window refresh
requests from X and the Mac.

The programmer specifies the handling of
input from the user at a high level using abstract
@emph{interactor} objects. Typical user interface behaviors
are encapsulated into a few different types of interactors, and the
programmer need only supply a few parameters to get objects to respond to
the mouse and keyboard in sophisticated ways.

There is built-in support for laying out objects in @emph{rows and columns},
for example, for menus, or in @emph{graphs or trees}, for example, to
show a directory structure or a dependency graph.

Two complete sets of @emph{gadgets} (also called widgets or interaction
techniques) are provided to help the programmer get started.
These include menus, buttons, scroll bars, sliders, circular gauges, graphic
selection, scrollable windows, and arrows.
One set has the Garnet look and feel, and the other has
the Motif look and feel. The Motif set is implemented entirely in
Lisp on top of Garnet, to provide maximum flexibility. Note: There are no
Macintosh look-and-feel gadgets. When you use Garnet on the Macintosh,
the gadgets will @b{not} look like standard Macintosh widgets.

Garnet is designed to be @emph{efficient}. Even though Garnet handles many
aspects of the interface automatically, an important goal is that it
execute quickly and not take too much memory. We are always
working to improve the efficiency, but Garnet can currently handle dozens
of constraints attached to objects that are being dragged with the mouse.

Garnet will automatically produce PostScript for any picture on the
screen, so the programmer does not have to worry about printing.

Gesture recognition (such as drawing an "X" over an object to delete
it) is supported, so designers can explore innovative 
user interface concepts.
@end itemize


@section Coverage
@node Coverage
@cindex{Coverage}
Garnet is designed to handle interfaces containing a number
of graphical objects which the user can manipulate with the mouse and
keyboard.

Garnet is suitable for applications of the following kinds:

@itemize
User interfaces for expert systems and other AI applications.

Box and arrow diagram editors like Apple Macintosh MacProject (which helps
with project management).

Graphical Programming Languages where computer
programs can be constructed using icons and other pictures (a common
example is a flowchart).

Tree and graph editing programs, including editors for semantic
networks, neural networks, and state transition diagrams.

Conventional drawing programs such as Apple Macintosh MacDraw.

Simulation and process monitoring programs where the user interface shows the
status of the simulation or process being monitored, and allows the user to
manipulate it.

User interface construction tools (Garnet was implemented using itself).

Some forms of CAD/CAM programs.

Icon manipulation programs like the Macintosh Finder (which allows users to
manipulate files).

Board game user interfaces, such as Chess.
@end itemize

Figure @ref{toolkitpic} shows a simple Garnet application that
was created from start to finish (including debugging) in three hours.
The code for this application is shown in the sample program manual,
which begins on page @ref{fig:ex1}.

@float Figure,fig:ex1
@center @image{toolkitpic, 5.5in}
@caption{A sample Garnet application. The code for this application is
listed the "Sample Garnet Program" section of this manual, starting on
page @ref{sampleprog-first-page.}}
@end float
@anchor{toolkitpic}

Other examples of applications created using Garnet appear in the picture
section of this manual, starting on page @ref{apps}.


@section Running Garnet From /afs
@node Running Garnet From /afs

If you are running Garnet in X windows from CMU, or if you have access
to AFS, you can access Garnet directly on the @code{/afs} servers. We maintain
binaries of the official release version in machine- and
lisp-specific subdirectories of @code{/afs/cs/project/garnet/}. If you are
at CMU, you can skip section @ref{retrieving} altogether, and just start lisp
and load Garnet with:

@code{(load "/afs/cs/project/garnet/garnet-loader.lisp")}

The CMU version of @code{garnet-loader.lisp} will attempt to determine what
kind of machine and lisp you're using, and load the appropriate binaries
for you. You will not have to supply or customize any pathnames.


@section How to Retrieve and Install Garnet
@node How to Retrieve and Install Garnet
@anchor{retrieving}
@cindex{Getting Garnet}
@cindex{retrieving Garnet}
@cindex{installing Garnet}
@cindex{compiling Garnet}
@cindex{Address}
@cindex{License}
@cindex{FTP Instructions}

Garnet is available for free by anonymous FTP. There are different
instructions for obtaining the software depending on whether it will
be installed on a Mac or a Unix system (the code is the same, but the
packaging is different).

@subsection Installation on a Mac
@node Installation on a Mac
@sp 1

@b[Retrieving the Stuffit Files:]

Garnet 3.0 is available in @code{Stuffit} files that include the
sources, the library files, the binary files compiled for
Macintosh Common Lisp 2.0.1, and documentation. To download the Garnet
collection
that includes MCL binaries, use FTP or Fetch (a Mac file transfer utility)
to connect to @code{a.gp.cs.cmu.edu} (@code{128.2.242.7}) and login as
@code{``anonymous''} with your e-mail address as the password. Change
to "binary" mode for FTP, or stay in "automatic" mode for Fetch, and
download the @code{Stuffit} archive
@code{/usr/garnet/garnet/mac.sit}
Alternatively, you can get the BinHex version in text mode by
retrieving
@code{/usr/garnet/garnet/mac.sit.hqx}
If you are using Fetch, it will automatically convert the BinHex file into
a binary @code{.sit} file after it is installed on your Mac. If you used FTP to
get the @code{.hqx} file, you will need to BinHex4 Decode the file.
You should also retrieve one version of the documentation file:
@example
/usr/garnet/garnet/doc.sit
/usr/garnet/garnet/doc.sit.hqx
@end example

If you do not have a version of @code{Stuffit}, you can also download the copy of
@code{Stuffit_Expander} from the same directory to uncompress the Garnet archive.
The @code{Stuffit} utility is a self-extracting archive that you only need to
double-click on to install on your Mac. Be sure to use binary
transfer mode in FTP if you are retrieving @code{StuffIt_Expander_.sea}.


@b[Unpacking the Stuffit Files:]

Once you have downloaded the @code{.sit} or @code{.sit.hqx} archives
(and installed the @code{Stuffit_Expander}, if necessary), launch the
@code{Stuffit} utility. Next, "Expand..." or "Open" the @code{mac.sit} archive,
and choose a folder into which the uncompressed Garnet folder will be
expanded. The instructions below assume you have installed the
uncompressed folder at the top-level of your hard drive, and that your
hard drive is named "Macintosh HD" (i.e., the uncompressed folder will
become "Macintosh HD:Garnet:"). It is a good idea to expand the @code{doc.sit}
archive in the Garnet folder that was created by the first archive.
For further instructions about printing the documentation, consult the
README file in the doc folder.

@sp 1

@b[Preparing MCL Before Loading Garnet:]

When using Garnet, you may need to increase the amount of memory that is
claimed by the Lisp application. You can change the memory claimed by MCL by
selecting the MCL application in the Macintosh Finder and choosing "Get Info"
from the Finder's "File" menu. Most Garnet applications will require that
MCL use at least 6Mb of RAM, and using at least 12Mb is recommended.
The default "Preferred size" for MCL is 3072K, so you will need to edit that
value to be upwards of 6000K. You are only allowed to change this
information when the application is NOT running, and it should be done before
proceeding with the rest of these instructions. Note: All Lisp images saved
from the MCL application will retain the new "Preferred size" value.

Before loading Garnet, you will need to compile several MCL library files
that are used by Garnet. A compiler script for this procedure is provided in
the Garnet collection. In the fresh MCL listener, load the file "Macintosh
HD:Garnet:compile-mcl-libraries.lisp" (replacing the hard drive prefix with
whatever is appropriate for your machine). After the script is finished,
quit MCL and then launch MCL again.


@b[Loading Garnet:]

Using the MCL text editor, edit the file @code{garnet-loader.lisp} from the new
Garnet folder (choose "File...", "Open..." from the MCL menubar to edit
a file). Find the definition of the variable @code{Your-Garnet-Pathname}
and set its value to the path of the new Garnet folder you created with
@code{Stuffit}. All other subfolders of Garnet will be computed relative to this
pathname. Save the new version of the @code{garnet-loader.lisp} file.

In the fresh lisp listener, load "Macintosh HD:Garnet:garnet-loader.lisp"
(using whatever prefix is appropriate instead of "Macintosh HD:Garnet:").
Garnet will inform you as it loads each module, and will finally return with
a prompt. At this point, Garnet is fully loaded and you are ready to try
the Tour or some demos as discussed later in this manual.



@subsection Installation on a Unix System
@node Installation on a Unix System


When running on X windows, Garnet uses the CLX interface from Lisp to
X11. CLX should be supplied with every Lisp, and the following instructions
assume that CLX has been installed correctly on your system. If you need help
with CLX, you need to contact your Lisp vendor. We cannot help you
acquire, compile, or install CLX, sorry.


@b{Retrieving the TAR Files:}

The Garnet software is about 9 megabytes. In order to make it easy to
copy the files over, we have created TAR files, so to use the
mechanism below requires double the storage area. Therefore, you
first need to find a machine with enough room, and then create a
directory called @code{garnet} wherever you want the system to be:
@example
	% mkdir garnet
@end example

@page
Then, cd to the @code{garnet} directory.
@example
	% cd garnet
@end example
Now, ftp to @code{a.gp.cs.cmu.edu (128.2.242.7)}. When asked to log in, 
use @code{anonymous}, and your name as the password.
@example
   % ftp a.gp.cs.cmu.edu
   Connected to A.GP.CS.CMU.EDU.
   220 A.GP.CS.CMU.EDU FTP server (Version 4.105 of 10-Jul-90 12:07) ready.
   Name (a.gp.cs.cmu.edu:bam): anonymous
   331 Guest login ok, send username@@node as password.
   Password:
   230 Filenames can not have '/..' in them.
@end example

Then change to the @code{garnet} directory (note the double
@code{garnet}'s) and use binary transfer mode:
@example
	ftp> cd /usr/garnet/garnet/
	ftp> bin
@end example

The files have all been combined into TAR format files for your convenience.
These will create the appropriate sub-directories automatically. We
have both compressed and uncompressed versions. For the regular
versions, do the following:
@example
	ftp> get src.tar
	ftp> get lib.tar
	ftp> get doc.tar
@end example

To get the compressed version, do the following:
@example
	ftp> get src.tar.Z
	ftp> get lib.tar.Z
	ftp> get doc.tar.Z
@end example

Now you can quit FTP:
@example
	ftp> quit
@end example


@b{Installing the Source Files:}

If you got the compressed versions, you will need to uncompress them:
@example
	% uncompress src.tar.Z
	% uncompress lib.tar.Z
	% uncompress doc.tar.Z
@end example

Now, for each tar file, you will need to "untar" it, to get all the original
files:
@example
	% tar -xvf src.tar
	% tar -xvf lib.tar
	% tar -xvf doc.tar
@end example

This will create subdirectories will all the sources in them. At this point
you can delete the original tar files, which will free up a lot of space:
@example
	% rm *.tar
@end example

Now, copy the files @code{garnet-loader.lisp}, @code{garnet-compiler.lisp}, 
@code{garnet-prepare-compile.lisp}, and @code{garnet-after-compile} from the
src directory into the @code{garnet} directory:
@example
	% cp src/garnet-*  .
@end example


@b{Customizing the PathNames:}

The file @code{garnet-loader.lisp} contains variables that should be set with
the pathnames of your Garnet directory and the location of CLX for your lisp.
You will now need to edit @code{garnet-loader.lisp} in an editor, and set
these variables. Comments in the file will direct you how
to do this. At the top of the file are the two variables you will need to set:
@code{Your-Garnet-Pathname} and @code{Your-CLX-Pathname}. NOTE: If CLX is already
loaded in your lisp image, you do not need to set the CLX variable.


@page
@b{Compiling Garnet to Make Binary Files:}

Lisp requires very large address spaces. We have found on many Unix
systems, that you need to expand the area that it is willing to give
to a process. The following commands work in many systems. Type
these commands to the C shell (csh). You might want to also put these
commands into your @code{.login} file.
@example
	% unlimit datasize
	% unlimit stacksize
@end example

Now, you will need to compile the Garnet source to make your own binaries.
This is achieved by loading the compiler scripts. There is more information
on compiling in section @ref{compilinggarnet} below, and special
instructions for compiling Garnet in CLISP are in section @ref{clisp}.
@example
        @emph{;; Only LispWorks users need to do the next two commands. See section @ref{lispworks}.}
        lisp> #+lispworks (load "src/utils/lispworks-processes.lisp")
        lisp> #+lispworks (guarantee-processes)

	lisp> (load "garnet-prepare-compile")
	lisp> (load "garnet-loader")
	lisp> (load "garnet-compiler")
@end example

Now Garnet is all compiled and loaded, but a shell script still needs to be
executed to separate the binary files from the source files. To set up
for the next time, it is best to quit lisp now, and
run the @code{garnet-after-compile} shell script.
If your sources are not in a directory named @code{garnet/src} or your binaries
should not be in a directory named @code{garnet/bin}, then you will need to
edit @code{garnet-after-compile} to set the directories. Also, if your
compiler produces binary files that do not have one of the following
extensions, then you need to edit the variable @code{CompilerExtension} in
@code{garnet-after-compile}: ".fasl", ".lbin", ".sbin", ".hbin", ".sparcf",
".afasl", or ".fas". Otherwise, you
can just execute the file as it is supplied (NOTE: this is run from
the shell, not from Lisp). You should be in the @code{garnet} directory.
@example
	% csh garnet-after-compile
@end example

Now you can start lisp again, and load Garnet:
@example
	lisp> (load "garnet-loader")
@end example

Details about how to customize the loading of Garnet are provided in
section @ref{loading-garnet}.

@section Directory Organization
@node Directory Organization
@cindex{Directories}
@cindex{src}
@cindex{doc}
@cindex{garnet-loader}
@cindex{garnet-version-number}

All of the information about where various files of Garnet are stored is
in the file @code{garnet-loader.lisp}. This file also defines the Garnet
version number:
@example
* user::Garnet-Version-Number
"3.0"
@end example

You may need to edit the @code{garnet-loader} file to
tell Garnet where all the files are. Normally, there
will be a directory
called @code{garnet} with sub-directories called @code{src}, @code{lib} and
@code{bin}. In the @code{src} and @code{bin} directions will be sub-directories
for all the parts of the Garnet system:
@itemize
@code{utils} - Utility files and functions.

@code{kr} - KR object system.

@code{gworld} - Mac routines for off-screen drawing (only used on the Mac)

@code{gem} - Garnet's interface to machine-specific graphics routines (X and Mac)

@code{opal} - Opal Graphics management system.

@code{inter} - Interactors input handling.

@code{aggregadgets} - Files to handle aggregates and lists.

@code{gadgets} - Pre-defined gadgets, such as menus and scroll bars.

@code{gesture} - Tools for handling gestures as input.

@code{ps} - Functions for printing Garnet windows with PostScript.

@code{debug} - Debugging tools.

@code{demos} - Demonstration programs written using Garnet.

@code{gilt} - The Gilt interface builder.

@code{c32} - A spreadsheet for editing constraints among objects.

@code{lapidary} - The Lapidary interactive tool.

@code{contrib} - Files contributed by Garnet users that are not
supported by the Garnet group, but just provided for your use.
@end itemize

@section Site-Specific Changes
@node Site-Specific Changes
@cindex{Site specific changes}
@cindex{Machine-specific features}
If you are transferring Garnet to your site, you will need to make a
number of edits to files in order for Garnet to load, compile and
operate correctly. All users will need to edit the Garnet pathnames as
discussed in section @ref{pathnames}, but relatively few users should need
the other sections @ref{optimization-settings} - @ref{clisp}. Garnet has
been adjusted to load on the widest possible variety of lisps and operating
systems with minimum modification.

Of course, if you change any @code{.lisp} files in the Garnet subdirectories
(not including @code{garnet-loader.lisp}), you will need to
recompile them (section @ref{garnet-load}), even if you do not need to
recompile other parts of Garnet.

@subsection Pathnames
@node Pathnames

@anchor{pathnames}
@cindex{pathnames}
@cindex{file names}
@cindex{Garnet-loader}
@cindex{garnet-version}

After you have copied Garnet to your machine and untar'ed the source files,
the top level Garnet directory will contain the file
@code{garnet-loader.lisp}. This one file contains the file names for all the
parts of Garnet. You should edit this file to put in your own file names.
The best way to do this is to set the @code{Garnet-Version} to be
@code{:external} and edit the string
at the top of the file called @code{Your-Garnet-Pathname} to say where the
files are. This change is normally done during the compile procedure,
already described in section @ref{retrieving}.

@subsection Compiler Optimization Settings
@node Compiler Optimization Settings
@anchor{optimization-settings}

The variable @code{user::*default-garnet-proclaim*}, defined in
@code{garnet-loader.lisp}, holds a list of
compiler optimization flags and default values. These flags determine things
like the size and speed of your resulting Garnet binaries.
For example, the default value of this variable in Allegro is:

@example
'(optimize (speed 3) (safety 1) (space 0) (debug 3))
@end example

This optimization causes Allegro to generate compiled binaries that
are as fast and small as possible. The @emph{safety} setting of 1 means
that the compiled code will allow keyboard interrupts if you somehow
go into an infinite loop, and the @emph{debug} setting of 3 means you
will get the most helpful error messages that Allegro can give you
when you are thrown into the debugger.

Different implementations of lisp require different values for the
optimization flags, and @code{garnet-loader.lisp} provides values for
Allegro, Lucid, CMUCL, LispWorks, and MCL that we have found work particularly
well. You can override the default optimizations by defining the
@code{*default-garnet-proclaim*} variable before loading
@code{garnet-loader.lisp}. A value of NIL for this variable means that
you want to maintain the declarations that are already in effect
for your lisp.


@subsection Fonts in X11
@node Fonts in X11
@cindex{Fonts}
@cindex{text-fonts.lisp}

In X11 R4 through R6, there are almost always a full set of fonts available
with standard names. Garnet relies on these fonts being available on the
standard font paths set up by X11. You can try loading Garnet and see
if it finds the standard fonts. 

If not, look in the file @code{garnet/src/opal/text-fonts.lisp}. This file
constructs font names according to the standard X11 format (with lots of
"-*-*-*"'s). You will have to substitute
the names of fonts that are available at your installation.

@subsection Keyboard Keys
@node Keyboard Keys
@cindex{Keyboard Keys}
@cindex{Key Caps}

If your keyboard has some specially-labeled keys on it, Garnet will allow
you to use these as part of the user interface. The file
@example
define-keys.lisp
@end example
which is in the @code{garnet/src/inter} sub-directory,
defines the mappings from the codes that come back from X11 and the Mac
to the special Lisp characters or atoms that define the keys in Garnet. 

For many machines, such as Suns, HP's, DECStations, and Macs,
we have built in mappings for all of the keyboard keys. Since there
are no Lisp characters for the
special keys, they are named with keywords such as @code{:uparrow} and
@code{:F1}. If some keys on your keyboard are not mapped to keywords, you
can use the following mechanism to set this up. 

@cindex{find-key-symbols}
@cindex{define-keys}
To find the correct codes to use for each undefined key, load the
Find-Key-Symbols utility with
@example
(garnet-load "inter-src:find-key-symbols.lisp")
@end example
After loading this file, simply type the keys you need to find mappings for
while input is focused on the Find-Key-Symbols window (you may have to click
on the window's title-bar to change the input focus).
Garnet will print out the code number of the keys you type.

Then, you can go into the file @code{define-keys.lisp} and edit it so the
codes you found map to appropriate keywords.

Next, you might want to bind these keys to keyboard editing operations. If
you want these to be global to all Garnet applications, then you can edit
the files
@cindex{textkeyhandling.lisp}
@code{textkeyhandling.lisp}
and
@code{multifont-textinter.lisp}
which contain the default mappings of keyboard keys to text editing
operations. The Interactors Manual contains full more information on how
this works.

@b[If you surround your changes to all these files with
@code{#+<your-switch>} and mail them back to us
(@code{garnet@@cs.cmu.edu}), then we will incorporate them into future
versions so you won't need to continually edit the files.]

@subsection Multiple Screens
@node Multiple Screens
@cindex{Garnet-Screen-Number}
@cindex{Multiple Screens}
@cindex{Screens}
If you are working on a machine with only one screen, you need
not pay attention to this section.
However, certain machines, such as the color Sun 3/60, have more
than one screen. The color Sun 3/60 has
both a black-and-white screen (whose display name is "unix:0.0")
and a color screen (whose display name is "unix:0.1"). If you type
"echo $DISPLAY" in a Unix shell, you will get 
the display name of the screen you are working on; that name should
look like "unix:0.*" where * is some integer.

Garnet assumes that the DISPLAY environment variable has this form of
"displayname:displaynumber.screennumber", and extracts the display and
screen numbers from that. If any fields are missing, then the missing display
or screen number defaults to zero.


@subsection OpenWindows Window Manager
@node OpenWindows Window Manager
@cindex{OpenWindows}
@cindex{FocusLenience}

If you are running OpenWindows from Sun, you will need to add
the following line to your @code{.Xdefaults} file to make text input work
correctly:
@example
	OpenWindows.FocusLenience:		True
@end example


@subsection LispWorks
@node LispWorks
@anchor{lispworks}
@cindex{Harlequin}
@cindex{lispworks}
@cindex{guarantee-processes}

LispWorks is the common lisp sold by Harlequin Ltd. There is one peculiarity
about LispWorks that requires an additional step
before executing the @code{main-event-loop} background process of Garnet
(Garnet uses multiprocessing by default in LispWorks -- see the Interactors
Manual, section "The Main Event Loop" for details). You need to perform this
step both when @b{compiling} and @b{loading} Garnet (the appropriate steps
are mentioned during the standard compile procedure in section
@ref{retrieving}).

LispWorks has an unconventional "initialization phaze" to multiprocessing,
which requires that a special function be called before launching a background
process. There are two ways to initialize multiprocessing in LispWorks.
One way is to start the big window-oriented LispWorks interface by
executing @code{(tools:start-lispworks)}. This will cause a menu to
appear, and you can open a lisp listener as a selection from the menu.
From this listener, you can load @code{garnet-loader.lisp}, and Garnet's
main-event-loop process will be launched by default.

If you do not need all the functionality of the LispWorks interface, you can
initialize multiprocessing with much less overhead. Before loading Garnet,
load the file @code{"src/utils/lispworks-process.lisp"} and execute the function
@code{guarantee-processes} to start multiprocessing. For example, at the
LispWorks prompt you could type:

@example
@b[>] (garnet-load "utils-src:lispworks-process.lisp")
@b[>] (guarantee-processes)

@emph{;; At this point, a new lisp listener has been spawned}
@b[>] (load "garnet/garnet-loader")
@end example

It is @b{important} to realize that when you call @code{guarantee-processes},
a @b{new} lisp listener is spawned, and all subsequent commands will be typed
into the second listener. Putting the @code{guarantee-processes} call at the top
of the @code{garnet-loader.lisp} file will not work, because the first listener
will remain hung at the @code{guarantee-processes} call, while the second
process is waiting for user input.

On the other hand, it has been reported that putting the special steps for
LispWorks in a @code{.lispworks} file may serve to automate the process a bit.
To automatically initialize multiprocessing whenever LispWorks is started,
put the following lines in your @code{.lispworks} file:
@example
(progn
  (load "<your-garnet-pathname>/src/utils/lispworks-process.lisp")
  (guarantee-processes))
@end example
You will not be able to call @code{garnet-load} from your @code{.lispworks} file
because the function will not have been defined when the file is read.

Whenever you enter the debugger of the new listener spawned by
@code{guarantee-processes}, you will get restart options that include:

@example
...
5 (abort) return to level 0.
6 Return to top level
7 Return from multiprocessing
@end example

When you want to exit the debugger, you should choose either
"(abort) return to level 0," or "Return to top level", since both of these
options will return you to the top-level LispWorks prompt. If you ever
choose "Return from multiprocessing", then you will kill both the
second listener and the main-event-loop-process, and you will have to call
@code{guarantee-processes} and @code{opal:launch-main-event-loop-process}
to restart Garnet's main-event-loop process.

It is not necessary to load @code{"lispworks-process.lisp"} or execute
@code{guarantee-processes} if you instead choose to execute
@code{tools:start-lispworks}.



@subsection CLISP
@node CLISP
@cindex{clisp}
@anchor{clisp}

CLISP is a Common Lisp (CLtL1) implementation by Bruno Haible of
Karlsruhe University and Michael Stoll of Munich University, both in
Germany. There are a couple of additional steps you must take to run
Garnet in CLISP that are not required in other lisps.


@b{Renaming .lisp files to .lsp}

If you have an older version of CLISP, you will have to rename
all of the source files from ".lisp" to ".lsp"
before starting the procedure to compile Garnet. A @code{/bin/sh} shell script
has been provided to automate this process in the file
@code{src/utils/rename-for-clisp}. This script requires that you @code{cd} into
the @code{src} directory and execute

@code{% sh utils/rename-for-clisp}

The script will rename all of the @code{"src/*/*.lisp"} files to @code{".lsp"},
so that they can be read by CLISP.


@b{Obtaining CLX}

If you are already using CLISP, you may need to additionally retrieve the
CLX module. CLX for CLISP can be retrieved via @code{ftp} from
@code{ma2s2.mathematik.uni-karlsruhe.de}, in the file
@code{/pub/lisp/clisp/packages/pcl+clx.clisp.tar.z}.


@b{Making a Garnet image}

Once you have installed the CLX module, you can make a restartable image of
Garnet with the following procedure (NOTE: this is different from other lisps).
This is the standard procedure for compiling Garnet, followed by a dump of
the lisp image.

@example
clisp -M somewhere/clx.mem
> (load "garnet-prepare-compile.lsp")
> (load "garnet-loader.lsp")
> (load "garnet-compiler.lsp")
> (opal:make-image "garnet.mem" :quit t)
@end example

The saved image can then be restarted with the command:

@code{clisp -M garnet.mem}



@subsection AKCL
@node AKCL

Some of the default parameters for the AKCL lisp image are insufficient
for running Garnet. You may be able to change some of these parameters
in the active lisp listener, but it is probably better to rebuild your
AKCL image from scratch with the following parameter values:

@example
MAXPAGES for AKCL should be at least 10240, and

(SYSTEM:ALLOCATE-RELOCATABLE-PAGES 800)
(SYSTEM:ALLOCATE-CONTIGUOUS-PAGES 45 T)
(SYSTEM:ALLOCATE 'CONS   3500 t)
(SYSTEM:ALLOCATE 'SYMBOL  450 t)
(SYSTEM:ALLOCATE 'VECTOR  150 t)
(SYSTEM:ALLOCATE 'SPICE   300 t)
(SYSTEM:ALLOCATE 'STRING  200 t)
@end example

Garnet runs about half as fast in AKCL as on other Common Lisps. Increasing
the RAM in your machine may help. Users have reported that 16MB on a
Linux-Box 486 yields unacceptable performance.




@section Mac-Specific Issues
@node Mac-Specific Issues

@subsection Compensating for 31-Character Filenames:
@node Compensating for 31-Character Filenames:
There are several gadgets files that
normally have names that are longer than 31 characters. Mac users may
continue to specify the full-length names of these files by using
@code{user::garnet-load}, described in section @ref{garnet-load},
which translates the regular names of the gadgets into their truncated
31-character names so they can be loaded. It is recommended that
@code{garnet-load} be used
whenever any Garnet file is loaded, so that typically long and cumbersome
pathnames can be abbreviated by a short prefix.


@subsection Directories:
@node Directories:
Unlike the Unix version, the Macintosh version stores all the
binary and source files together in the various subdirectories under
"src". This difference will not matter when a Garnet application is
moved between Unix and Mac platforms as long as @code{garnet-load} is being
used to load Garnet files. @code{Garnet-load} will always knows where to
find the files.

@subsection Binding Keys:
@node Binding Keys:
We have assigned Lisp keywords for most of the keys on the Macintosh keyboard.
Thus, to start an interactor when the "F1" key is hit, use @code{:F1} as the
interactor's @code{:start-event}. If you want to know what a key generates, you
can use the small utility @code{Find-Key-Symbols} which has been ported to the
Mac. Execute
@code{(garnet-load "inter-src:find-key-symbols")}
to bring up a window which can perceive keyboard events and prints out the
resulting characters. The data you collect from this utility can be used in
the @code{:start-where} slot of interactors to describe events that will start
the interactor, and can be used to modify the characters generated by the
keyboard key by editing the file @code{src:inter:mac-define-keys.lisp}.

@subsection Simulating Multiple Mouse Buttons With the Keyboard:
@node Simulating Multiple Mouse Buttons With the Keyboard:
Most of the Garnet demos assume a three button mouse. To simulate this
on the Macintosh, we use keyboard keys to replace a three-button mouse.
By default, the keys are @code{F13}, @code{F14}, and @code{F15} for the left,
middle, and right mouse buttons, respectively. The real mouse button
is also mapped to @code{:leftdown}.

You can redefine the keys to be any three keys you want by setting
@code{inter::*leftdown-key*}, @code{inter::*middledown-key*}, and
@code{inter::*rightdown-key*} after loading Garnet or by editing the
file @code{src:inter:mac-define-keys.lisp} directly. These variables
should contain numerical key-codes corresponding to your desired keys.
Some key-codes are shown on p. I-251 of @emph{Inside Macintosh Volume I},
but you can also do @code{(garnet-load "inter:find-key-symbols")} to run
a utility program that tells you the key-code for any keyboard key.
The utility will generate numbers that can be used directly in
@code{src:inter:mac-define-keys.lisp}.

@cindex{mouse-keys.lisp}
To facilitate Garnet's use with keyboards not equipped with function keys,
Garnet supplies another utility program called @code{mouse-keys.lisp},
which is in the top-level Garnet directory in the Mac version (and is
in @code{src/utils/mouse-keys.lisp} if you acquired the Unix-packaged
version of Garnet). When loaded, this utility creates a window that
allows you to toggle between using
the function keys and arrow keys for the simulated mouse buttons. If
you are frequently switching between using Garnet on an Extended
Keyboard and a smaller laptop keyboard, you may use this utility a lot
to tell Garnet which keys should be used for middle-down and right-down.


@subsection Modifier Keys:
@node Modifier Keys:
Like MCL itself, Garnet treats the @code{Option} key as the "Meta" key. Also,
you currently cannot get access to the @code{Command} (Open-Apple) key
from Garnet.

@subsection Things to Keep in Mind When You Want Your Garnet Programs
@node Things to Keep in Mind When You Want Your Garnet Programs
to Run on Both X Windows and the Mac:
@itemize
Use @code{user::garnet-load} instead of @code{load} when loading gadget files

Only supply @code{:face} values for fonts that run on both systems -- this
typically restricts you to using only the standard faces available
in Garnet 2.2 and earlier versions.

The @code{#+apple} and @code{#-apple} reader macros can be used to
indicate code that should be used only for Macs and only for non-Macs,
respectively. When defining fonts, for example, you may want to
provide the slot description @code{(:face #+apple :underline #-apple :bold)}
to indicate that the font will be underlined on the Mac but bold in X.

The default place for windows is at (0,0) which unfortunately puts their
title bars under the Macintosh menubar, so you cannot even move them
using the mouse!  (You can still @code{s-value} the position from the Lisp 
Listener.)  Therefore, never create a window on the Mac with a @code{:top} less
than 45 or it will not be movable.

Remember that many Mac screens are much smaller than most workstations'
screens. Positioning windows perfectly may not be possible, and a better
goal may be to simply keep the window title-bars within reach of the
mouse so that the windows can be moved.
@end itemize


@section Compiling Garnet
@node Compiling Garnet
@anchor{compilinggarnet}
@cindex{Compiling Garnet}
@cindex{garnet-compiler}

After executing the compile procedure in section @ref{retrieving},
the result should be that all the files are compiled and loaded.
(If there was a problem and you need to restart the compile procedure,
please see below.)  The compiler scripts do @emph{not} check for compile errors.
We have attempted to make Garnet compile without errors
on all common lisps, but some lisps generate more warnings than others.

The compiler scripts compile the binaries into the same
directories as the source files. For example, all the interactor binaries
will be in @code{garnet/src/inter/} along with the source (@code{.lisp}) files.
Therefore, after the compilation is completed, you will need to move the
binaries into their own directory (e.g., @code{garnet/bin/inter}).
To do this, use the c-shell script
@example
csh garnet-after-compile
@end example
The @code{garnet-after-compile} file will normally be in the top level garnet
directory. Note that this is typed to the shell, not to Lisp. Even if you
normally run the "regular" (Bourne) shell (sh), the above command should work.

To prevent certain parts of Garnet from being compiled, set
@code{user::compile-}@emph{xxx}@code{-p} to NIL, where @emph{xxx} is replaced with the
part you do not want to compile. See the comments at the top of the file
@code{garnet-prepare-compile} for more information.

If you ever have to restart the compile process, you do not have to start
from scratch. If you have not yet moved the binary files out of the @code{src/}
directory (i.e., you have not yet run @code{garnet-after-compile}), then you
can use the files that have been compiled already instead of compiling them
again. Restart lisp, and for each Garnet module that has been compiled,
set the variable @code{user::compile-}@emph{xxx}@code{-p} to NIL to indicate that it
should not be compiled
again. Then load the three script files again in the usual order. Note:
if a module has been only partially compiled, then you must recompile the
whole module.


@section Loading Garnet
@node Loading Garnet
@anchor{loading-garnet}
@cindex{Loading Garnet}
@cindex{garnet-loader}
@cindex{load-@emph{xxx}-p}
@cindex{Garnet-@emph{xxx}-Pathname}
@cindex{Garnet-@emph{xxx}-Src}

To load Garnet, it is only necessary to load the file:
@example
(load "garnet-loader")
@end example

(Of course, you may have to preface the file name with the directory
path of where it is located. It is usually in the top level
@code{garnet} directory.)

To prevent any of the Garnet sub-systems from being loaded, simply set the
variable @code{user::load-}@emph{xxx}@code{-p} to NIL, where @emph{xxx} is replaced by
whatever part you do not want to load. Normally, some parts of the system are
not loaded, such as the gadgets and demos. This is because you normally do not
want to load or use all of these in a session. Files that use gadgets will
load the appropriate ones automatically, and the @code{demos-controller}
program loads the demos as requested.

It is possible to save an image of lisp after loading Garnet, so that when
you restart lisp, Garnet will already be loaded and you will not have to
load @code{garnet-loader.lisp}. For details about making lisp images, see
the function @code{opal:make-image} in the Opal manual.


@section Loader and Compiler Functions
@node Loader and Compiler Functions
@anchor{garnet-load}
@cindex{loading}
@cindex{compiling}
@cindex{garnet-load}
@cindex{garnet-compile}

@subsection Garnet-Load and Garnet-Compile
@node Garnet-Load and Garnet-Compile

There are two functions that allow you to save a lot of typing when
you load and compile files. When you supply @code{garnet-load} and
@code{garnet-compile} with the Garnet subdirectory that you want to get a
file from (e.g., "gadgets"), the functions will automatically
append your Garnet pathname to the front of the specified file.

@example
user::Garnet-Load "@emph{prefix}:@emph{filename}" @ref{function}

user::Garnet-Compile "@emph{prefix}:@emph{filename}" @ref{function}
@end example

These functions are defined in @code{garnet-loader.lisp} and are internal
to the @code{user} package.


@sp 1

The @emph{prefix} parameter corresponds to one of the Garnet
subdirectories, and the @emph{filename} is a file in that directory.
A list of the most useful prefixes appear in section @ref{garnet-load-alist},
and a full list can be seen by evaluating the variable
@code{user::Garnet-Load-Alist} in your lisp (after loading Garnet).
Examples:

@example
* (garnet-load "gadgets:v-scroll-loader")
Loading #p"/afs/cs/project/garnet/bin/gadgets/v-scroll-loader"
Loading V-Scroll-Bar...
...Done V-Scroll-Bar.

T
* (garnet-compile "opal:aggregates")
Compiling #p"/afs/cs/project/garnet/src/opal/aggregates.lisp"
for output to #p"/afs/cs/project/garnet/bin/opal/aggregates.fasl"
...
; Writing fasl file "/afs/cs/project/garnet/bin/opal/aggregates.fasl"
; Fasl write complete

NIL 
* 
@end example

@sp 1

There are two groups of prefixes that @code{garnet-load} accepts -- the
"bin" prefixes and the "src" prefixes. @code{Garnet-load} assumes that
when you load files, you will want to load the compiled binaries.
Therefore, when you use prefixes like "gadgets", @code{garnet-load} uses
the Garnet-Gadgets-Pathname variable to find the file you want. If
you really want to load a file from your source directory, you should
use the subdirectory name with "-src" tacked on. For example,

@example
* (garnet-load "gadgets-src:motif-parts")
Loading #p"/afs/cs/project/garnet/src/gadgets/motif-parts"
...

T
*
@end example

@code{Garnet-compile} does not accept "-src" prefixes, because it always
assumes that you want to take a lisp file from your source directory,
compile it, and output it to your bin directory. Note: do not specify
".lisp" or ".fasl" with your filename -- @code{garnet-compile} will
supply suffixes for you. @code{Garnet-compile} attempts to determine
your correct binary extension (".fasl", ".lbin", etc.) from the kind
of Lisp that you are using. If @code{garnet-compile} ever gets the
extension wrong, you can change it by setting the variable
@code{*compiler-extension*}, which is defined in the @code{user} package.


@subsection Adding Your Own Pathnames
@node Adding Your Own Pathnames
@anchor{garnet-load-alist}

The functions @code{user::garnet-load} and @code{user::garnet-compile}
look up their prefix parameters in an association list called
@code{user::Garnet-Load-Alist}. Its structure looks like:

@example
(defparameter Garnet-Load-Alist
  `(("opal" . Garnet-Opal-Pathname)          @emph{; For loading the } multifont-loader
    ("gg" . Garnet-Gadgets-PathName)         @emph{; For loading gadgets}
    ("gestures" . Garnet-Gestures-PathName)  @emph{; For loading } agate
    ("debug" . Garnet-Debug-PathName)        @emph{; For loading the } Inspector
    ("demos" . Garnet-Demos-PathName)        @emph{; For loading demos}
    ("gilt" . Garnet-Gilt-PathName)          @emph{; For loading high-level tools...}
    ("c32" . Garnet-C32-PathName)
    ("lapidary" . Garnet-Lapidary-PathName)
    ...))
@end example

This alist is expandable so that you can include your own prefixes and
pathnames. Prefixes can be added with the following function:

@cindex{add-garnet-load-prefix}
@example
user::Add-Garnet-Load-Prefix @emph{prefix pathname} @ref{function}
@end example

For example, after executing
@code{(add-garnet-load-prefix "home" "/usr/amickish/")},
you would be able to do @code{(garnet-load "home:my-file")}.




@section Overview of the Parts of Garnet
@node Overview of the Parts of Garnet
@cindex{Parts of Garnet}
@cindex{Packages in Garnet}

Garnet is composed of a number of sub-systems, some of which can be loaded
and used separately from the others. Most of the subsystems also have
their own separate packages. The following list shows the components of
Garnet, the package used by that component, and the page number of the
corresponding section in this manual.

@itemize
@code{KR} - Package @code{kr}. @cindex{kr (package)}  The object and constraint
system. @ref{kr}.

@code{Gem} - Package @code{gem}. @cindex{gem (package)}  Low-level graphics
routines that allow the system to run on the Mac or on X11. We do not
support user code directly calling Gem, so it is not described further
in this manual.

@code{Opal} - Package @code{opal}. @cindex{opal (package)}
The graphical object system. @ref{Opal}.

@code{Interactors} - Package @code{inter}. @cindex{inter (package)} Handling of
mouse and keyboard
input. @ref{Inter}.

@code{Gestures} - Package @code{inter}. Code to handle gesture recognition
and training. Described in the interactors manual, @ref{Inter}.

@code{Aggregadgets} - Package @code{opal}. Support for creating instances of
collections of objects, and for rows or columns of objects. @ref{aggregadgets}.

@code{AggreGraphs} - Package @code{opal}. Support for
creating graphs and trees of objects. Also described in the
aggregadgets manual, @ref{aggregadgets}.

@code{Gadgets} - Package @code{garnet-gadgets}, nicknamed @code{gg}.
@cindex{garnet-gadgets (package)} A collection of pre-defined
gadgets, including menus, buttons, scroll bars, circular gauges, graphics
selection, etc. @ref{gadgets}.

@code{Debugging tools} - Package @code{garnet-debug}, nicknamed @code{gd}.
@cindex{garnet-debug (package)} Useful functions to help debug Garnet programs,
including the Inspector. @ref{Debug}.

@code{Demonstration programs} - Each demonstration program is in its own
package. @ref{demos}.

@code{Gilt}  - Package @code{gilt}. @cindex{gilt (package)} The Garnet
interface builder. @ref{gilt}.

@code{C32} - Package @code{c32}. A spreadsheet interface for editing
constraints. @ref{c32}.

@code{Lapidary}  - Package @code{Lapidary}. @cindex{lapidary (package)} A
sophisticated interactive design tool. @ref{lapidary}.

@code{Contrib} - A set of file contributed by Garnet users. These have
not been tested by the Garnet group, and are not supported. Each file
should have a comment at the top describing how it works and who to
contact for help and more information.
@end itemize

@section Overview of this Technical Report
@node Overview of this Technical Report

In addition to the reference manuals for all the parts of the Garnet
toolkit listed above, this technical report also contains:
@itemize
A guided on-line tour of the Garnet system that will help you become
familiar with a few of the features of the Garnet toolkit. @ref{tour}.

A tutorial to teach you the basic things you need to know to use
Garnet. @ref{tutorial}.

The code for a simple graphical editor, as a sample of code written for
Garnet. @ref{sampleprog}.

The Hints manual starting on page @ref{hints} includes some suggestions
that have been collected from the experience of Garnet users for making
Garnet programs run faster.
If you have ideas for things to add to this section, let us know.
@end itemize

@section What You Need To Know
@node What You Need To Know

Although this is a large technical report, you certainly do not need to
know everything in it to use Garnet. Garnet is designed to support many
different styles of interface.
Therefore, there are many options and functions that you will probably not
need to use.

In fact, to run the @b{Tour} (page @ref{tour}), it is not
necessary to read any of the reference manuals. The tour is
self-explanatory. 

Next, you should probably read the @b{Tutorial} (page @ref{tutorial}), since
it tries to provide enough information about most of Garnet so that you don't
need the other manuals right away.

To run the Gilt Interface Builder, you do not need to know about the
rest of the system either. The Gilt manual should be sufficient.
When you are ready to set some properties of the gadgets, you will
need to look up the particular gadget in the Gadgets manual to see
what the properties do.

Even when you are ready to start programming, you will still not need most
of the information described here. To start, you should probably do the
following:
@enumerate
Read this overview.

Run the tour, to get a feel for Garnet programming.

Read the tutorial.

You might try creating a few dialog boxes using Gilt. This will
familiarize you with the Gadgets. See the Gilt manual (@ref{gilt}).

After that, you can look at the sample program at the end of
this technical report, to see what you need more information about.

You could now try to start writing your own programs, and just use the rest
of the manuals as reference when you need information.

Next, look at the introduction and the following functions in the KR
document: @code{gv, gvl, s-value, formula, o-formula,} and
@code{create-instance}. The KR manual documents the entire KR module, but
Garnet does not use every feature that KR provides. Some concepts (like
demons), will never be used by the typical Garnet user. Once you have
gained some familiarity with the system, you may want to return to the KR
Manual and read about object-oriented programming, type-checking, and
constants.

Next, skim the first five chapters of the Opal manual, and look at the
various graphical objects, so you know what kinds are provided. The primary
functions you will use from Opal are: @code{add-component, update,} and
@code{destroy}, as well as the various types of graphical objects
(@code{rectangle, line, circle}, etc.), drawing styles (@code{thin-line,
dotted-line, light-gray-fill}, etc.) and fonts.

Next, in the Interactors manual, you will need to skim the first four
chapters to see how interactors work, and then see which interactors there
are in the next chapter. You will probably not need to take advantage of
the full power provided by the interactors system.

Aggregadgets and Aggrelists are very useful for handling collections of
objects, so you should read their manual. They support creating instances
of groups of objects.

You should then look at the gadget manual to see all the built-in
components, so you do not have to re-invent what is already supplied.

User interface code is often difficult to debug, so we have provided a
number of helpful tools. The Inspector is mentioned briefly in the Tutorial,
and it is discussed thoroughly in the debugging manual. You will probably
find many debugging features very useful.

The demo programs can be a good source of ideas and coding style, so the
document describing them might be useful.
@end enumerate

If all you want Garnet for is to display menus and gauges that are supplied
in the gadget set, you can probably just read the KR, Gadgets and Gilt
manuals, and skip the rest.


@section Planned Future Extensions
@node Planned Future Extensions
@cindex{Future work}
@anchor{future}

We expect 3.0 to be the last release of the lisp version of Garnet.
No enhancements of the lisp version are planned. However, if you need
something and would like to sponsor its development, write to
@code{garnet@@cs.cmu.edu}.

@cindex{amulet}
The group is now working on a C++ system called Amulet, which will have
many features similar to those found in Garnet. Watch for announcements
about the Amulet project on @code{comp.windows.garnet} and @code{comp.lang.c++}.
To sign up for the new Amulet mailing list, please send mail to
@code{amulet-users-request@@cs.cmu.edu}.


@page
@section Garnet Articles
@node Garnet Articles
@anchor{articles}
@cindex{articles}
@cindex{papers}

A number of articles about Garnet have been made available for FTP from the
directory @code{/usr/garnet/garnet/doc/papers/} on @code{a.gp.cs.cmu.edu}.
There is a README file in that directory, indicating which @code{.ps} files
correspond to the Garnet bibliography citations.

@chapter On-line Tour Through Garnet
@node On-line Tour Through Garnet

@b{Brad A. Myers}
@value{date}

@section Abstract
@node Abstract

This document provides an on-line tour through some of the features of the
Garnet toolkit. It serves as an introduction to the toolkit and how to
program with it. This document and tour do @emph{not} assume that the reader
has read the reference manuals. The tour only assumes that the reader is
familiar with Common Lisp and has loaded the Garnet software. 




@section Introduction
The Garnet User Interface Development Environment contains a comprehensive
set of tools that make it significantly easier to design and implement
highly-interactive, graphical, direct manipulation user interfaces. The
lower layers of Garnet provide an object-oriented, constraint-based
graphical system that allows properties of graphical objects to be
specified in a simple, declarative manner and then maintained automatically
by the system. The dynamic, interactive behavior of the objects can be
specified separately by attaching high-level ``interactor'' objects to the
graphics. The higher layers of Garnet include a number of tools to allow
various parts of the interface to be specified without programming.
The primary tools are Gilt, an interface builder, and Lapidary, a tool which
helps you build gadgets and dialog boxes.

This document will help users get acquainted with the Garnet software by
leading them through a number of exercises on line. This entire exercise
should take about an hour. This tour assumes that the user is familiar
with Lisp, although even non-Lispers might be able to type in the
expressions verbatim and get the correct results.

Clearly, in this short tour, a great many parts of Garnet will not be
covered, so the interested reader will need to refer to other parts of this
manual for details.

@section Getting Started
@anchor{startlisp} 

Garnet is a software package written in Common Lisp for X11 and the Mac,
so the first thing to do is to run X11 and lisp on your Unix machine, or
start MCL on your Mac. At Carnegie Mellon University, the Garnet
software is available on the AFS file server. Elsewhere, you will
have to copy the software onto your machine, and load it into your
Lisp. See the discussion in the Overview document for an explanation
of loading Garnet and special considerations for particular machines.


@section Typing
@node Typing
@anchor{typing}

Many of the names in Garnet contain colons ``:'' and hyphens ``-''. These
are part of the names and must be typed as shown. For example,
@code{:filling-style} is a single name, and must be typed exactly.

In this document, the text that the user types (e.g, you) is shown underlined
in the code examples. Most of the code looks like the following:
@example
* @samp{(+ 3 4)}
7
@end example
The "*" is the prompt from Lisp to tell you it is ready to accept input
(your Lisp may use a different prompt).
Do not type the "*". Type "@samp{(+ 3 4)}". The next line (here @code{7})
shows what Lisp types as a response.

If you don't like to type, you might have the Appendix of this document
displayed in an editor and just copy the commands into the Lisp
window. In X, you can use the X cut buffer (copy the lines one-by-one
into the X cut buffer, then paste them into the Lisp window);  on the
Mac, you can edit a file using the MCL editor and do the usual
copy-and-paste operations.
The Appendix contains a list of all the commands you need to
type, to make it easier to copy them.
The appendix code by itself is stored in 
the file @code{tourcommands.lisp} which is stored in the @code{demos} source
directory (usually @code{garnet/src/demos/tourcommands.lisp}).
@i{Note: do
not just load @code{tourcommands}, since it will run all the demos and quickly
quit; just copy-and-paste the commands one-by-one from the file}.

@section Garbage Collection
@node Garbage Collection

Most Common Lisp implementations use a garbage collection
mechanism that occasionally interrupts
all activity until it is completed. At various
times during your tour, Lisp will
stop and print something like the following message:
@example
[GC threshold exceeded with 2,593,860 bytes in use. Commencing GC.]
@end example
You will then have to wait until it finishes and types something like:
@example
[GC completed with 538,556 bytes retained and 2,055,356 bytes freed.]
[GC will next occur when at least 2,538,556 bytes are in use.]
@end example
This can happen at any time, and it causes the entire system to freeze
(although the cursor will still track the mouse). Therefore, if
nothing is responding, Lisp and Garnet may not have crashed. Wait for
a minute and see if they come back.

@section Errors, etc.
@node Errors, etc.
It is quite common to end up in the Lisp debugger. This might be caused by
a bug in Garnet or because you made a small typing error. To get out of
the debugger, you will need to type the specific command for that version
of Common Lisp (@code{q} on CMU Common Lisp, @code{:reset} in Allegro
Common Lisp, and Command-period in MCL). For special instructions
about the LispWorks debugger, see the section "LispWorks" in the
Overview manual.

Often, you can just try whatever you were doing again. However, some
errors might cause Garnet or even Lisp to get messed up. In order of
severity, you can try the following recovery strategies after leaving
the debugger:
@itemize
If Lisp does not seem to be responding, try typing ^C (or whatever your
break character is -- Command-comma in MCL) @emph{to the lisp window}
(move the mouse cursor to the Lisp window first).

If you typed a line incorrectly, try typing it again the correct way.

If that does not work, try destroying the object you were creating and
starting over from where you first started creating the object. To destroy
an object that you created using @code{(create-instance 'xxx ...)}, just type
@code{(opal:destroy xxx)}. Note that on the @code{create-instance} there
is a quote mark, but not on the destroy call.

If you were in the first part of the tour (section @ref{LearnGarnet}), then 
if that does not work, try destroying the window and starting over from the
top: @code{(opal:destroy MYWINDOW)}. If you were in the Othello part, try typing
@code{(stop-othello)}.

If that does not work, try quitting Lisp and restarting. For CMU
Common Lisp, type @code{(quit)} to get out of Lisp; for Lucid, type
@code{(system:quit)}; for LispWorks, type @code{(bye)};  for Allegro,
type @code{:ex}; and for MCL type @code{(quit)}. See section
@ref{startlisp} about how to start Lisp, and section @ref{quitting}
about quitting.

Finally, you can always logout and log back in.
@end itemize

In the Appendix
of this document is a list of all the commands you are supposed
to type in. This will be useful if you need to start over and don't want
to have to read through everything to get to where you were. If you
are starting at the Othello part (section @ref{Othello}), you do not have
to execute any of the commands before that (except to load Garnet and the
tour).

If Lisp seems to be stuck in an infinite loop, you can break out by typing
the break character (often ^C --- control-C) or the abort command in
MCL (Command-comma). It will throw you into the debugger.

If you start something over, or retype a command, you may see messages
like:
@example
Warning - create-schema is destroying the old #k<MGE::TRILL>.
@end example
This is a debugging statement is you can just ignore it.

There are a large number of debugging functions and techniques provided to
help fix Garnet toolkit code, but these are not explained in this tour.
See the debugging manual.

@verbatim
*****************************
LOGGING IN
*****************************

Ask for user's name and login and e-mail address.
Automatically send bam the name in a mail message.

System will also Use-package kr, kr-debug

@end verbatim

@verbatim
*****************************
BASICS
*****************************
@end verbatim

@section Learning Garnet
@section LearnGarnet

@section A Note on Packages
@node A Note on Packages
@cindex{Packages}
@cindex{KR (Package)}
@cindex{Opal (Package)}
@cindex{Inter (Package)}
@cindex{Garnet-Gadgets (Package)}
@cindex{Garnet-Debug (Package)}

The Garnet software is divided into a number of Lisp packages. A
@emph{package} may be thought of as a module containing procedures and
variables that are all associated in some way. Usually, the
programmer works in the @code{user} package, and is not aware of
other packages in Lisp. In Garnet, however, function calls are
frequently accompanied by the name of the package in which the function
was defined.

For example, one of the packages in Garnet is @code{opal}, which
contains all the objects and procedures dealing with graphics. To
reference the @code{rectangle} object, which is defined in @code{opal},
the user has to explicitly mention the package name, as in
@code{opal:rectangle}.

On the other hand, the package name may be omitted if the user
calls @code{use-package} on the package that is to be referenced. That
is, if the command @code{(use-package :OPAL)} or @code{(use-package
"OPAL")} is issued, then the @code{rectangle} object may be referenced
without naming the @code{opal} package.

The recommended "Garnet Style" is to @code{use-package} only one
Garnet package -- @code{KR} -- and explicitly reference objects in other
packages. This convention is followed in the code examples below.
The file @code{tour.lisp} that you loaded contains the line
@code{(use-package :KR)}, which implements this convention. You will
probably want to put this line at the top of all your future Garnet
programs as well.

The packages in Garnet include:
@itemize
@code{KR} - contains the procedures for creating and accessing objects. This
contains the functions @code{create-instance}, @code{gv}, @code{gvl},
@code{s-value}, and @code{o-formula}. 

@code{Opal} - contains the graphical objects and some functions for them.

@code{Inter} - contains the interactor objects for handling the mouse.

@code{Garnet-Gadgets} - (nicknamed @code{gg}) contains a collection of predefined
"gadgets" like menus and scroll bars.

@code{Garnet-Debug} - (nicknamed @code{gd}) contains a number of debugging
functions. These are not discussed in this tour, however.
@end itemize


@section A Note on Refresh
@node A Note on Refresh
@cindex{Refreshing windows}
@cindex{Main-Event-Loop}
In X11 and Mac QuickDraw, pictures drawn to windows need to be
redrawn if the window is covered and then uncovered. Garnet handles
this automatically for you by through a background process
which detects this situation and redraws windows when necessary.
In most lisps, Garnet launches this @code{main-event-loop} process
itself. On the Mac, MCL runs a background process anyway, and Garnet
supplies the necessary functions that handle graphics redrawing.
This function is also responsible for processing
mouse and keyboard input to Garnet windows.

The @code{main-event-loop} background process starts without any special
attention in most lisps, including Allegro, Lucid, CMUCL, and MCL. If
you are running LispWorks, then there is an initialization procedure
for multiprocessing that you must perform before loading Garnet.
Please consult the "LispWorks" section of the Overview Manual, the
first section in this Garnet Reference Manual.

Unfortunately, if you are not running a recent version of Allegro,
Lucid, CMUCL, MCL, or LispWorks, your Lisp may not support background
processes. In this case, you must explicitly run
the function yourself. If you notice that windows are not refreshing
properly after becoming uncovered (or de-iconified), or that Garnet is
completely ignoring all your keyboard and mouse input, then type the
following into Lisp:
@example
* @samp{(inter:main-event-loop)}
@end example
This function loops forever, so you then have to hit the
@code{F1} key while the cursor is in a Garnet window to exit
@code{main-event-loop}. Alternatively, you can type ^C or Command-period,
or whatever your operating system break character is,
in the Lisp window. Also, it is permissible (though unnecessary) to call
@code{main-event-loop} within a version of Lisp which supports background
processes -- the function first checks if another @code{main-event-loop}
is already running in the background, and if so, it returns immediately.


@section Loading Garnet and the Tour
@node Loading Garnet and the Tour

The Overview document discusses how to load the Garnet software. In
summary, you will load the file @code{Garnet-Loader} and this will load all
the standard software. After that, you need to load the special file
@code{tour.lisp}, which is in the @code{src/demos} sub-directory.
For example, if the Garnet files are in the directory
@code{/usr/xxx/garnet/}, then type the following:

@example
* @samp{(load "/usr/xxx/garnet/garnet-loader")}
@end example
Which will print out lots of stuff. Then type:
@example
* @samp{(garnet-load "demos:tour")}
@end example
Note that @code{garnet-load}
@cindex{Garnet-Load} is a useful procedure
provided by Garnet to simplify loading Garnet files. It takes one
argument (in this case @code{"demos:tour"}), a two-part string consisting of
the a Garnet subdirectory reference (eg, @code{"demos"}) and
the name of a file (eg, "tour"), separated by a colon. The procedure
searches the directory associated with that package for a Lisp file (either
compiled or uncompiled) of that name.



@section Basic Objects
@node Basic Objects
Now you are going to start creating some Garnet Toolkit objects.

@cindex{Create-instance}
Garnet is an object-oriented system, and you create objects using the
function @code{create-instance}, which takes a quoted name for the new
object, the type of object to create, and then some other optional
parameters. First, you will create a window object.

@cindex{interactor-window}
Type the text shown underlined to Lisp. Be sure to start with an open
parenthesis and be careful about where the quotes and colons go. 
@example
* @samp{(create-instance 'MYWINDOW inter:interactor-window)}
#k<MYWINDOW>
@end example

@cindex{update}
You won't see anything yet, because Garnet waits for an @code{update} call
before showing the results. Now type:
@example
* @samp{(opal:update MYWINDOW)}
@end example
and the window should appear.

You can move the window around and change its size just like any other
X or Mac window, in whatever way you have your X window manager set up
to do this.

@cindex{s-value}
@cindex{aggregate}
Now, you are going to create an ``aggregate'' object to hold all the other
objects you create. An aggregate holds a collection of other objects; it
does not have any graphic appearance itself.
@example
* @samp{(create-instance 'MYAGG opal:aggregate)}
#k<MYAGG>
@end example
This aggregate will be the special top level aggregate in the window, that
will hold all the objects to be displayed in the window. You will use the
function @code{s-value} which sets the value of a ``slot'' (also called an
instance variable) of the object. @code{S-value} takes the object, the slot
and the new value. To read the value of the slot, use the function @code{gv},
which stants for ``get value''. All slot names in Garnet start
with a colon.
@example
* @samp{(s-value MYWINDOW :aggregate MYAGG)}
#k<MYAGG>
* @samp{(gv MYWINDOW :aggregate)}
#k<MYAGG>
@end example

@cindex{moving-rectangle}
@cindex{rectangle}
Now, you will create a rectangle.
@example
* @samp{(create-instance 'MYRECT MOVING-RECTANGLE)}
#k<MYRECT>
@end example

@cartouche
[Note: MOVING-RECTANGLE is defined in the @code{user} package by
@code{tour.lisp} as a specialization of the general @code{opal:rectangle} prototype.]
@end cartouche

@cindex{add-component}
Again, this is not visible yet. First, the rectangle must be added to the
aggregate, and then the update procedure must be called. Adding the
rectangle uses the function
@code{add-component} which takes the aggregate and the new object to add to
it.
@example
* @samp{(opal:add-component MYAGG MYRECT)}
#k<MYRECT>
* @samp{(opal:update MYWINDOW)}
NIL
@end example

The rectangle should now appear in the window.

@cindex{filling-style}
@cindex{gray-fill}
All objects have a number of properties,
such as their position, size and color. So far, all the objects have used
the default values for properties. You will now change the color of the
rectangle by setting its @code{:filling-style} slot. Remember that slot
names begin with a colon, and that nothing happens until you do the
@code{update}.
@example
* @samp{(s-value MYRECT :filling-style opal:gray-fill)}
#k<GRAY-FILL>
* @samp{(opal:update MYWINDOW)}
NIL
@end example

The other filling styles that are available include @code{opal:light-gray-fill,
opal:dark-gray-fill, opal:black-fill, opal:white-fill}, and
@code{opal:diamond-fill}. These are all ``halftone'' shades, which
means that they are created by turning some pixels on and others off.
If you have a color screen, you might also try @code{opal:red-fill,
opal:blue-fill, opal:green-fill, opal:yellow-fill, opal:purple-fill}, etc.

Now, you will create a text object. Here, for the first time, you will
supply some extra values for slots when the object is created, rather than
just using @code{s-value} afterward. Objects have a large number of slots
and the ones that are not specified use the default values.
To specify a slot at creation time, each name and value is
enclosed in a separate parenthesis pair. Note that you can type carriage
return where-ever you want. After the text is created, add it to the
aggregate and update the window.
@cindex{Hello World}
@cindex{Cursor-Multi-Text}
@example
* @samp{(create-instance 'MYTEXT opal:text (:left 200)(:top 80)
      (:string "Hello World"))}
#k<MYTEXT>
* @samp{(opal:add-component MYAGG MYTEXT)}
#k<MYTEXT>
* @samp{(opal:update MYWINDOW)}
NIL
@end example
The @code{:top} of the string is just its @code{Y} value, and the @code{:left} is
just the @code{X} value, and they are, of course, independent.

You can change the position (@code{:left} and @code{:top}) and string of
MYTEXT using @code{s-value} if you want, like the following:
@example
* @samp{(s-value MYTEXT :top 40)}
40
* @samp{(opal:update MYWINDOW)}
NIL
@end example


@section Formulas
@node Formulas
@cindex{formula}
@cindex{o-formula}
@cindex{gv}
An important property of Garnet is that properties of objects can be
connected using @emph{constraints}. A constraint is a relationship that is
defined once and maintained automatically by the system. You
will constrain the string to stay at the top of the rectangle. Then, when
the rectangle is moved, the string will move automatically.

Constraints in Garnet are expressed as @emph{formulas} which are put into the
slots of objects. Any slot can either have a value in it (like a number or
a string) or a formula which computes the value. The formula can be an
arbitrary Lisp expression which must be passed to the Garnet function
@code{o-formula}. References to other objects in formulas must take a special
form. To get the slot @code{slot-name} from the object
@code{other-object}, use the form @code{(gv other-object slot-name)}, where
``gv'' stands for ``get value.''  The @code{gv} function can be used either
inside or outside of formulas. When used from inside a formula, @code{gv} will
establish a dependency on the referenced slot, causing the formula to
reevaluate if the value in the referenced slot ever changes.

Now, set the top of the string to be a formula that depends on the
top of the rectangle. 

Note that the particular number returned by the @code{s-value} call will not
be the same as shown below.
@example
* @samp{(s-value MYTEXT :top (o-formula (gv MYRECT :top)))}
#k<F3875>   @i{the number will be different}
* @samp{(opal:update MYWINDOW)}
NIL
@end example

After the update, the string should move to be at the top of the rectangle.
If you change the top of the rectangle, @emph{both} the rectangle and the string
will now move:
@example
* @samp{(s-value MYRECT :top 50)}
50
* @samp{(opal:update MYWINDOW)}
NIL
@end example

If you want to experiment with writing your own formulas, the Lisp
arithmetic operators include @code{+, -, floor} (for divide), and @code{*} (for
multiply) and they must be in fully parenthesized expressions, as in
@code{(o-formula (+ (gv MYRECT :top) 7))}.
To get the width and height of an object from inside a
formula, use @code{(gv @emph{obj} :width)} and @code{(gv @emph{obj}
:height)}. You could try, for example, to get the text to stay centered in
X (@code{:left}) and Y (@code{:top}) inside the rectangle.


@section Interaction
@node Interaction

Now, you will get the objects to respond to input. To do this, you attach
an @emph{interactor} to the object. Interactors handle the mouse and keyboard
and update graphical objects.

@cindex{Move-Grow-Interactor}
First, you will have the rectangle move with the mouse. To do this, you
create a @code{move-grow-interactor} and tell it to operate on MYRECT.
The interactor will start whenever the mouse is pressed @code{:in MYRECT},
and the interactor works in MYWINDOW. The interactor will continue to
run no matter where the mouse is moved while the button is held down. 

It is not necessary to call
@code{update} to get interactors to start working; they start as soon as
they are created. However, if you are not using a recent version of
CMU, Allegro, LispWorks, Lucid, or MCL Common Lisp, interactors only run
while the @code{main-event-loop} procedure is operating.
@code{Main-Event-Loop} does not exit, so you will have to hit the @code{F1} key
while the cursor is in the Garnet window, or type ^C (or
whatever your operating system break character is) while the cursor is in
the Lisp window, to be able to type further Lisp expressions.

@example
* @samp{(create-instance 'MYMOVER inter:move-grow-interactor
	(:start-where (list :in MYRECT))
	(:window MYWINDOW))}
#k<MYMOVER>
@end example
If your Lisp requires it, then type:
@example
* @samp{(inter:main-event-loop)}
@end example

Now you can press with the left button over the rectangle, and while the
button is held down, move the rectangle around. (The first time you press
on the rectangle, it may take a while, as Lisp swaps in the appropriate code.)
Notice that the text
string moves up and down also. The text string does not move left and
right, however, since there is no constraint on the @code{:left} of the
string, only on the @code{:top} (unless you have written some extra formulas
other than the one described above).

A different interactor allows you to type into text strings. This is called a
@code{text-interactor}. The code below will cause the text interactor to start
when you press the right mouse button, and stop when you press the right mouse
button again. This will allow you to type carriage returns into the string
and to move the cursor point by hitting the left button inside the string.
(Before typing these commands, hit the F1 key to exit  @code{main-event-loop}
if necessary).
@cindex{Text-Interactor}
@example
* @samp{(create-instance 'MYTYPER inter:text-interactor
	(:start-where (list :in MYTEXT))
	(:window MYWINDOW)
	(:start-event :rightdown)
	(:stop-event :rightdown))}
#k<MYTYPER>
@end example
If your Lisp requires it, then type:
@example
* @samp{(inter:main-event-loop)}
@end example

Now, if you press with the right mouse button on the string, you can change
the string by typing. The available editing commands include:

@table @key
@item ^h, delete, backspace
delete previous character.

@item ^w, ^backspace, ^delete
delete previous word.

@item ^d
delete next character.

@item ^u
delete entire string.

@item ^b, left-arrow
go back one character.

@item ^f, right-arrow
go forward one character.

@item ^n, down-arrow
go vertically down one line.

@item ^p, up-arrow
go vertically up one line.

@item ^<, ^comma, home
go to the beginning of the string.

@item ^>, ^period, end
go to the end of the string.

@item ^a
go to beginning of the current line.

@item ^e
go to end of the current line.

@item ^y, insert
insert the contents of the X or Mac cut buffer into
the string at the current point.

@item ^c
copy the current string to the X or Mac cut buffer.

@item enter, return, ^j, ^J
Go to new line.

@item left button down inside the string
move the cursor to the
specified point.

@item ^G
Abort the edits and return the string to the way it was before
editing started.
@end table

All other characters go into the string (except other control characters
which beep). You can also move the cursor with the mouse by clicking in
the string.

(In X, to type to a window, the mouse cursor must be inside the window, so to
type to the ``Hello World'' string, the mouse cursor must be inside the Garnet
window, and to type to Lisp, the cursor should be inside the Lisp
window. On the Mac, you have to click the mouse on the title-bar of
the window you want to type into, so you will have to click
alternately on the Garnet window and the lisp listener.)


If you make the text string be multiple lines, by typing a carriage
return into it,
then you can control whether the lines are centered, left or right
justified. This is controlled by the @code{:justification} slot of
MYTEXT, which can be @code{:left, :center}, or @code{:right}.
(Before typing these commands, hit the F1 key to exit  @code{main-event-loop}
if necessary).
@cindex{justification}
@example
* @samp{(s-value MYTEXT :justification :right)}
:RIGHT
* @samp{(opal:update MYWINDOW)}
NIL
* @samp{(s-value MYTEXT :justification :center)}
:CENTER
* @samp{(opal:update MYWINDOW)}
NIL
@end example

Of course, you can type to the string while it is centered or
right-justified, and you can move around the rectangle with the mouse and
the string will still follow.

@section Higher-level Objects
@node Higher-level Objects

Now, you are going to create instances of pre-created objects from the
``Garnet Gadget Set.''  The Gadget Set contains a large collection of menus,
buttons, scroll bars, sliders, and other useful @emph{interaction techniques}
(also called ``widgets''). You will be using a set of ``radio buttons''
and a slider.

First, however, you should make the window bigger (in whatever way you
do this in
your window manager).

@subsection Buttons
@node Buttons

First, you will create a set of 3 ``radio'' buttons that will determine
whether the text
is centered, left, or right justified. The parameter that tells the
buttons what the labels should be is called @code{:Items}. This slot is
passed a quoted list. The radio buttons will appear at the right of
the string.
@cindex{Radio-Button-Panel}
@example
* @samp{(create-instance 'MYBUTTONS gg:radio-button-panel
        (:items '(:center :left :right))
	(:left 350)(:top 20))}
#k<MYBUTTONS>
* @samp{(opal:add-component MYAGG MYBUTTONS)}
#k<MYBUTTONS>
* @samp{(opal:update MYWINDOW)}
NIL
@end example

If your Lisp requires it, then type:
@example
* @samp{(inter:main-event-loop)}
@end example

Now, you can click on the radio buttons with the left mouse button, and the
dot will move to whichever one you click on.

@cindex{Value Slot}
Next, you will use a constraint to tie the value of the @code{:justification}
field of the text object to the value of the radio buttons. The current
value of the radio buttons is conveniently kept in the @code{:value} field.
(Before typing these commands, hit the F1 key to exit  @code{main-event-loop}
if necessary).

@example
* @samp{(s-value MYTEXT :justification (o-formula (gv MYBUTTONS :value)))}
#k<F2312>   @i{the number will be different}
* @samp{(opal:update MYWINDOW)}
NIL
@end example
If your Lisp requires it, then type:
@example
* @samp{(inter:main-event-loop)}
@end example

Now, whenever you press on one of the buttons, the text will re-adjust
itself.

All of the built-in toolkit items have a large number of parameters to
allow users to customize their look and feel. For example, you can change
the radio buttons to be horizontal instead of vertical:
(From now on, you will have to remember to hit the F1 key to exit
@code{main-event-loop} if necessary before typing commands without these
reminders).
@example
* @samp{(s-value MYBUTTONS :direction :horizontal)}
:HORIZONTAL
* @samp{(opal:update MYWINDOW)}
NIL
@end example

Now, change it back to be vertical:
@example
* @samp{(s-value MYBUTTONS :direction :vertical)}
:VERTICAL
* @samp{(opal:update MYWINDOW)}
NIL
@end example

@subsection Slider
@node Slider

Next, you will do a similar thing to get the gray shade of the
rectangle to be attached to an on-screen slider. First, create a Garnet
vertical slider object:
@cindex{V-Slider}
@example
* @samp{(create-instance 'MYSLIDER gg:v-slider
	(:left 10)(:top 20))}
#k<MYSLIDER>
* @samp{(opal:add-component MYAGG MYSLIDER)}
#k<MYSLIDER>
* @samp{(opal:update MYWINDOW)}
NIL
@end example
If your Lisp requires it, then type:
@example
* @samp{(inter:main-event-loop)}
@end example

This slider can be operated in a number of ways, all using the left mouse
button. Press on the top arrow to move up one unit, and the down arrow to
move down one. The double arrow buttons move up and down by five (the
increment amount can be changed by using @code{s-value} on the
@code{:scr-incr} and @code{:page-incr} slots of MYSLIDER). You can
also press on
the black indicator arrow and drag it to a new position. Finally. you can
press in the top number area, then type a new number value, and then hit
carriage return.

Of course the value returned by the slider does not affect anything yet.
To change the color of the rectangle, you will use the Garnet function
@code{Halftone}, which takes a number from 0 to 100 and returns a
@code{:filling-style} that is that percentage black. Connect the filling
style of the rectangle to the value returned by the slider:
 
@example
* @samp{(s-value MYRECT :filling-style
		(o-formula (opal:halftone (gv MYSLIDER :value))))}
#k<F5940>   @i{the number will be different}
* @samp{(opal:update MYWINDOW)}
NIL
@end example
If your Lisp requires it, then type:
@example
* @samp{(inter:main-event-loop)}
@end example

Now when you change the value of the slider, the color of the rectangle
will change. Note that halftone only can generate 17 different gray
colors, so a range of numbers for the slider will generate the same color.

@section Playing Othello
@anchor{Othello}
@cindex{Othello}
@cindex{start-othello}

Now you can play the Othello game we created using the Garnet Toolkit.

To bring up the game, type:
@example
* @samp{(start-othello)}
T
@end example
The game board will appear on the
screen. There are various things you can control in the game. You can put
new pieces down on the board by just pressing with the left mouse button.
In Othello, you can put a piece in a position where you are next to the
other player's marker, and one of your markers is in a straight line from
where you are going to play.
If you try to place your marker in an illegal place, the
game will beep. This game does not try to play against you; you must
handle both players (or get someone else to play with you). 
If a player does not want to move (or has no legal moves), then the
``Pass'' menu item can be selected. This implementation does not detect
when the game is over. The current score (which is the number of squares
that the player controls) is shown in the top left box.

To start over, press on the menu button marked ``Start.''  This will start
a new game with a board that has the number of squares shown by the scroll
bar. The default is 8 by 8. To change the scroll bar value, press on the
arrows. (Changing the scroll bar does not change the current board; it
takes affect the next time you hit ``Start'' from the menu.)  

``Stop'' just erases the board, and ``Quit'' exits the game. (You don't
have to quit before going on to the next section.)

@section Modifying Othello

We created an editor that allows you to change what the Othello playing
pieces look like. This is editor is just a small toy program that was
created quickly by David Kosbie in the Garnet group especially for this tour.

If you quit out of the Othello game, bring it back up using @code{(start-othello)}.

Othello has a tall window on the left side of the screen containing
the current 2 Othello playing  pieces at the top: a white
and a black circle. Underneath is a command button (``Delete'') and 3
menus. The top left menu is for different types of objects: rectangles,
rounded rectangles, circles and ovals. The bottom left menu is for line
styles (the way the outlines of objects are drawn): no outline, dotted
outline, thin, thicker or very thick outline. The menu on the right is for
how the inside of objects looks: no filling inside, white, grey, black or
various patterns.

Press with the left mouse button over any of the menus to change the
current mode.

To draw a new object in either playing
piece, just use the @emph{right} mouse button
to drag out the dimensions for the new object. Press down the right button
inside whichever piece you want to modify where you want one corner of the
new object to be, move the cursor while holding down, and
release at the other corner. The type, line styles, and
inside of the new object come from the current values of the menus. 

Objects can be selected by pressing over them with the @emph{left} mouse
button. (Some objects require that you press on the edge (border) of the
object, and others allow you to press anywhere inside.)
When an object is selected, 12 small boxes are shown on the borders of
the object. (The small boxes are on the bounding rectangle of the object, which
may be a little confusing for circles.)
The black boxes can be used to change the object's size, and
the white boxes are used to move the object. Just press with the left
button over one of the boxes, and then adjust the size or position while
holding down. The editor will not let you move or grow an object so that
it goes outside the game piece area. 

The selected object can also be deleted or changed. Delete it by just
hitting the Delete button in the menu when the object is selected. If you
press on a new line style or
filling style while an object is selected, the object's outline and color will
change. (You can't change an object's type.)  Note that as you select
objects, the menus change to show the object's current styles.

Every time you edit one of the playing pieces, the Othello game display
also changes to reflect the edits. This is handled automatically by Garnet
using inheritance.


@section Using GarnetDraw
@cindex{garnetdraw}

There a useful utility called @code{GarnetDraw} which is a
relatively simple drawing program written using Garnet. Using this
application, you can draw pictures with many of the basic Garnet objects
(like circles, rectangles, and lines), and then save the picture to a file.
Since the file format for storing the created objects is simply a Lisp file
which creates aggregadgets, you might be able to use GarnetDraw to prototype
application objects (but Lapidary is probably better for this).

GarnetDraw uses many sophisticated features of Garnet including gridding,
PostScript printing, selection of all objects in a region, moving and growing
of multiple objects, menubars, and the @code{save-gadget} and @code{load-gadget}
dialog boxes.

To load and start GarnetDraw, type:
@example
* @samp{(garnet-load "demos:garnetdraw")}

* @samp{(garnetdraw:do-go)}
@end example

GarnetDraw works like most Garnet programs: select in the palette
with any button, draw in the main window with the right button, and select
objects with the left button. Select multiple objects with shift-left or
the middle mouse button. Change the size of objects by pressing on black
handles and move them by pressing on
white handles. The line style and color and filling color can be
changed for the selected object and for further drawing by clicking on
the icons at the bottom of the palette.

You might want to save a picture to a file, and then bring the file up in
your editor to see the kind of code that GarnetDraw generates. There should
be a top-level aggregadget that has your drawn objects as components.

To quit GarnetDraw, either select "Quit" from the menubar, or type:

@example
* @samp{(garnetdraw:do-stop)}
@end example



@section Cleanup

@anchor{quitting}

If you are not in a Lisp which supports background processes, and
you are running something in Garnet, then you need to type F1 in a
Garnet window or ^C in your Lisp window to get back to the Lisp
read-eval-print loop. 

@cindex{stop-tour}
To get rid everything at once (MYWINDOW, the Othello game, and the 
editor for the game pieces), just type:
@example
* @samp{(stop-tour)}
"Thank you for your interest in the Garnet Project"
@end example

@cindex{stop-othello}
Otherwise, 
to just get rid of Othello and the editor, you can hit on the ``Quit'' menu
button or type @code{(stop-othello)} to Lisp. To just get rid of MYWINDOW,
type @code{(opal:destroy MYWINDOW)}.

The command that exits Lisp is different for different implementations.
For CMU Common Lisp, type: @samp{* (quit)}

for Lucid Common Lisp, type: @samp{* (system:quit)}

for LispWorks, type: @samp{* (bye)}

for Allegro Common Lisp, type: @samp{* :ex}

and for MCL, type: @samp{* (quit)}

This returns you to the shell (or to the finder on the Mac), and you
can log out. It is not necessary to run @code{(stop-othello)} or
@code{(stop-tour)} before quitting Lisp.

If the quit command doesn't work for any reason,
you can probably quit by typing ^Z to pause to the shell and
then kill the lisp process (or just log out).

@section
We hope you have enjoyed your tour through Garnet. There are, of course,
many features and capabilities that have not been demonstrated. These are
described fully in the various manuals and papers about the Garnet project
and its parts. The next step might be to run the Gilt interface
builder, since it does not require that you learn much about how
Garnet works. See the Gilt manual.

@ref{Appendix: List of commands}
This appendix lists all the commands that the tour has you type. This is
useful as a quick reference if you need to restart due to an error.
These commands are stored in
the file @code{tourcommands.lisp} which is stored in the @code{demos} source
directory (usually @code{garnet/src/demos/tourcommands.lisp}).
If you have this document in a window on the screen, you can
copy-and-paste to move text from below into your Lisp window. 
@emph{Note: do
not just load @code{tourcommands}, since it will run all the demos and quickly
quit; just copy the commands one-by-one from the file}.

This listing does not show the prompts or Lisp's responses to these commands.

@b[First, load the Garnet software. You will have to replace @code{xxx}
with your directory path to Garnet:]
@example
(load "/xxx/garnet/garnet-loader")
(garnet-load "demos:tour")
@end example


@b[Start here after Garnet and the tour software is loaded:]
@example
(create-instance 'MYWINDOW inter:interactor-window)
(opal:update MYWINDOW)

(create-instance 'MYAGG opal:aggregate)
(s-value MYWINDOW :aggregate MYAGG)
(gv MYWINDOW :aggregate)
(create-instance 'MYRECT MOVING-RECTANGLE) @emph{; In the USER package}
(opal:add-component MYAGG MYRECT)
(opal:update MYWINDOW)

(s-value MYRECT :filling-style opal:gray-fill)
(opal:update MYWINDOW)

(create-instance 'MYTEXT opal:text (:left 200)(:top 80)
	(:string "Hello World"))
(opal:add-component MYAGG MYTEXT)
(opal:update MYWINDOW)

(s-value MYTEXT :top 40)
(opal:update MYWINDOW)

(s-value MYTEXT :top (o-formula (gv MYRECT :top)))
(opal:update MYWINDOW)

(s-value MYRECT :top 50)
(opal:update MYWINDOW)

(create-instance 'MYMOVER inter:move-grow-interactor
  (:start-where (list :in MYRECT))
  (:window MYWINDOW))
#-(or cmu allegro lucid lispworks apple)  @emph{;only do this if your Lisp is NOT a recent}
(inter:main-event-loop)                   @emph{;version of CMU, Allegro, Lucid, or LispWorks}
                                          @emph{;type F1 or ^C to exit when finished.}

(create-instance 'MYTYPER inter:text-interactor
  (:start-where (list :in MYTEXT))
  (:window MYWINDOW)
  (:start-event :rightdown)
  (:stop-event :rightdown))
#-(or cmu allegro lucid lispworks apple)  @emph{;only do this if your Lisp is NOT a recent}
(inter:main-event-loop)                   @emph{;version of CMU, Allegro, Lucid, or LispWorks}
                                          @emph{;type F1 or ^C to exit when finished.}

(s-value MYTEXT :justification :right)
(opal:update MYWINDOW)

(s-value MYTEXT :justification :center)
(opal:update MYWINDOW)

(create-instance 'MYBUTTONS gg:radio-button-panel
  (:items '(:center :left :right))
  (:left 350)(:top 20))
(opal:add-component MYAGG MYBUTTONS)
(opal:update MYWINDOW)
#-(or cmu allegro lucid lispworks apple)  @emph{;only do this if your Lisp is NOT a recent}
(inter:main-event-loop)                   @emph{;version of CMU, Allegro, Lucid, or LispWorks}
                                          @emph{;type F1 or ^C to exit when finished.}

(s-value MYTEXT :justification (o-formula (gv MYBUTTONS :value)))
(opal:update MYWINDOW)
#-(or cmu allegro lucid lispworks apple)  @emph{;only do this if your Lisp is NOT a recent}
(inter:main-event-loop)                   @emph{;version of CMU, Allegro, Lucid, or LispWorks}
                                          @emph{;type F1 or ^C to exit when finished.}

(s-value MYBUTTONS :direction :horizontal)
(opal:update MYWINDOW)

(s-value MYBUTTONS :direction :vertical)
(opal:update MYWINDOW)

(create-instance 'MYSLIDER gg:v-slider
  (:left 10)(:top 20))
(opal:add-component MYAGG MYSLIDER)
(opal:update MYWINDOW)
#-(or cmu allegro lucid lispworks apple)  @emph{;only do this if your Lisp is NOT a recent}
(inter:main-event-loop)                   @emph{;version of CMU, Allegro, Lucid, or LispWorks}
                                          @emph{;type F1 or ^C to exit when finished.}

(s-value MYRECT :filling-style (o-formula
				(opal:halftone (gv MYSLIDER :value))))
(opal:update MYWINDOW)
#-(or cmu allegro lucid lispworks apple)  @emph{;only do this if your Lisp is NOT a recent}
(inter:main-event-loop)                   @emph{;version of CMU, Allegro, Lucid, or LispWorks}
                                          @emph{;type F1 or ^C to exit when finished.}
@end example

@b[To just get Othello to run, execute the following line.
You do not have to enter any of the previous code to run Othello and
the editior (except for the software loading, of course).]

@example

(start-othello)

@end example


@b[To just load and run GarnetDraw, execute the following lines.]

@example

(garnet-load "demos:garnetdraw")
(garnetdraw:do-go)

@end example

@b[Cleaning up and quitting:]
@example
@emph{;;; * To quit all editors and demos and destroy all windows}

(stop-tour)
(garnetdraw:do-stop)   @emph{; if running}

@emph{;;; * To leave lisp}

#+cmu   (quit)         @emph{; in CMU Common Lisp}
#+lucid (system:quit)  @emph{; in Lucid Common Lisp}
#+allegro :ex          @emph{; in Allegro Common Lisp}
#+lispworks (bye)      @emph{; in LispWorks Common Lisp}
#+apple (quit)         @emph{; in MCL}

@end example


@verbatim

**********************************************************
Later, have another section on more details of objects, etc.
**********************************************************


**********************************************************
CREATING A GRAPHICS EDITOR (Optional)
**********************************************************

		left button moves objects
		right button edits text
		shift-left creates a new object
		shift-right deletes object under mouse
		scroll bar and menu as before for specifying props of next
			new object

create another window
create an aggregadget of a rectangle, line, and editable-string as a prototype
** or use predefined one; would prefer to do this part using Lapidary****

create an aggregate to hold the objects

create a new version of the scroll bar and x-boxes to in another new window

define the create and delete functions

create all the interactors


@end verbatim

@verbatim
@ref{References}
@end verbatim


@chapter Garnet Tutorial
@node Garnet Tutorial

@b{Andrew Mickish}
@value{date}

@section Abstract
@node Abstract

This tutorial has been designed to introduce the reader to the
basic concepts of Garnet. The reader should have already taken the
Garnet Tour before starting the tutorial.

@section Take the Tour
@node Take the Tour

Before beginning this tutorial, you should have already completed the
Garnet Tour, available in a separate document. The Tour was a series
of exercises intended to acquaint you with a few of the features of
Garnet, while giving you a feel for the interactive programming aspects
of Garnet. This Tutorial investigates all of those features in
greater depth, while explaining the fundamental principles behind
objects, inheritance, constraints, interactors, and the actual writing
of code.

In the Garnet Tour, you were given some background information about
how to load Garnet, how to access the different Garnet packages,
garbage collection, the main-event-loop for interactors, etc. It may
be helpful to review this information from the first few sections of
the Tour before starting the Tutorial. 


@section Load Garnet
@node Load Garnet

Using the instructions from the Tour, load Garnet into your lisp
process. Also, type in the following line so that references to
the KR package can be eliminated (we will explicitly reference the
other Garnet packages):

@code{(use-package :KR)}


@section The Prototype-Instance System
@node The Prototype-Instance System

The basic idea behind programming in Garnet is creating objects
and displaying them in windows on the screen.
An object is any of the fundamental data types in Garnet. Lines,
circles, aggregates and windows are all objects. These are all
@emph{prototype} objects --- you make copies of these objects and
customize the copies to have your desired size and position, as well
as other graphic qualities such as filling styles and line styles.
When you make a customized copy of an object, we say you create an
@emph{instance} of the object. Thus, Garnet is a prototype-instance system.


@section Inheritance
@node Inheritance
@anchor{inheritance}

When instances are created, an inheritance link is established between
the prototype and the instance. @emph{Inheritance} is the property that
allows instances to get values from their prototypes without specifying
those values in the instances themselves. For example, if we set the
filling style of a rectangle to be gray, and then we create an
instance of that rectangle, then the instance will also have a gray
filling style. Naturally, this leads to an inheritance hierarchy
among the objects in the Garnet system.
In fact, there is one root object in Garnet -- the @code{view-object} -- that
all other objects are instances of (except for interactors, which have
their own root). Figure @ref{opal-inheritance}
shows some of the objects in Garnet and how they fit into the
inheritance hierarchy. (The average user will never be concerned with
the actual @code{view-object} or @code{graphical-object} prototypes.)

@float Figure, fig:ex1
@center @image{opal-inheritance, 5.5in}
@caption{The inheritance hierarchy among some of the Garnet prototype objects.
All of the standard shapes in garnet are instances of the
@code{graphical-object} prototype. As an example of inheritance, the
@code{circle} and @code{oval} objects are both special types of arcs, and
they inherit most of their properties from the @code{arc} prototype
object. The Gadgets (the Garnet widgets) are not pictured in this
hierarchy, but most of them are instances of the @code{aggregadget} object.}
@anchor{opal-inheritance}
@end float
@sp 1

To see an example of inheritance, let's create an instance of a window
and look at some of its inherited values. After you have loaded Garnet,
type in the following code.

@example
(create-instance 'MY-WIN inter:interactor-window
   (:left 800) (:top 100))
(opal:update MY-WIN)  @emph{; To make the window appear}
@end example
@sp 1

The window should appear in the upper-right corner of your screen.
In the definition of the MY-WIN schema, we gave a value of 800 to the
@code{:left} slot and a value of 100 to the @code{:top} slot. Let's check
these slots in MY-WIN to see if they are correct. Type in the
following lines.

@example
(gv MY-WIN :left)    @emph{; Should be 800}
(gv MY-WIN :top)     @emph{; Should be 100}
@end example

The function @code{gv} gets the values of slots from an object.
If you got the right values for the @code{:left} and @code{:top} slots of
MY-WIN, then you see that the values you supplied during the
@code{create-instance} call are still being used by MY-WIN. These are values
that are held in the instance itself. On the other hand, try typing
in the following lines.

@example
(gv MY-WIN :width)
(gv MY-WIN :height)
@end example

We did not supply values to the @code{:width} and @code{:height} slots of
MY-WIN when it was created. Therefore, these values are @emph{inherited}
from the prototype. That is, they were defined in the
@code{interactor-window} object when it was created, and now MY-WIN
inherits those values as its own. We could, however, override these
inherited values. Let's change the width and height of MY-WIN using
@code{s-value}, the function that sets the values of slots.

@example
(s-value MY-WIN :width 100)
(s-value MY-WIN :height 400)
(opal:update MY-WIN)  @emph{; To cause the changes to appear}
@end example

The dimensions of the window should change, reflecting the new values
we have supplied to its @code{:width} and @code{:height} slots. If we
were to now use @code{gv} to look at the width and height of
MY-WIN, we would get back the new values, since the old ones are no
longer inherited.

The inheritance hierarchy which was partially pictured in Figure
@ref{opal-inheritance} is traced from the leaves toward the root
(from right to left) during a search for a value.
Whenever we use @code{gv} to get the value of a slot, the object
first checks to see if it has a local value for that slot. If there
is no value for the slot in the object, then the object looks to its
prototype to see if it has a value for the slot. This search
continues until either a value for the slot is found or the root
object is reached. When no inherited or local value for the slot is
found, the value NIL is returned (which, by the way, looks just the
same as a user-defined local value of NIL for a slot).

Since we are now finished with the example of MY-WIN, let's destroy it
so it does not interfere with future examples in this tutorial. Type
in the following line.

@code{(opal:destroy MY-WIN)}


@section Prototypes
@node Prototypes
@anchor{prototypes}

When programming in Garnet, inheritance among objects can eliminate a
lot of duplicated code. If we want to create several objects that
look similar, we could create each of them from scratch and copy all
the values that we need into each object. However, inheritance allows
us to define these objects more efficiently, by creating several
similar objects as instances of a single prototype.

@float Figure, fig:ex1
@center @image{proto-rects, 5.5in}
@caption{Three instances created from one prototype rectangle.}
@anchor{proto-rects}
@end float

To start, look at the picture in Figure @ref{proto-rects}. We are
going to define three rectangles with three different filling styles
and put them in a window. First, let's create a window with a
top-level aggregate. (For now, just think of an aggregate as an
object which contains several other objects.)  As we add our objects
to this aggregate, they will be displayed in the window.

@example
(create-instance 'WIN inter:interactor-window
   (:left 750)(:top 80)(:width 200)(:height 400))
(create-instance 'TOP-AGG opal:aggregate)
(s-value WIN :aggregate TOP-AGG)
(opal:update win)
@end example

Now let's consider the design for the rectangles. The first thing to
notice is that all of the rectangles have the same width and height.
Therefore, we will create a prototype rectangle which has a width of
40 and a height of 20, and then we will create three instances of that
rectangle. To create the prototype rectangle, type the following.

@example
(create-instance 'proto-rect opal:rectangle
   (:width 40) (:height 20))
@end example

This rectangle will not appear anywhere, because it will not be added
to the window. But now we need to create the three actual rectangles
that will be displayed. Since the prototype has the correct values
for the width and height, we only need to specify the left, top, and
filling styles of our instances.

@example
(create-instance 'r1 proto-rect
   (:left 20) (:top 20)
   (:filling-style opal:white-fill))

(create-instance 'r2 proto-rect
   (:left 40) (:top 30)
   (:filling-style opal:gray-fill))

(create-instance 'r3 proto-rect
   (:left 60) (:top 40)
   (:filling-style opal:black-fill))

(opal:add-components top-agg r1 r2 r3)  @emph{; give the aggregate three components}
(opal:update win)
@end example

After you update the window, you can see that the instances R1, R2,
and R3 have inherited their @code{:width} and @code{:height} from
PROTO-RECT. You may wish to use @code{gv} to verify this. With
these three rectangles still in the window, we are ready to look at
another important use of inheritance. Try changing the width and
height of the prototype as follows.

@example
(s-value proto-rect :width 30)
(s-value proto-rect :height 40)
(opal:update win)
@end example

The result should look like the rectangles in Figure @ref{changed-proto}.
Just by changing the values in the prototype rectangle, we were able
to change the appearance of all its instances. This is because the
three instances inherit their width and height from the prototype,
even when the prototype changes.

@float Figure, fig:ex1a
@center @image{changed-proto, 5.5in}
@caption{The instances change whenever the prototype object changes.}
@anchor{changed-proto}
@end float

For our last look at inheritance in this section, let's try to
override the inherited slots in one of the instances. Suppose we now
want the rectangles to look like Figure @ref{override}. In this case, 
we only want to change the dimensions of one of the instances. The
following lines should change the appearance of the black rectangle
accordingly.

@example
(s-value R3 :width 100)
(opal:update WIN)
@end example

The rectangle R3 now has its own value for its @code{:width} slot, and
no longer inherits it from PROTO-RECT. If you change the @code{:width}
of the prototype again, the width of R3 will not be affected.
However, the width of R1 and R2 will change with the prototype,
because they still inherit the values for their @code{:width} slots.
This shows how inheritance can be used flexibly to make specific
exceptions to the prototype object.

@float Figure, fig:ex1
@center @image{override, 5.5in}
@caption{The width of R3 is overridden, so it is no longer inherited
from the prototype.}
@anchor{override}
@end float


@section Default Values
@node Default Values

Because of inheritance, all instances of Garnet prototype objects have
reasonable default values when they are created. As we saw in section
@ref{inheritance}, the
@code{interactor-window} object has its own @code{:width}. So, if an
instance of it is created without an explicitly defined width, the
width of the instance will be inherited from the
prototype, and it can be considered a default value.


@section The Inspector
@node The Inspector
@anchor{inspector-sec}

An important tool for examining properties of objects is the Inspector.
This tool is loaded with Garnet by default, and resides in the package
@code{garnet-debug}. The Inspector is described in detail in the Debugging
Manual that starts on page @ref{debug} of this reference manual.

To run the inspector on our example of three rectangles, position the mouse
over R3 (the black rectangle) in the window, and hit the HELP key. If your
keyboard does not have a HELP key, or hitting it does not seem to do anything,
you can start the Inspector manually by typing @code{(gd:Inspector R3)} into
the lisp listener. The Inspector window that appears will look like figure
@ref{inspector}.

@float Figure, fig:ex1
@center @image{inspector, 5.5in}
@caption{The Inspector displaying the slots and values of rectangle R3.}
@anchor{inspector}
@end float

The local slots and values for R3 are shown in the Inspector window.
Inherited slots are not shown, like @code{:height} or @code{:line-style} (assuming
that you did not set these slots yourself, installing local values in R3).
If you have a color screen, some slots are red, indicating that these slots
are public "parameters" of the object (we discuss parameters more in
section @ref[parameters]).

It is very easy to change properties of an object with the Inspector. For
example, to change the @code{:width} of R3 using the inspector, click the mouse
on the value of the @code{:width} slot (which is 100 in figure @ref[inspector]).
Use standard Emacs commands to change the value of the slot to something
significantly different, like 20. When you hit RETURN, the change will appear
instantly in R3.

To add a new local value to R3 -- that is, to override an inherited value with
a new local value -- you have to add an extra line to the Inspector window.
In our example, R3 does not have a local value for @code{:height}, since its
value is inherited from the prototype PROTO-RECT. To override this value,
click the cursor at the end of a line, and type @code{^j} to add a new line
to the display. Now you can type "@code{:height = 100}" and hit RETURN to
install the new slot/value pair. The change should be reflected instantly
in R3.

You can bring up other Inspector windows by positioning the mouse over another
object and hitting HELP again, or you can select text that is already displayed
in the Inspector and using the "@code{Show Object}" or "@code{Show in New}"
buttons. For example, to examine the @code{opal:black-fill} object that is the
value of R3's @code{:filling-style} slot, either click-and-drag or double-click
on the @code{#k<OPAL:BLACK-FILL>} value and press the "@code{Show in New}" button.
The object will be displayed in a new window.

When you are finished with the Inspector, you can click on the "@code{Done}" or
"@code{Done All}" buttons to make the Inspector windows disappear. 

Significantly more detail about the Inspector is included in the Debugging
Manual, including how to explore the Prototype/Instance hierarchy of objects,
and how to use the Inspector for debugging more compilcated examples.


@section Parameters
@node Parameters
@anchor{parameters}

Most objects in Garnet have a list of @emph{parameters}, which are stored in the
@code{:parameters} slot. This is a list of all customizable properties of
the object. For example, @code{gv opal:rectangle :parameter} yields:

@code{(:LEFT :TOP :WIDTH :HEIGHT :LINE-STYLE :FILLING-STYLE :DRAW-FUNCTION :VISIBLE)}

These can be considered the "public" slots of @code{opal:rectangle}, which can
be given customized values when instances are created. If values are not
supplied for these slots when instances are created, the default values will
be inherited from the prototype object.

There are other slots that change when instances of @code{opal:rectangle} are
added to a window, such as the @code{:window} and @code{:parent} slots, but these
slots are not intended to be set manually. Since they are "read-only" slots,
they are not included in the @code{:parameters} list.

Several tools in Garnet rely heavily on the @code{:parameters} slot.
As discussed in section @ref{inspector-sec}, the Inspector displays the
parameter slots in red, so that they are easily identified. The
@code{gg:prop-sheet} gadget which is used in Gilt and Lapidary looks at the
@code{:parameters} slot to determine which slots should be displayed for the
user to customize. These objects are discussed thoroughly in later sections
of this reference manual.

The typical Garnet user will not have to worry much about the @code{:parameters}
slot. All of the slots that are in the list are documented in this manual,
so it is really just another way to access the same information about
properties of objects. For details on defining @code{:parameters} slots for
your own objects, see the KR Manual. Unless you are defining your own
list for a special object, the @code{:parameters} slot should be considered
read-only.


@section Destroying Objects
@node Destroying Objects
@anchor{destroying}

Before moving on to the next section, destroy the window so that it
does not interfere with future examples in this tutorial. Type the
following line.

@code{(opal:destroy WIN)}
				   
Destroying the window will also destroy all of the objects that were
added to its aggregate. We can no longer manipulate R1, R2, and R3,
since they were destroyed by the previous call. However, the
PROTO-RECT was never added to the top-level aggregate, and it was not
destroyed. You could destroy this object now with a @code{destroy}
call, but we will be using this object again in Section
@ref{destroying}. So, leave the object residing in memory for now.

When an object is destroyed, its variable name becomes unbound and the
memory space that was allocated to the object is freed. You can
@code{destroy} any object, including windows. If you destroy a window,
all objects inside of it are automatically destroyed. Similarly, if
you destroy an aggregate, all objects in it are destroyed. When you
destroy a graphical object (like a line or a circle), it is
automatically removed from any aggregate it might be in and erased
from the screen.

If a prototype object is destroyed (i.e., an object that has had
instances created from it), then all of the instances of that object
will be recursively destroyed. 

Occasionally in the course of developing a program, you may (either
accidentally or intentionally) define a new object which happens to
have the same name as an old object. When the new object is created,
its variable name is set to the new object, and the old object by the
same name is destroyed. Also, all of the instances of the old object
are recursively destroyed.

For example, in Section @ref{prototypes} above, we created the object
PROTO-RECT, which still exists in memory. If we now enter the
following new schema definition for an object by the same name, then
the old PROTO-RECT will be destroyed.

@code{(create-instance 'PROTO-RECT opal:rectangle)}

When the new schema is entered, a warning is given that the old object
is being destroyed. You can safely ignore this message, assuming that
you intended to override the definition of the old schema.


@section Unnamed Objects
@node Unnamed Objects
@anchor{unnamed-objects}

Sometimes you will want to create objects that do not have a
particular name. For example, you may want to write a function that
returns a rectangle, but it will be called repeatedly and should not destroy
previous instances with new ones. In this case, you should return an
unnamed rectangle from the function which can be used just like the
named objects we have created earlier in this tutorial.

As an example, the following code creates an
unnamed object and internally generates a unique variable name for it.
Instead of supplying a quoted name to @code{create-instance}, we give it
the value NIL.

@example
(create-instance NIL opal:rectangle
   (:left 10) (:top 10) (:width 75) (:height 50))
@end example

When you enter this schema definition, the @code{create-instance} call
will return the generated internal name of the rectangle -- something like
@code{RECTANGLE-123}. This name has a unique number as a
suffix that prevents it from being confused with other rectangles in
Garnet. You can now use the generated name to refer to the object.

@example
(gv RECTANGLE-123 :top)  @emph{; Replace this name with the name of your rectangle.}
@end example

Usually it is convenient to assign an unnamed object to a local
variable. The following line creates a circle and assigns it to the
new variable MY-CIRCLE.

@code{(setf MY-CIRCLE (create-instance NIL opal:circle))}

Now MY-CIRCLE will have the generated circle as its value. If the
same line were entered again, the old circle would not be destroyed,
but the variable MY-CIRCLE would still point to a new one. This can
be useful inside a function that uses a @code{let} clause -- every time
the @code{let} is executed, new objects are assigned to the local
variables, but the old objects still remain in memory and are not
destroyed. Section @ref{function} contains an example of how unnamed
objects might be used in a function.



@section Lines, Rectangles, and Circles
@node Lines, Rectangles, and Circles

The Opal package provides different graphical shapes
including circles, rectangles, roundtangles, and lines. There are
also several different kinds of text, and some special objects like
bitmaps and arrowheads. Each graphical object has special slots that
determine its appearance, which are documented in the Opal manual.
(For example, the line uses the slots @code{:x1}, @code{:y1}, @code{:x2},
and @code{:y2}.)
See the section  "Specific Graphical Objects" in the Opal manual for
details of how each object works. Examples of creating instances of
graphical objects appear throughout this tutorial.


@section Aggregates
@node Aggregates
@anchor{aggregates}

In order to put a large number of objects into a window, we might
create all of the objects and then add them, one at a time, to the
window. However, this is usually not how
we organize the objects conceptually. For example, if we were to
create a sophisticated interface with a scroll bar, several buttons,
and labels for the buttons, we would not want to add each rectangle in
the scroll bar and the buttons individually. Instead, we would think
of creating the scroll bar from its composite rectangles, then
creating the buttons along with their labels, and then adding the
scroll bar assembly and the button assembly to the window.

Grouping objects together like this is the function of the @code{aggregate}
object. Any graphical object can be a component of an aggregate - lines,
circles, rectangles, and even other aggregates. Usually all of the
components of an aggregate are related in some way, like they are all
parts of the same button.

Two other objects, the @code{aggregadget} and the
@code{aggrelist}, are also used to group objects, and usually appear more
often in Garnet programs. @code{Aggregadgets} and @code{aggrelists} are
instances of @code{aggregate}, and they have special features that make
them very useful in creating objects. These objects will be discussed
further in Section @ref{aggregadgets}.

The top-level object in a window is always an aggregate. This
aggregate contains all of the objects in that window.
Therefore, for an object to appear in a window it either has to be a
component of the top-level aggregate, or it has to be a component of
another aggregate which, at the top of its aggregate hierarchy, is a
component of the top-level aggregate.

When aggregates have other aggregates as components, an aggregate hierarchy
is formed. This hierarchy describes the way that objects are grouped together.
Figure @ref{v-scroll-hierarchy} shows how the objects that comprise a 
vertical scroll bar might be conceptually organized.

@float Figure, fig:ex1
@center @image{v-scroll-hierarchy, 5.5in}
@caption{One possible hierarchy for the objects that make up a scroll bar.}
@anchor{v-scroll-hierarchy}
@end float

In the scroll bar hierarchy, all of the leaves correspond to shapes
that appear in the scroll bar. The leaves are always Opal graphic
primitives, like rectangles and text. The nodes @code{top-trill-box} and
@code{bottom-trill-box} are both aggregates, each with two components.
And, of course, the top-level @code{scroll-bar} node is an aggregate.

This aggregate hierarchy should not be confused with the inheritance
hierarchy that was discussed earlier. Components of an aggregate do
not inherit values from their parents. Instead, relationships among
aggregates and components must be explicitly defined using
constraints, a concept which will be discussed shortly in this tutorial.

When an object is added to an aggregate, its @code{:parent} slot is set
to point to that aggregate. Therefore, in Figure @ref{v-scroll-hierarchy},
the @code{:parent} of the @code{bottom-trill-box} is the @code{scroll-bar}
aggregate. This @code{:parent} slot is called a @emph{pointer} slot because
its value is another Garnet object. Pointer slots are discussed
further in section @ref{aggregadgets}.

The functions @code{add-component}, @code{remove-component},
and @code{move-component} are used to manipulate the components of an
aggregate. Descriptions of these and other functions for components
may be found in the "Aggregate Objects" section of the Opal manual.


@section Aggregadgets, Aggrelists, and Aggregraphs
@node Aggregadgets, Aggrelists, and Aggregraphs
@anchor{aggregadgets}

Aggregadgets and aggrelists are types of aggregates. With these
objects, an aggregate and its components can basically be defined
simultaneously. In aggregadgets, all the components are defined
with a list in the @code{:parts} slot. In an aggrelist, a single object
is defined to be an "item-prototype", and the aggrelist automatically
generates several instances of that object to make its components.
The aggregraph is a type of aggregadget, where all the components are
nodes and arcs that make up a graph. Figures @ref{opal-inheritance}
and @ref{v-scroll-hierarchy} were created using Garnet aggregraphs.
For several examples and a complete discussion of how to use
aggregraphs, see the Aggregadgets, Aggrelists, and Aggregraphs
Reference Manual.


@subsection Aggregadgets
@node Aggregadgets

When you create an aggregadget, you may list all of the objects that
you want as components of the aggregadget in the @code{:parts} slot.
The list is specified using the standard Lisp backquote macro, and
there are usually many function calls and objects inside the list that
must be evaluated with a comma. As an example of an aggregadget, we
will analyze the following schema definition, but it is not necessary
to type it in. This code contains a few references that have not been
discussed in this tutorial yet, but it serves the purpose of giving us
a plain aggregadget to study. 

@example
(create-instance 'AGG opal:aggregadget
   (:left 10) (:top 20)
   (:parts
    `((:my-circle ,opal:circle
                  (:left 60) (:top 70)
                  (:width 100) (:height 100)
                  (:line-style ,opal:dashed-line))
      (:my-rect ,opal:rectangle
                (:left ,(o-formula (gvl :parent :left)))
                (:top ,(o-formula (gvl :parent :top)))
                (:width 80) (:height 40)
                (:filling-style ,opal:black-fill)
                (:line-style NIL)))))
@end example

The @code{:parts} slot in the AGG object contains
a list of lists, with each internal list being a definition of a component.
The components of AGG will be a circle and a rectangle, to which we
have given the arbitrary names @code{:my-circle} and @code{:my-rect}.
These names, which are preceded by a colon, will be the names of new
slots in the aggregadget. That is, two @emph{pointer} slots will be
created in AGG, named @code{:my-circle} and @code{:my-rect}, which will
have the circle and rectangle objects as their values. We say these are
pointer slots because they point to other objects.

Other pointer slots which are automatically created are the
@code{:parent} slots of both the circle and the rectangle. Since these
objects are being added as components to the aggregadget, their
@code{:parent} slots are set as with aggregates. Thus, a two-way path
of communication is established between the aggregadget and each of
its components -- the @code{:parent} slot points up, and the
@code{:my-circle} slot points down.

Notice that the @code{:parts} list is backquoted
(with a @code{`} instead of a @code{'}). Using this backquote syntax, we can then
use commas to evaluate the names of objects inside the list. The
references to be evaluated are the two graphical object prototypes (the
@code{opal:circle} and the @code{opal:rectangle}) and the graphical
qualities (@code{opal:dashed-line} and @code{opal:black-fill}).
Commas are also used to evaluate the @code{o-formula} calls, which
establish constraints among objects (constraints are discussed
in Chapter @ref{constraints}). If the commas were not present inside
the @code{:parts} list, then the names of all the Garnet objects would not be
dereferenced, and they would be treated as mere atoms, not objects.
Similarly, the calls to @code{o-formula} would appear as simple quoted
lists instead of function calls.

An important difference between aggregates and aggregadgets is that
when you create an instance of an aggregadget, the instance will
automatically have components that match those in the prototype. That
is, if we created an instance of AGG, called AGG-INSTANCE, then
AGG-INSTANCE would automatically have a circle and rectangle component
just like AGG. In contrast, when you create an instance of an
aggregate, the components are not automatically generated, and you
would have to create and add them to the instance manually.

Other examples of aggregadget definitions
can be found in sections @ref{aggregadget-ex} and @ref{big-example} in
this tutorial.

@subsection Aggrelists
@node Aggrelists

An aggrelist allows you to create and easily arrange objects into a
nicely formatted graphical list. The motivation for aggrelists comes
from the arrangement of groups of objects like button panels,
tic-marks, and menu choices, where all the components of an aggregate
are similar and should appear in a vertical or horizontal list.

In an aggrelist, a single item-prototype is defined, and then this
object is automatically copied several times to make the components of
the aggrelist. The @code{:left}, @code{:top}, and other slots of the
components are automatically given values that will neatly lay out the
components in a list, so that the programmer does not have to do any
calculations for the positions of the objects.

As with aggregadgets, aggrelists
use the backquote syntax to define the item prototype. There are many
customizable aspects of aggrelists, such as whether to orient the
components vertically or horizontally, the distance between each
object, etc. Since there are so many customizable slots, please see
the Aggregadgets and Aggrelists Reference Manual for a discussion of
how to use aggrelists. Section @ref{big-example} in this tutorial
includes an example of the definition of an aggrelist.


@section Windows
@node Windows

When we want to add an object to a window, what we really mean is that we
want to add the object to the window's top-level aggregate (or to an
aggregate at a lower level in that window's aggregate hierarchy).
Every window has one top-level aggregate, and all objects that appear
in the window are components in its aggregate hierarchy.

Any object must be added to a window in order for it to be shown on
the screen. Additionally, a window must be updated before any changes
made to it (or the objects in it) will appear. Windows are updated
when you explicitly issue a call to @code{opal:update}, and they are
also continuously updated when interactors are running and changing
objects in the window (during the @code{main-event-loop}, discussed in
Section @ref{interactors}).


@section Gadgets
@node Gadgets

The Garnet gadgets are a set of ready-made widgets that can be treated
as regular graphical objects. They have slots that can be customized
with user-defined values, and are added to windows just like graphical
objects. Generally, they are objects that are
commonly found in an interface including scroll bars, menus, buttons
and editable text fields. In the Tour, you created instances of the
radio button panel and the vertical slider. There are also more
sophisticated gadgets like scrolling windows, property sheets (to
allow quick editing of the slots of objects), and selection handles
(for moving and growing objects).

Most of the gadgets come in two versions -- one called the Garnet
Style, and one modeled after the OSF/Motif style. Examples of how to
use the gadgets are found in demonstration programs at the end of each
of the gadget files, which can be executed by commands like
@code{(garnet-gadgets:menu-go)}. For detailed descriptions of all the
available gadgets, see the Gadgets Reference Manual.



@section Constraints
@node Constraints


In the course of putting objects in a window, it is often desirable to
define relationships among the objects. For example, you may want
the tops of several objects to be aligned, or you might want a set of
circles to have the same center, or you may want an object to change
color if it is selected. Constraints are used in Garnet to define
these relationships among objects.

Although all the examples in this section use constraints on the
positions of objects, it should be clear that constraints can be
defined for filling styles, strings, or any other property of a Garnet
object. Many examples of constraints can be found in other sections
of this tutorial. Additionally, much of the KR Reference Manual is
devoted to the discussion of constraints among objects. The sections
"Constraint Maintenance" and "Slot and Value Manipulation Functions"
should be of particular interest.


@section Formulas
@node Formulas

A formula is an explicit definition of how to calculate the value for
a slot. If we want to constrain the top of one object to be the same
as another, then we define a formula for the @code{:top} slot of the dependent
object. With constraints, the value of one slot always @emph{depends} on
the value of one or more other slots, and we say the formula in that
slot has @emph{dependencies} on the other slots.

An important point about constraints is that they are constantly
maintained by the system. That is, they are evaluated once when they
are first created, and then they are continually @emph{re-evaluated} when
any of their dependencies change. Thus, if several objects depend on
the top of a certain rectangle, then all the objects will change
position whenever the rectangle is moved.

@float Figure, fig:ex1
@center @image{align-top, 5.5in}
@caption{Three objects that are all aligned with the same top. The
top of the gray rectangle is constrained to the white rectangle, and
the top of the black circle is constrained to the top of the gray rectangle.}
@anchor{align-top}
@end float

As our first example of defining constraints among objects, we will
make the window in Figure @ref{align-top}. Let's begin by creating
the white rectangle at an absolute position, and then create the other objects
relative to it. Create the window and the first box with the
following code.

@example
(create-instance 'CONSTRAINTS-WIN inter:interactor-window      @emph{; Create the window}
   (:left 750)(:top 80)(:width 260)(:height 100))
(create-instance 'TOP-AGG opal:aggregate)                      @emph{; Create an aggregate}
(s-value CONSTRAINTS-WIN :aggregate TOP-AGG)                   @emph{; Assign the aggregate to the window}
(opal:update CONSTRAINTS-WIN)                                  @emph{; Make the window appear}

(create-instance 'WHITE-RECT opal:rectangle                    @emph{; Create a rectangle}
   (:left 20) (:top 30)
   (:width 60) (:height 40)
   (:filling-style opal:white-fill))
		 
(opal:add-components TOP-AGG WHITE-RECT)                       @emph{; Add the rectangle to the window}
(opal:update CONSTRAINTS-WIN)                                  @emph{; Make changes in the window appear}
@end example

We are now ready to create the other objects that are aligned with
WHITE-RECT. We could simply create another rectangle and a circle that
each have their top at 30, but this would lead to extra work if we ever
wanted to change the top of all the objects, since each object's
@code{:top} slot would have to be changed individually. If we instead
define a relationship that depends on the top of WHITE-RECT, then
whenever the top of WHITE-RECT changes, the top of the other objects
will automatically change, too. Define the schema for the gray
rectangle as follows.

@example
(create-instance 'GRAY-RECT opal:rectangle
   (:left 110)
   (:top (o-formula (gv WHITE-RECT :top)))  @emph{; Constrain the top of this rectangle to the top of WHITE-RECT}
   (:width 60) (:height 40)
   (:filling-style opal:gray-fill))

(opal:add-components TOP-AGG GRAY-RECT)
(opal:update CONSTRAINTS-WIN)
@end example

You can see that without specifying an absolute position for the top
of the gray rectangle, we have constrained it to always have the same
top as the white rectangle. The formula in the @code{:top} slot of
the gray rectangle was defined using the functions @code{o-formula} and
@code{gv}. The @code{o-formula} function is used to declare that an
expression is a constraint. When @code{gv} is used inside a formula,
it causes a dependency to be established on the referenced slot, so that
the formula will be reevaluated when the value in the referenced slot
changes.@footnote{There is another function called @code{g-value}
that is similar
to @code{gv}, except that it never causes dependencies to be established.
Older versions of Garnet required that @code{gv} only be used inside
formulas, and @code{g-value} to be used ouside. The @code{gv} function has
since been enhanced so that it can be used everywhere. It would be
unusual to ever need to use @code{g-value}.}

To see if our constraint is working, try changing the
top of the white rectangle with the following instructions and notice
how the gray rectangle moves with it. Try setting the top to other
values, if you wish.

@example
(s-value WHITE-RECT :top 50)
(opal:update CONSTRAINTS-WIN)
@end example

The important thing to notice is that the value of the @code{:top} slot
of GRAY-RECT changes as the top of the WHITE-RECT changes. This shows
that the formula in GRAY-RECT is being re-evaluated whenever its
depended values change.

Now we are ready to add the black circle to the window. We have a
choice of whether to constrain the top of the circle to the white
rectangle or the gray rectangle. Since we are going to be examining
these objects closely in the next few paragraphs, let's constrain the
circle to the gray rectangle, resulting in an indirect relationship with
the white one. Define the black circle with the following code.

@example
(create-instance 'BLACK-CIRCLE opal:circle
   (:left 200)
   (:top (o-formula (gv GRAY-RECT :top)))
   (:width 40) (:height 40)
   (:filling-style opal:black-fill))

(opal:add-components TOP-AGG BLACK-CIRCLE)
(opal:update CONSTRAINTS-WIN)
@end example

At this point, you may want to set the @code{:top} of the white
rectangle again just to see if the black circle follows along with
the gray rectangle.


@section Cached Values
@node Cached Values

An interesting question might have occurred to
you -- what happens if you set the @code{:top} of the gray rectangle now?
Setting the value of a slot which already has a formula in it does @b{not}
destroy the existing constraint. However, it does override the
current @emph{cached} value of the formula. Try setting the @code{:top} of
the gray rectangle now.

@example
(s-value WHITE-RECT :top 30)  @emph{; Return everything to its original position}
(opal:update CONSTRAINTS-WIN)

(s-value GRAY-RECT :top 40)
(opal:update CONSTRAINTS-WIN)
@end example

The position of WHITE-RECT will remain unchanged, since it was defined with
an absolute position. However, the new value that we gave for the top
of the gray rectangle has repositioned GRAY-RECT and BLACK-CIRCLE.
Previously, the formula in the @code{:top} slot of GRAY-RECT had
correctly computed its own top, getting the value from the @code{:top}
slot of WHITE-RECT. Now, however, we replaced that cached value
with our absolute value of 40.

To show that the formula is still alive and well in the @code{:top} slot
of GRAY-RECT, try setting the @code{:top} slot of WHITE-RECT again.

@example
(s-value WHITE-RECT :top 10)
(opal:update CONSTRAINTS-WIN)
@end example

Since the top of GRAY-RECT depends on WHITE-RECT, its formula will be
recomputed whenever the top of WHITE-RECT changes. There is now a new
cached value for the @code{:top} of GRAY-RECT, a result of re-evaluating
the formula.


@section Formulas and s-value
@node Formulas and s-value

It is important to distinguish the behavior of @code{s-value} when it is
used on a slot with a formula in it, versus using it on a slot with an
absolute value in it (like the number 5). Setting the value of a slot that
@emph{already} has a formula in it will not destroy the old formula.
Instead, only the cached value of the formula is changed, and the
formula will be re-evaluated if any of its dependencies change.

On the other hand, @code{s-value} will replace one absolute value with
another absolute value, and the old value will never appear again.
That is, if an object was created with some particular absolute value for a
slot, and we changed that slot with @code{s-value}, then the new value
will be permanent until the slot is explicitly set again with @code{s-value}.

The one exception to the above rules is when the new value is a
formula itself. Using @code{s-value} to set a new formula will always
obliterate what was previously in the slot, whether it was an absolute
value or a formula.


@section Using the :obj-over Slot
@node Using the :obj-over Slot
@anchor{obj-over-slot}

When designing an interface, you may want a box to be drawn
around an object to show that it is selected. In the usual case, you
will want to define only one box that will be drawn around different
objects, and it would be nice if the box changed size when it was over
objects of different size. The traditional Garnet approach to this
problem is to use constraints in the dimension slots of the selection
box that depend on the dimensions of the object it is over.

@float Figure, fig:ex1
@center @image{obj-over, 5.5in}
@caption{A selection box drawn around an object.}
@anchor{obj-over}
@end float

In the traditional approach, we use the slot @code{:obj-over} in the
selection box to specify which object the selection box should be
drawn around. The @code{:obj-over} slot is a pointer slot, since it
contains an object as its value (pointer slots were discussed in
section @ref[aggregadgets]). Then, we define formulas for the
dimensions of the selection box which depend on the @code{:obj-over}
slot. The formulas in the following schema definition should be clear.

@example
(create-instance 'SEL-BOX opal:rectangle
   (:obj-over GRAY-RECT)  @emph{; A pointer slot}
   (:left (o-formula (- (gvl :obj-over :left) 10)))
   (:top (o-formula (- (gvl :obj-over :top) 10)))
   (:width (o-formula (+ 20 (gvl :obj-over :width))))
   (:height (o-formula (+ 20 (gvl :obj-over :height))))
   (:line-style opal:line-4))  @emph{; A line with a thickness of 4 pixels}
		 
(opal:add-components TOP-AGG SEL-BOX)
(opal:update CONSTRAINTS-WIN)
@end example

Now if you set the @code{:obj-over} slot of the selection box to be a
different object, the position and dimensions of SEL-BOX will change
according to the object.

@example
(s-value SEL-BOX :obj-over BLACK-CIRCLE)
(opal:update CONSTRAINTS-WIN)
@end example

You may have noticed that we performed computations in the formulas
above, instead of just using values directly as in the GRAY-RECT and
BLACK-CIRCLE objects. In fact, formulas can contain any lisp
expression. Also, the formulas above use the function @code{gvl}
instead of @code{gv}, which was used earlier. We use @code{gvl} here
because we are referencing a slot, @code{:obj-over}, in the same schema
as the formula. Previously, we used @code{gv} to look at a slot in a
different object. 

Another point of interest in these formulas is the use of indirect
references. In the @code{:left} formula above, the pointer slot @code{:obj-over}
is referenced, and then its @code{:left} slot is referenced, in turn.
It is important to distinguish between this case and the case where
a value is stored in the same object as the formula, as in the
following example.

Suppose we want the selection box to become invisible if no object is
currently selected. Using @code{s-value}, we can set the @code{:visible}
slot of SEL-BOX to have a formula which will cause the box to
disappear when its current selection is NIL. (We could have also
defined this formula in the @code{create-instance} call.)

@example
(s-value SEL-BOX :visible (o-formula (gvl :obj-over)))
@end example

Clearly, if @code{:obj-over} is set to NIL, then the value in the
@code{:visible} slot will also become NIL, and the box will become
invisible. When @code{:obj-over} is again set to be some object, then
the @code{:visible} slot will have a non-NIL value, and the box will
appear in the appropriate position. Previously, if we had set
@code{:obj-over} to NIL, then updating the window would have caused an
error when the formulas tried to access the @code{:left}, @code{:top},
@code{:width}, and @code{:height} of the non-existent selected object.

We are finished with the objects from this section, but the next
section will continue to use the same window. So, to remove the old
objects from the window, use the function @code{remove-components}.

@example
(opal:remove-components TOP-AGG WHITE-RECT GRAY-RECT BLACK-CIRCLE SEL-BOX)
(opal:update CONSTRAINTS-WIN)
@end example


@section Constraints in Aggregadgets
@node Constraints in Aggregadgets
@anchor{aggregadget-ex}

As mentioned in section @ref{aggregates}, the @code{:parent} slot of a
component is automatically set to its parent aggregate when it is
attached. Since aggregadgets are instances of aggregates, all of the
components defined in an aggregadget have their @code{:parent} slot set
in this way. In this section, we will examine how this slot can be
used to communicate between components of an aggregadget.

@sp 1
The aggregadget we will use in this example will make the picture of
concentric circles in Figure @ref{concentric-circles}. Suppose that
we want to be able to change the size and position of the circles
easily, and that this should be done by setting as few slots as
possible.

@float Figure, fig:ex1
@center @image{con-circles, 5.5in}
@caption{An aggregadget with three circles as components.}
@anchor{concentric-circles}
@end float

From the picture, we see that the dimensions of the black circle are
the same as the dimensions of the entire group of objects. That is,
if a bounding box were drawn around the black circle, all the other
objects would be inside the bounding box, too.
Therefore, it will be helpful to put slots for the size and position
of this circle in the top-level aggregadget, and have all the circles
reference these top-level values through formulas.

To start, let's create an aggregadget with only one component -- the
black circle -- and then redefine the aggregadget with the other
components later. The following code creates this one-component
aggregate.

@example
(create-instance 'CON-CIRCLES opal:aggregadget
   (:left 20) (:top 20)
   (:width 100)
   (:height (o-formula (gvl :width)))
   (:parts
    `((:black-circle ,opal:circle
                     (:left ,(o-formula (gvl :parent :left)))
                     (:top ,(o-formula (gvl :parent :top)))
                     (:width ,(o-formula (gvl :parent :width)))
                     (:height ,(o-formula (gvl :width)))
                     (:filling-style ,opal:black-fill)))))

(opal:add-component TOP-AGG CON-CIRCLES)
(opal:update CONSTRAINTS-WIN)
@end example

All those commas are needed because we want the Opal objects and the
calls to @code{o-formula} to be evaluated inside the backquoted list.
If the commas were not present, then those forms would become inert
atoms and lists instead of objects and function calls.

The black circle in the aggregadget gets its position and
dimensions from the top-level slots in CON-CIRCLES. The communication
link used here is the @code{:parent} slot, which points from the
component to the aggregadget. The function
@code{gvl} is used in the formulas for the black circle because the
@code{:parent} slot is in the same object as the formulas. Notice that
the black circle does @b{not} "inherit" any values from its parent.
Creating components in an aggregadget sets up an @emph{aggregate}
hierarchy, where values travel back-and-forth over constraints,
not inheritance links. If you want a component to depend on values in
its parent, you have to define constraints.

The other components of CON-CIRCLES will be defined analogously, but with
a little more computation in the formulas to get them to line up properly.
Before typing in the new definition of CON-CIRCLES, remove the old
aggregadget from the window with the following instruction.

@example
(opal:remove-components TOP-AGG CON-CIRCLES)
(opal:update CONSTRAINTS-WIN)
@end example

And now we are ready to redefine CON-CIRCLES again, this time with an
extra top-level slot to reduce redundant calculations, and of course
with the other two circles.

@example
(create-instance 'CON-CIRCLES opal:aggregadget
   (:left 20) (:top 20)
   (:width 100)
   (:height (o-formula (gvl :width)))
   (:radius/3 (o-formula (round (gvl :width) 6)))
   (:parts
    `((:black-circle ,opal:circle
                     (:left ,(o-formula (gvl :parent :left)))
                     (:top ,(o-formula (gvl :parent :top)))
                     (:width ,(o-formula (gvl :parent :width)))
                     (:height ,(o-formula (gvl :width)))
                     (:filling-style ,opal:black-fill))
      (:gray-circle ,opal:circle
                    (:left ,(o-formula (+ (gvl :parent :left)
					  (gvl :parent :radius/3))))
                    (:top ,(o-formula (+ (gvl :parent :top)
					 (gvl :parent :radius/3))))
                    (:width ,(o-formula (- (gvl :parent :width)
					   (* 2 (gvl :parent :radius/3)))))
                    (:height ,(o-formula (gvl :width)))
                    (:filling-style ,opal:gray-fill))
      (:white-circle ,opal:circle
                     (:left ,(o-formula (+ (gvl :parent :gray-circle :left)
					   (gvl :parent :radius/3))))
                     (:top ,(o-formula (+ (gvl :parent :gray-circle :top)
					  (gvl :parent :radius/3))))
                     (:width ,(o-formula (- (gvl :parent :gray-circle :width)
					    (* 2 (gvl :parent :radius/3)))))
                     (:height ,(o-formula (gvl :width)))
                     (:filling-style ,opal:white-fill)))))
            
(opal:add-components TOP-AGG CON-CIRCLES)
(opal:update CONSTRAINTS-WIN)
@end example

The gray circle gets its size and position from the top-level slots
just like the black circle, only it is one-third the size. The white circle
is the most interesting case, where it gets its position and
dimensions from the gray circle. Not only does the white circle
communicate with the aggregadget through the @code{:parent} slot, but it
also uses the slot @code{:gray-circle} which was automatically created
in the aggregadget (see section @ref[aggregadgets]). Thus, the
formulas in the white circle trace up the aggregate hierarchy to the
parent aggregadget, and then back down into another component.

To examine these pointer slots more closely, try executing the
following line.

@code{(gv CON-CIRCLES :white-circle)}

The value returned by this @code{gv} call is the internally
generated name of the white circle. This name was generated with a
unique suffix number so that it will not be confused with some other
white circle in Garnet (see Section @ref{unnamed-objects}). You can
also look at slots of the components directly, by adding slot names to
the end of the @code{gv} call, like

@code{(gv CON-CIRCLES :white-circle :top)}

or even

@code{(gv CON-CIRCLES :white-circle :parent)}

This is the end of the section regarding constraints. Destroy the window
we have been using to keep it from interfering with future examples in
the tutorial.

@code{(opal:destroy CONSTRAINTS-WIN)}



@section Interactors
@node Interactors

@anchor{interactors}

Interactors are used to communicate with the mouse and keyboard.
Sometimes you may just want a function to be executed when the mouse
is clicked, but often you will want changes to occur in the graphics
depending on the actions of the mouse. Examples include moving
objects around with the mouse, editing text with the mouse and
keyboard, and selecting an object from a given set.

The fundamental way that the interactors communicate with graphical
objects is that they set slots in the objects in response to mouse
movements and keyboard key strokes. That is, they generate side
effects in the objects that they operate on. For example, some interactors
set the @code{:selected} and @code{:interim-selected} slots to indicate which
object is currently being operated on. When objects are defined with
formulas that depend on these special slots, the appearance of the
objects (i.e., the graphics of the interface) can change in response
to the mouse.

It is important to note that all of the gadgets come with their
interactors already defined. Therefore, you do not need to create
interactors that change the gadgets.

In this section we will see some examples of how to change graphics in
conjunction with interactors. Section @ref{trace-inter} describes how
to use an important debugging function for interactors called
@code{trace-inter}. Although this tutorial only gives examples of
using the @code{button-interactor} and @code{move-grow-interactor}, the
Interactors Manual discusses and provides examples for all six types
of Garnet interactors.


@section Kinds of Interactors
@node Kinds of Interactors

The design of the interactors is based on the observation that there
are only a few kinds of behaviors that are typically used in graphical
user interfaces. Currently, Garnet supports seven types of interactive
behavior, which allows a wide variety of user actions in an interface.
Below is a list of the available interactors, which are described in
detail in the Interactors Manual.

@vtable @code 
@item @code{Menu-Interactor}
For selecting one or more choices from a set of
items. Useful in menus, etc., where the mouse may be held down and
dragged while moving over the items to be selected.

@item @code{Button-Interactor}
For selecting one or more choices from a set
of items. Useful in single buttons and panels of buttons where the
mouse can only select one item per mouse click.

@item @code{Move-Grow-Interactor}
For moving and changing the size of an
object. Useful in scroll bars and graphics editors.

@item @code{Two-Point-Interactor}
For obtaining one or two points in a
window from the user. Useful in specifying the size and position of a
new object to be created.

@item @code{Angle-Interactor}
For getting the angle that the mouse moves
around a point. Useful in circular gauges or for "stirring motions".

@item @code{Text-Interactor}
For editing strings. Most useful for small
strings, since Garnet does not support complicated word-processing
applications.

@item @code{Gesture-Interactor}
For recognizing gestures drawn by the user
(e.g., the user draws a rough shape that Garnet recognizes as a square).

@item @code{Animator-Interactor}
For executing a function at regular intervals,
allowing rapid updating of graphics.
@end vtable

There are also several interactors that work with the @code{multifont-text}
object. This object and its associated interactors are discussed in
the Opal manual.


@section The Button Interactor
@node The Button Interactor

In this example, we will perform an elementary operation with an
interactor. We will create a window with a white rectangle inside,
and then create an interactor that will make it change colors when
the mouse is clicked inside of it. First, create the window with the
white rectangle.

@example
(create-instance 'INTER-WIN inter:interactor-window
   (:left 750)(:top 80)(:width 250)(:height 250))
(create-instance 'TOP-AGG opal:aggregate)
(s-value INTER-WIN :aggregate TOP-AGG)
(opal:update INTER-WIN)

(create-instance 'CHANGING-RECT opal:rectangle
   (:left 20) (:top 30)
   (:width 60) (:height 40)
   (:filling-style (o-formula (if (gvl :selected)
				  opal:black-fill
				  opal:white-fill)))
   (:selected NIL))  @emph{; Set by the interactor}

(opal:add-components TOP-AGG CHANGING-RECT)
(opal:update INTER-WIN)
@end example

From the definition of the @code{:filling-style} formula, you can see
that if the @code{:selected} slot in CHANGING-RECT were to be set to be
non-NIL, then its color would turn to black. Conveniently, setting the
@code{:selected} slot is one of the side effects of the
@code{button-interactor}. The following code defines an interactor which
will set the @code{:selected} slot of CHANGING-RECT, which will cause it
to change colors.

@example
(create-instance 'COLOR-INTER inter:button-interactor
   (:window INTER-WIN)
   (:start-where (list :in CHANGING-RECT))
   (:start-event :leftdown))

@emph{; Unless using CMU, Allegro, Lucid, LispWorks, or MCL}
(inter:main-event-loop)
@emph{; Hit F1 while the mouse is in the Garnet window to exit}
@end example

The @code{main-event-loop} function causes Garnet to start paying
attention to events (like clicking the mouse) that trigger the interactors.
(A background process in CMU, Allegro, Lucid, LispWorks, and MCL always
pays attention to events.)
Now you can click on the rectangle
repeatedly and it will change from white to black, and back again.
From this observation, and knowing how we defined the
@code{:filling-style} of CHANGING-RECT, you can conclude that the
@code{button-interactor} is setting (and clearing) the @code{:selected}
slot of the object. This is one of the functions of the
@code{button-interactor}.
When you are ready to resume typing in the Lisp process, you have to
hit the F1 key while the mouse is in the Garnet window to get a new
prompt. (You may execute the @code{main-event-loop} call again at any
Lisp prompt.)

@float Figure, fig:ex1
@center @image{inter-white, 5.5in}
@center @image{inter-black, 5.5in}
@caption{The rectangle CHANGING-RECT when its @code{:selected} slot is NIL
(the default), and when it is set to T by the interactor (when the
mouse is clicked over it).}
@end float


@section A Feedback Object with the Button Interactor
@node A Feedback Object with the Button Interactor
@anchor{button-feed}

The method we used in the previous section with the
@code{button-interactor} involved setting the @code{:selected} slot of the
selected object. There is another way to use the button interactor
which involves using feedback objects. A @emph{feedback object} is some
object that indicates the currently selected object. For example, it is
often desirable that the actual selected object not move or change
color, but rather that a separate object follow the mouse or appear
over the selection.

In an earlier example in section @ref{obj-over-slot}, we defined a
selection box which works just like a feedback object. When the
@code{:obj-over} slot of the selection box was set to the name of the
selected object, then the box appeared around the selected object. In this
example, we will redefine the objects from that section and create an
interactor to work on them.

The following code is analogous to what was presented in section
@ref{obj-over-slot}, but here the three selectable objects are defined as
components in an aggregadget. Type in the following aggregadget and
feedback object, and add them to the current window. Notice that
because of the @code{:visible} formula in FEEDBACK-RECT, that rectangle
will be invisible when the window is first updated.

@example
(create-instance 'AGG opal:aggregadget
   (:top 100)
   (:parts
    `((:white-rect ,opal:rectangle
                   (:left 20)
                   (:top ,(o-formula (gvl :parent :top)))
                   (:width 60)
                   (:height 40)
                   (:filling-style ,opal:white-fill))
      (:gray-rect ,opal:rectangle
                  (:left 110)
                  (:top ,(o-formula (gvl :parent :top)))
                  (:width 60)
                  (:height 40)
                  (:filling-style ,opal:gray-fill))
      (:black-circle ,opal:circle
                     (:left 200)
                     (:top ,(o-formula (gvl :parent :top)))
                     (:width 40)
                     (:height 40)
                     (:filling-style ,opal:black-fill)))))

(create-instance 'FEEDBACK-RECT opal:rectangle
   (:obj-over NIL)  @emph{; A pointer slot to be set by the interactor}
   (:visible (o-formula (gvl :obj-over)))
   (:left (o-formula (- (gvl :obj-over :left) 10)))
   (:top (o-formula (- (gvl :obj-over :top) 10)))
   (:width (o-formula (+ 20 (gvl :obj-over :width))))
   (:height (o-formula (+ 20 (gvl :obj-over :height))))
   (:line-style opal:line-4))

(opal:add-components TOP-AGG AGG FEEDBACK-RECT)
(opal:update INTER-WIN)
@end example

Notice that the @code{:obj-over} slot of FEEDBACK-RECT is a pointer
slot, as usual. When @code{:obj-over} is set with the name of an
object, the FEEDBACK-RECT will appear over the object because of the
way we defined its position and dimension formulas. In this example,
we will not set @code{:obj-over} by hand, as we did previously.
Instead, we will create a @code{button-interactor} to set the slot for us.

The following code defines an interactor which uses the FEEDBACK-RECT
to indicate which object is selected. Since all of the selectable
objects are in the same aggregate, we can tell the interactor to start
whenever the mouse is clicked over any component of AGG.

@example
(create-instance 'SELECTOR inter:button-interactor
   (:window INTER-WIN)
   (:start-where (o-formula (list :element-of AGG)))  @emph{; Work on the components of AGG}
   (:final-feedback-obj FEEDBACK-RECT)
   (:how-set :toggle))

@emph{; Unless using CMU, Allegro, Lucid, LispWorks, or MCL}
(inter:main-event-loop)
@emph{; Hit F1 while the mouse is in the Garnet window to exit}
@end example

Now when you click on the objects, the feedback object will appear
over the selected object. The reason is that the
@code{button-interactor} sets the @code{:obj-over} slot of the feedback
object. Since the interactor is a toggling
interactor (according to its @code{:how-set} slot), the @code{:obj-over}
slot will be reset to NIL when the selected object is clicked on again.

If you entered the @code{main-event-loop}, remember to hit the F1 key
before typing in the next example.


@section The Move-Grow Interactor
@node The Move-Grow Interactor

From the previous example, you can see that it is easy to change the
graphics in the window using the mouse. We are now going to define several
more objects in the window and create an interactor to move them.

The side effect of the @code{move-grow-interactor} is that it sets the
@code{:box} slot of the selected object (as well as the feedback object,
if any) to be a list of four values -- the left, top, width, and
height of the object. When formulas are defined in the @code{:left},
@code{:top}, @code{:width}, and @code{:height} slots which depend on
the @code{:box} slot, then the position and dimensions of the
object will change whenever the @code{:box} slot changes.

The idea goes like this:  Suppose the current value of the @code{:box}
slot in a rectangle is '(0 0 40 40). Since the @code{:left} and
@code{:top} slots are constrainted to the @code{:box} slot, the rectangle
appears at the position (0,0). To move the object, the user clicks
and drags on the rectangle until it is at position (50,50). When the
user lets go, then the interactor automatically sets the @code{:box}
slot to '(50 50 40 40). Since the @code{:box} slot has changed, the
formulas in the @code{:left} and @code{:top} slot are re-evaluated, and
the rectangle appears at the new position.

The following code creates a prototype circle and several instances of
it. With a little study, it should be clear how the position and dimension
formulas work with respect to the @code{:box} slot. All of the circles
are then added to an aggregate, and this aggregate is added as a
component to the top-level aggregate.

@example
(create-instance 'MOVING-CIRCLE opal:circle
   (:box '(0 0 40 40))  @emph{; This slot will be set by the interactor}
   (:left (o-formula (first (gvl :box))))     @emph{; Get the first value in the list}
   (:top (o-formula (second (gvl :box))))     
   (:width (o-formula (third (gvl :box))))
   (:height (o-formula (fourth (gvl :box)))))

(create-instance 'M1 MOVING-CIRCLE
   (:box '(120 30 40 40)))

(create-instance 'M2 MOVING-CIRCLE
   (:box '(30 100 60 60)))

(create-instance 'M3 MOVING-CIRCLE
   (:box '(120 100 80 80)))

(create-instance 'CIRCLE-AGG opal:aggregate)

(opal:add-components CIRCLE-AGG M1 M2 M3)		 

(opal:add-components TOP-AGG CIRCLE-AGG)
(opal:update INTER-WIN)
@end example

If you want to try setting the @code{:box} slot of any of these objects,
you will see how the position and dimension of each circle depend on
it. Be sure you set the @code{:box} slot to be a list of four positive
numbers, or an error will occur!

Now let's create an instance of the @code{move-grow-interactor}, which
will cause the moving circles to change position. The following
interactor works on all the components of the aggregate CIRCLE-AGG.
Remember to execute the @code{inter:main-event-loop} call to start the
interactors working.

@example
(create-instance 'MG-INTER inter:move-grow-interactor
   (:window INTER-WIN)
   (:start-where (list :element-of CIRCLE-AGG)))    @emph{; Work on the components of CIRCLE-AGG}

@emph{; Unless using CMU, Allegro, Lucid, LispWorks, or MCL}
(inter:main-event-loop)
@emph{; Hit F1 while the mouse is in the Garnet window to exit}
@end example

Now if you press and drag in any of the circles, they will follow the
mouse. This is because the interactor sets the @code{:box} slot of the
object that it is pressed over, and the @code{:left} and @code{:top} slots
of the objects depend on the @code{:box} slot.

It is worth noting once again that the @code{move-grow-interactor} does
@b{not} set the @code{:left}, @code{:top}, etc. slots of the selected
object. It instead sets the @code{:box} slot of the selected
object, and the user is required to define formulas that depend on the
@code{:box} slot.


@section A Feedback Object with the Move-Grow Interactor
@node A Feedback Object with the Move-Grow Interactor

Now let's add a feedback object to the window that will work with the
moving circles. In this case, the feedback object will appear
whenever we click on and try to drag a circle. The mouse will
actually drag the feedback object, and then the real circle will jump
to the final position when the mouse is released.

Our feedback object will be a circle with a dashed line. The
DASHED-CIRCLE object defined below will have two slots set by the
interactor. The @code{:box} slot will be set while the mouse is held
down and dragged, and the @code{:obj-over} slot will be set to point to the
circle being dragged. Given our MOVING-CIRCLE prototype, the feedback
object is easy to define.

@example
(create-instance 'DASHED-CIRCLE MOVING-CIRCLE
   @emph{; Inherit all the :left, :top, etc. formulas that depend on the :box slot.}
   (:obj-over NIL)  @emph{; Set by the interactor}
   (:visible (o-formula (gvl :obj-over)))
   (:line-style opal:dashed-line))

(opal:add-components TOP-AGG DASHED-CIRCLE)
@end example

The @code{:visible} slot is set with a formula because we only want the
feedback object to be visible when it is being used with the
interactor. Now, we will redefine the move-grow interactor to use
DASHED-CIRCLE as a feedback object. (Redefining the MG-INTER will
destroy the old instance, so don't worry if a warning appears.)

@example
(create-instance 'MG-INTER inter:move-grow-interactor
   (:window INTER-WIN)
   (:start-where (list :element-of CIRCLE-AGG))
   (:feedback-obj DASHED-CIRCLE))
@end example

Now when you move the circles with the mouse, the feedback object will
follow the mouse, instead of the real circle following it directly.

Since we have finished this section on interactors, destroy the window
so that it does not interfere with the next example. Type the
following line.

@code{(opal:destroy INTER-WIN)}


@section Creating a Panel of Text Buttons
@node Creating a Panel of Text Buttons
@anchor{big-example}

In this section, we will go through a comprehensive example that pulls
together all the concepts that have been discussed in this tutorial.
The final objective will be the panel of text buttons in Figure
@ref{text-buttons}. We will use an aggregadget to assemble a group
of objects into a single button, then use an aggrelist to make
multiple copies of the text button and organize them into a list for
the panel, and finally create a button interactor to manage the panel.


@subsection The Limitations of Aggregates
@node The Limitations of Aggregates

Before starting the aggregadget for this example, let's take a look at the use
of an aggregate. This will help to demonstrate the usefulness of
aggregadgets. First, create a window with a top-level aggregate and
update it:

@example
(create-instance 'BUTTON-WIN inter:interactor-window
   (:left 800)(:top 10)(:width 200)(:height 400))
(create-instance 'TOP-AGG opal:aggregate)
(s-value BUTTON-WIN :aggregate TOP-AGG)
(opal:update BUTTON-WIN)
@end example

The TOP-AGG aggregate is the top-level aggregate for the window. If
we want any object to appear in the window, it will have to be added
to TOP-AGG, or added to an aggregate further below in TOP-AGG's
aggregate hierarchy. We will keep TOP-AGG as the top-level aggregate
throughout this example, but we will be changing its components continually.

Now we can begin adding objects to TOP-AGG (throughout this discussion
you should periodically check Figure @ref{text-buttons} to see why we
are creating particular objects). Let's start by assembling a button.
We will first create a couple of rectangles that have a fixed position
so that we get the window in Figure @ref{two-rects}. Since we
want the rectangles to have the same dimensions, we can make a
prototype object and then create two instances with appropriate
position values.

@example
(create-instance 'PROTO-RECT opal:rectangle
   (:width 100) (:height 50))

(create-instance 'R1 PROTO-RECT
   (:left 40) (:top 40)
   (:filling-style opal:black-fill))

(create-instance 'R2 PROTO-RECT
    (:left 20) (:top 20)
    (:filling-style opal:gray-fill))

(opal:add-components TOP-AGG R1 R2)
(opal:update BUTTON-WIN)
@end example

@float Figure, fig:ex1
@center @image{two-rects, 5.5in}
@caption{The two rectangles R1 and R2, which are instances of PROTO-RECT.}
@anchor{two-rects}
@end float

Keeping in mind our goal of making a panel of text buttons, one
problem should be immediately clear. In order to make several
buttons with this method, we will have to calculate the position of
every rectangle in the interface and explicitly create an object for
it. This will be time consuming, to say the least, and motivates us
to investigate how constraints will help avoid tedious calculations.
So, as the first step in pursuing a more fruitful approach, let's
remove the rectangles from the window and move on to aggregadgets.
To remove the rectangles, execute:

@example
(opal:remove-components TOP-AGG R1 R2)
(opal:update BUTTON-WIN)
@end example


@subsection Using an Aggregadget for the Text Button
@node Using an Aggregadget for the Text Button

When we create an aggregadget, we essentially create an aggregate and
add the components (along with pointer slots) all at once. Our task
is to build an aggregadget 
with two rectangles as components which will look like Figure
@ref{two-rects}. Since we already know what we want the
rectangles to look like in the window, putting a simple aggregadget
together using our previously defined R1 and R2 rectangles is
straightforward. However, the key to avoiding tedious
calculations of the positions of our rectangles is to generalize the
code. That is, we want the positions of our components to be formulas
rather than absolute numbers.

For the present, let's assume that we will always be giving absolute
numbers to our top-level aggregadget (but not its components). The first
problem we want to address 
is how to devise formulas for the positions of the rectangles.
By referring back to Figure @ref{two-rects},
we see that the entire aggregate has its upper-left
coordinate at one corner of the gray rectangle, and its lower-right
coordinate on the shadow. Therefore, it is a reasonable design
decision to put the left and top of the gray rectangle at the left,
top corner of the aggregadget, and then put the shadow 20 pixels
further below and to the right. The following code shows the
definition of our new BUTTON aggregadget with formulas defined for the
positions of the rectangle components.

@example
(create-instance 'BUTTON opal:aggregadget
   (:left 20) (:top 20)
   (:shadow-width 100) (:shadow-height 50)
   (:parts
    `((:shadow ,opal:rectangle
	       (:left ,(o-formula (+ 20 (gvl :parent :left))))
	       (:top ,(o-formula (+ 20 (gvl :parent :top))))
	       (:width ,(o-formula (gvl :parent :shadow-width)))
	       (:height ,(o-formula (gvl :parent :shadow-height)))
	       (:filling-style ,opal:black-fill))
      (:gray-rect ,opal:rectangle
		  (:left ,(o-formula (gvl :parent :left)))
		  (:top ,(o-formula (gvl :parent :top)))
		  (:width ,(o-formula (gvl :parent :shadow-width)))
		  (:height ,(o-formula (gvl :parent :shadow-height)))
		  (:filling-style ,opal:gray-fill)))))

(opal:add-components TOP-AGG BUTTON)
(opal:update BUTTON-WIN)
@end example

After studying the BUTTON schema for a moment, several features stand out. 
First, there are two slots called @code{:shadow-width} and
@code{:shadow-height} defined in the top-level schema, which are used by
the width and height formulas of the component rectangles. The
presence of these slots at the top-level will make it easier to change
the appearance of the button in the future -- if we want to make it
wider, we only need to change one slot, @code{:shadow-width}, instead
of all the components' @code{:width} slots.

Next, it should be clear that the formulas in the @code{:left} and
@code{:top} slots of the components will place the rectangles at the
appropriate positions relative to each other, with the shadow further
down and to the right. Finally, it is important that the shadow comes
first in the order of defining the components. Objects are drawn on
the screen in the order that they are added to an aggregate, so we
definitely want the gray rectangle to come after the shadow.

Notice that there is no "inheritance" going on in the BUTTON
aggregadget. When we want a component to get a value from its parent,
we have to explicitly define a constraint that gets that value.

We have just finished the first step in creating a text button.
Although there is more code in the aggregadget example than in the
previous example with rectangles R1 and R2, the aggregadget code is
simple and flexible. Also, almost all of the formulas that you will
write in the future will resemble those in this example. The only
difference will be the names of the slots and the arithmetic that is
appropriate for the situation.

Now we are ready to add more objects to the button. To do this, we will
not add objects to BUTTON while it is in the window. Instead, we will
remove the old BUTTON aggregadget from the window and write a new one from
scratch. Most of the code that we have already written will be reused,
however, and if you still have a copy of the previous example on your screen,
you will be able to cut-and-paste it. So execute the command that
will remove the button from the top-level aggregate:

@example
(opal:remove-components TOP-AGG BUTTON)
(opal:update BUTTON-WIN)
@end example


@subsection Defining Parts Using Prototypes
@node Defining Parts Using Prototypes

Before constructing an aggregadget with additional components, let's
look at another way to define components in aggregadgets. This method
will make it easier for us to develop the BUTTON aggregadget by
condensing some of the code and eliminating a lot of typing.

In the previous example, the components were instances of rectangles.
Another way to define components is to define them as prototypes
separate from the aggregadget, and then create instances of those
prototypes in the aggregadget @code{:parts} slot. The following code
comes from this alternate method for defining aggregadgets.

@example
(create-instance 'SHADOW-PROTO opal:rectangle
   (:left (o-formula (+ 20 (gvl :parent :left))))
   (:top (o-formula (+ 20 (gvl :parent :top))))
   (:width (o-formula (gvl :parent :shadow-width)))
   (:height (o-formula (gvl :parent :shadow-height)))
   (:filling-style opal:black-fill))

(create-instance 'GRAY-PROTO opal:rectangle
   (:left (o-formula (gvl :parent :left)))
   (:top (o-formula (gvl :parent :top)))
   (:width (o-formula (gvl :parent :shadow-width)))
   (:height (o-formula (gvl :parent :shadow-height)))
   (:filling-style opal:gray-fill))

(create-instance 'BUTTON opal:aggregadget
   (:left 20) (:top 20)
   (:shadow-width 100) (:shadow-height 50)
   (:string "Button")
   (:parts
    `((:shadow ,SHADOW-PROTO)
      (:gray-rect ,GRAY-PROTO))))

(opal:add-components TOP-AGG BUTTON)
(opal:update BUTTON-WIN)
@end example


Notice that this way of looking at aggregadgets is entirely consistent
with the previous aggregadget definition. In the @code{:parts} slot of
our new button, we have created instances just like before, but we
have not explicitly defined any slots in the components. It does not matter
whether we set slots in the prototype objects or in the parts
definitions. Using this abbreviation method for defining aggregadgets, 
we can now avoid retyping the slot definitions for the old components
and move on to talking about new ones.

It should be noted that the SHADOW-PROTO and GRAY-PROTO rectangles can
not be added to a window by themselves. If you were to try this, you
would get an error when Garnet tried to evaluate any of the formulas
that we defined. This is because there is no @code{:parent} for either
the SHADOW-PROTO or the GRAY-PROTO, which is clearly needed by the
formulas. But when instances of these rectangles are added to the BUTTON
aggregadget, their @code{:parent} slots are set to be the parent aggregadget.

As usual, remember to remove the current BUTTON from the window using
@code{remove-components}.


@subsection The Label of the Button
@node The Label of the Button

Referring to Figure @ref{text-buttons} again, we see that the text
button needs a white rectangle to be centered over the gray one, and text
should be centered inside the white rectangle. We will want the string of
the text object to be a top level slot in the aggregadget so that we
can change it easily. Thus, we need to place a constraint in the text
object to retrieve it (remember the text object does not "inherit" the
string from its parent just because it is a component). Other than
that, the addition of the new 
components to the BUTTON aggregadget is straightforward. Using the
abbreviation method for defining aggregadgets, we get the following code
(the components SHADOW-PROTO and GRAY-PROTO were defined above).

@example
(create-instance 'WHITE-PROTO opal:rectangle
   (:left (o-formula (+ 7 (gvl :parent :gray-rect :left))))
   (:top (o-formula (+ 7 (gvl :parent :gray-rect :top))))
   (:width (o-formula (- (gvl :parent :gray-rect :width) 14)))
   (:height (o-formula (- (gvl :parent :gray-rect :height) 14)))
   (:filling-style opal:white-fill))

(create-instance 'TEXT-PROTO opal:text
   (:left (o-formula (+ (gvl :parent :white-rect :left)
			(round (- (gvl :parent :white-rect :width)
				  (gvl :width))
			       2))))
   (:top (o-formula (+ (gvl :parent :white-rect :top)
		       (round (- (gvl :parent :white-rect :height)
				 (gvl :height))
			      2))))
   (:string (o-formula (gvl :parent :string))))

(create-instance 'BUTTON opal:aggregadget
   (:left 20) (:top 20)
   (:shadow-width 100) (:shadow-height 50)
   (:string "Button")
   (:parts
    `((:shadow ,SHADOW-PROTO)
      (:gray-rect ,GRAY-PROTO)
      (:white-rect ,WHITE-PROTO)
      (:text ,TEXT-PROTO))))

(opal:add-components TOP-AGG BUTTON)
(opal:update BUTTON-WIN)
@end example

Although the centering formulas for the @code{:left} and @code{:top} slots
of the text object are a little more complicated, they are basic
calculations that find the proper position of the text based on the
dimensions of the white rectangle. Another aspect of the formulas is
that they reference not only slots in the parent object, but also
slots in their sibling objects. Specifically, in the @code{white-rect}
part, the @code{:left} formula looks up the aggregate tree to the
@code{:parent}, and then looks down again into the @code{gray-rect}. The
same tracing of the aggregate tree is involved in the @code{text}
formulas for @code{:left} and @code{:top}.


@subsection Instances of the Button Aggregadget
@node Instances of the Button Aggregadget

It should be clear by now that aggregadgets are particularly useful
for organizing and defining components. After creating the four
prototype objects by themselves, we were able to define BUTTON with
the compact aggregadget above. And with our current definition of
BUTTON, we will now see another significant use of aggregadgets. The
following code creates several instances of the BUTTON aggregadget,
which we can use as a prototype. When you add these instances to the
window, you see that component rectangles and text are generated
automatically for the instances.

@example
(create-instance 'BUTTON-1 BUTTON
   (:left 130) (:top 80)
   (:shadow-width 60)
   (:string "abcd"))

(create-instance 'BUTTON-2 BUTTON
   (:left 10) (:top 120)
   (:string "Button-2"))

(opal:add-components TOP-AGG BUTTON-1 BUTTON-2)
(opal:update BUTTON-WIN)
@end example

@float Figure, fig:ex1
@center @image{several-buttons, 5.5in}
@caption{The BUTTON object and two instances of it.}
@anchor{several-buttons}
@end float

This feature of aggregadgets means that you do not need to manually
create objects individually and add them to the window. Instead, you
can create a group of objects, and then create instances of the group.

Before moving to the next section, remember to remove your three button
objects from the window with @code{remove-components}.


@subsection Making an Aggrelist of Text Buttons
@node Making an Aggrelist of Text Buttons

Even though instances of the aggregadget will automatically generate
components, the instances BUTTON-1 and BUTTON-2 show that we still
need to manually supply coordinates to the aggregadget in order to
position it. When we create the finished text button panel in Figure
@ref{text-buttons}, we don't want to calculate the position of each
text button in the window. (Notice that this is similar to the
problem we faced several sections ago -- that we didn't want to
compute the position of each rectangle within a text button.)  The
solution to this problem (as before) is to use a special type of
aggregate that will generate components for us. This time, we will
use an aggrelist.

Just for a start, let's create a simple itemized aggrelist. We will
supply an item-prototype and a number to the aggrelist, and it will
generate that number of instances of the item-prototype.
Specifically, we want the aggrelist to make five copies of the BUTTON
aggregadget. So, let's try the following code.

@example
(create-instance 'PANEL opal:aggrelist
   (:left 30) (:top 10)
   (:items 5)
   (:item-prototype BUTTON))

(opal:add-components TOP-AGG PANEL)
(opal:update BUTTON-WIN)
@end example

@float Figure, fig:ex1
@center @image{five-buttons, 5.5in}
@caption{An aggrelist with an @code{:items} value of 5 and the BUTTON
aggregadget as its @code{:item-prototype}.}
@anchor{five-buttons}
@end float

By supplying the number 5 in the @code{:items} slot, we tell the
aggrelist to make five copies of its item-prototype. And, because
this is an aggrelist, all the copies of the prototype are automatically
appropriate @code{:left} and @code{:top} coordinates. It turns out that
we only had to give the position of the left and top of the aggrelist;
all the calculations for the buttons were handled internally.
There are many customizable slots for aggrelists that change the
appearance of the aggrelist -- like whether to make the panel
horizontal or vertical, how much space to put between the items, etc.
A list of these slots is in the Aggregadgets manual, which you can try
out later.

The next step in the development of our panel is to give each button
an appropriate label. To do this, we need to supply a list of
labels to the aggrelist. The proper place to do this is in the
@code{:items} slot. As we just saw, if you give the @code{:items} slot a
number, the aggrelist generates that number of items. If instead you
give it a list, then it will generate the same number of components as
there are items in the list. We will also have to change the BUTTON
prototype so that its @code{:string} slot pays attention to the list of
items we supply. The following code makes this change to the BUTTON
prototype in the definition of the aggrelist, so we don't have to
redefine the BUTTON aggregadget.

@example
(create-instance 'PANEL opal:aggrelist
   (:left 30) (:top 10)
   (:items '("Mozart" "Chopin" "Strauss" "Beethoven" "Vivaldi"))
   (:item-prototype
    `(,BUTTON
      (:string ,(o-formula (nth (gvl :rank) (gvl :parent :items)))))))

(opal:add-components TOP-AGG PANEL)
(opal:update BUTTON-WIN)
@end example

The @code{:rank} slot in the @code{:string} formula above is put into each
component generated by the aggrelist. Even though there is no
@code{:rank} in our definition of BUTTON, when the aggrelist generates
its components, it ranks the objects in the order that they are
created and stores these ranks in the @code{:rank} slot (ranks start at 0).
This makes it easy to find the item in the @code{:items} list that
corresponds to each component. 

Since we are going to be redefining objects again, remember to remove
the PANEL object from the window before going on.


@subsection Adding an Interactor
@node Adding an Interactor

We are almost finished with the text button panel.
At this point, the panel that we have written is still a passive
graphical object -- if you press on it with the mouse, it acts just
like a pile of rectangles and does nothing at all. Therefore, the
next step is to add an interactor that will cause the appearance of
the buttons to change whenever we click the mouse on it. Suppose we
choose to use a @code{button-interactor} for our interface between the
mouse and the panel. By applying the principles discussed in
the interactor section of this tutorial, we can write the following
code for our interactor.

@example
(create-instance 'PRESS-PROTO inter:button-interactor
   (:window (o-formula (gvl :operates-on :window)))
   (:start-where (o-formula (list :element-of (gvl :operates-on))))
   (:start-event :leftdown))
@end example

The code for this interactor is short and simple. It is a
prototype object just like the rectangles, but it happens to be an
interactor. The @code{:operates-on} reference in the formulas is
analogous to the @code{:parent} slot in objects, and the slot is
automatically created when the interactor is attached to an
aggregadget or aggrelist. In interactors, the
@code{:operates-on} slot points to the aggregadget that it is attached
to, just like the @code{:parent} slot of a graphical object points to
its aggregate. Notice that we have supplied values for the two
required slots in an interactor. The @code{:window} slot points to the
window of the aggregadget that the interactor will be attached to,
which is reasonable since we want the interactor to work in the same
window that the graphics appear in. The value in the
@code{:start-where} slot tells the interactor to start whenever the
mouse is clicked over any component of the aggrelist (that is, over
any button).

Before we attach this interactor to the PANEL aggregadget, we are
going to have to change a few of the formulas in the button and its
components. The question to ask is -- how should the graphics change
when we press the mouse over the button?  By looking at the full
text-buttons picture in Figure @ref{text-buttons}, we see that the
gray rectangle should move down and to the right, settling over the
shadow. Therefore, we will have to change the formulas for the
@code{:left} and @code{:top} of the gray rectangle. We do not have to
change the @code{:left} and @code{:top} slots of the white rectangle or
text because they are already constrained to the gray rectangle's
position.

As you recall from the "Interactors" section of this
tutorial, the @code{button-interactor} sets the @code{:selected} slot of
the object it operates on when it is clicked on with the mouse.
Additionally, the interactor will also set the @code{:interim-selected}
slot of the object while the mouse is being held down over it. With
this in mind, it would be useful to make the gray rectangle formulas
depend on the @code{:interim-selected} slot of the aggregadget, since
the gray rectangle should settle over the black rectangle when the
mouse is held down over the button. A new GRAY-PROTO object that will
respond to the interactor follows.

@example
(create-instance 'GRAY-PROTO opal:rectangle
   (:left (o-formula (if (gvl :parent :interim-selected)
			 (gvl :parent :shadow :left)
			 (gvl :parent :left))))
   (:top (o-formula (if (gvl :parent :interim-selected)
			(gvl :parent :shadow :top)
			(gvl :parent :top))))
   (:width (o-formula (gvl :parent :shadow-width)))
   (:height (o-formula (gvl :parent :shadow-height)))
   (:filling-style opal:gray-fill))
@end example

The new formulas in the @code{:left} and @code{:top} of the new GRAY-PROTO
now look at the @code{:interim-selected} slot of the button. When the
mouse is clicked over a button, the button's @code{:interim-selected}
slot will be set to T, causing the gray rectangle to be moved down and
to the right. When the mouse is released, the @code{:interim-selected}
slot will be set back to NIL, and the gray rectangle will return to
its normal position.

If you refer back to the definitions of the other components, you will
see why the gray rectangle is the only component that we had to
change. The white rectangle depended on the position of the gray
rectangle, and the text was centered inside the white one. Thus, when
the gray rectangle's position changed, the change was propagated to
all of the dependent formulas, resulting in uniform movement of the
components.

There is one final note to make before we can complete the panel.
When the gray rectangle is pushed down onto the shadow, the dimensions
of the button are going to change. That is, when the gray
rectangle covers the shadow completely, then the button's aggregate has
smaller dimensions than if the two rectangles are spread out a bit.
If left unchecked, this will cause unexpected behavior because the
aggrelist keeps the components arranged according to their width and
height. For this reason, we will have to supply our own @code{:width}
and @code{:height} values to the BUTTON aggregadget within our
definition of the PANEL. To see the problem for yourself, you may
want to leave out the @code{:width} and @code{:height} values in the
following code just to see what happens. Then you will certainly want
to try the code again with the values in place. 

@example
(create-instance 'BUTTON opal:aggregadget
   (:left 20) (:top 20)
   (:width 120) (:height 70)  @emph{; The dimensions of the two rectangles plus their offset}
   (:shadow-width 100) (:shadow-height 50)
   (:string "Button")
   (:parts
    `((:shadow ,SHADOW-PROTO)
      (:gray-rect ,GRAY-PROTO)
      (:white-rect ,WHITE-PROTO)
      (:text ,TEXT-PROTO))))

(create-instance 'PANEL opal:aggrelist
   (:left 30) (:top 10)
   (:items '("Mozart" "Chopin" "Strauss" "Beethoven" "Vivaldi"))
   (:item-prototype
    `(,BUTTON
      (:string ,(o-formula (nth (gvl :rank) (gvl :parent :items))))))
   (:interactors
    `((:press ,PRESS-PROTO))))

(opal:add-components TOP-AGG PANEL)
(opal:update BUTTON-WIN)

@emph{; Required if you are not using CMU, Allegro, Lucid, LispWorks, or MCL}
(inter:main-event-loop)  @emph{; To start the interactors.}
                         @emph{; Hit F1 in the Garnet window to exit.}
@end example

@float Figure, fig:ex1
@center @image{text-buttons, 5.5in}
@caption{The finished text button panel.}
@anchor{text-buttons}
@end float

Once you have entered the @code{main-event-loop} (not necessary in CMUCL,
Allegro, Lucid, LispWorks, or MCL), you can click on any of the buttons and
they will respond. The movement comes from the interactor setting the
@code{:interim-selected} slot of the button that you press on, which
causes the @code{:left} and @code{:top} slots of the components to be
re-evaluated. When you let go, the @code{:interim-selected} slot is
cleared, and the components return to their original position.

Remember to destroy the window when you are finished with this example.

@code{(opal:destroy BUTTON-WIN)}


@section Referencing Objects in Functions
@node Referencing Objects in Functions
@anchor{function}

If a function that returns an object is only going to be called once,
then it is usually appropriate to explicitly name the objects in each
@code{create-instance} call. This is the method used in the
demonstration functions that accompany the gadgets. However, if a
function is called repeatedly and returns objects which will be used
at the same time, then unnamed objects should probably be used.

For example, the function below will create and return windows with
messages in them. If the window in the function was explicitly named
(say 'WIN or something), then each call to the function would destroy
the previous window instance while creating the new one.

@example
(defun Make-Win (left top string)
  @emph{; Create unnamed objects and assign them to local variables}
  (let ((win (create-instance NIL inter:interactor-window
		(:left left) (:top top)
		(:width 100) (:height 100)))
	(agg (create-instance NIL opal:aggregate))
	(message (create-instance NIL opal:text
		    (:left 20) (:top 40)
		    (:string string))))
    @emph{; Manipulate the objects according to their local names}
    (s-value win :aggregate agg)
    (opal:add-component agg message)
    (opal:update win)
    win))  @emph{; Return the internal name of the new window}

(setf Win-List (list (Make-Win 100 100 "Hello")
		     (Make-Win 190 120 "Window 2")
		     (Make-Win 70 190 "Third Win")))
@end example

Each time @code{Make-Win} is called, a window is created, an aggregate
is attached, and a text object is added to the aggregate. We kept a
list of the internal names of the windows in @code{Win-List} because we
will want to destroy them later. Each of the windows in the list can
be manipulated as usual (using @code{s-value}, etc.) by referring to
their generated names.

@float Figure, fig:ex1
@center @image{unnamed-windows, 5.5in}
@caption{Three windows created with the function @code{Make-Win}.}
@anchor{unnamed-windows}
@end float

To clean up the windows generated from @code{Make-Win}, you could use
@code{dolist} to destroy the whole list, or manually destroy the windows
individually while referring to their generated names.



@section Hints and Caveats
@node Hints and Caveats

There is a small manual devoted to optimizations that can be added to your
Garnet programs that make them smaller and faster. This section lists a
few suggestions that are sometimes @b{required} by Garnet programs, in
addition to helping your programs be more efficient.


@section Dimensions of Aggregates
@node Dimensions of Aggregates

@subsection Supply Your Own Formulas to Improve Performance
@node Supply Your Own Formulas to Improve Performance

Although it is usually not necessary to specify the @code{:width} and
@code{:height} of an aggregate, the programmer can almost always define
formulas that will be more efficient than the default formulas for
computing the bounding box. The default formulas look at all the
components of the aggregate and compute the appropriate bounding box, but
they are completely generic and make no assumptions about the arrangement
of the components. Since you will know where the components will
appear on the screen, you can usually supply simple formulas that
depend on only a few of the components.

For example, if you created an aggregadget out of nested rectangles,
where there was one outer rectangle and several others inside of it,
then you would want to define dimension formulas for the aggregate that
depend only on the outer rectangle and ignore the inner ones.
Otherwise, the default formulas would check every rectangle before
deciding on the correct width and height of the aggregate.


@subsection Ignore Feedback Objects in Dimension Formulas
@node Ignore Feedback Objects in Dimension Formulas

A good reason to define your own formulas for the @code{:width} and
@code{:height} slots of aggregates is that you usually don't want the
feedback object to be considered in the bounding box calculation.


@subsection Include All Components in the Aggregate's Bounding Box
@node Include All Components in the Aggregate's Bounding Box

Components of aggregates should always be inside the bounding boxes
of the aggregates. That is, you should not make the @code{:left} of an 
aggregate be 40, and then the left of a component be
(- 40 offset). This will put the component outside of the bounding
box of the aggregate (too far to the left), and Garnet will not be
able to update the aggregate properly.

The solution here is to make the left of the aggregate be the same as
the leftmost component, and then make the component
inherit that left. Of course, if you have several components which all
have different lefts, then you will have to add offsets to the lefts
of the other components.


@section Dimensions of Windows
@node Dimensions of Windows

Don't make the size of windows depend on the size of the objects
inside. This will lead to frequent refreshing of the entire window,
causing very poor performance.


@section Formulas
@node Formulas


@subsection The Difference Between formula and o-formula
@node The Difference Between formula and o-formula
@anchor{formula-difference}

The difference between @code{formula} and @code{o-formula} is somewhat
confusing. The preferred form is @code{(o-formula (expression))}
because the expression will be compiled when the the file is compiled.
Then, at run-time, the expression for the constraint executes as
compiled code when the formula needs to be re-evaluated. (This works
by expanding the code in-line to create a lambda expression, for which
the compiler generates code.)  When the @code{(formula '(expression))}
form is used, the expression is interpreted at run-time, so the
constraint executes much slower. 

The disadvantage of @code{o-formula}, however, is that because it is a macro,
variable references do not create lexical closures. This means that
variables referenced inside an @code{o-formula} will not be expanded into their
actual value inside the expression. The variable name will instead remain
inside the expression, and if its value ever changes, the new value will
be reflected when the expression is reevaluated.

On the other hand, using the form @code{(formula `( ... ,*variable* ...))}
puts the value of @code{*variable*} permanently in the formula, and eliminates
the reference to @code{*variable*}. If all your object references use
@code{(gvl ...)} to get values out of slots of the object ("paths"
in aggregadgets), then this is not relevant, and you should use
@code{o-formula}.

As an example, let's start with a global variable and two formulas that use
the variable. One formula will be an @code{o-formula}, and one will be a plain
@code{formula}. Note: @code{lisp>} represents the prompt for the lisp listener.

@example
@b{lisp>} (setf *width* 100)
100 
@b{lisp>} (create-schema 'A
	 (:left 10)
         (:right1 (o-formula (+ (gvl :left) *width*)))
	 (:right2 (formula `(+ (gvl :left) ,*width*))))
Object A

#k<A>
@b{lisp>} (gv A :right1)
110 
@b{lisp>} (gv A :right2)
110 
@b{lisp>}
@end example

So in both cases the formula computed the sum of the left and the current
value of @code{*width*}. Now, what happens if we change @code{*width*}?  At first,
it seems that nothing happens. Just changing the value of the variable will
not cause the formulas to recompute -- only things that are @code{gv}'ed have
dependencies, and Garnet doesn't know that the variable's value has changed
yet.

@example
@b{lisp>} (setf *width* 22)
22 
@b{lisp>} (gv A :right1)
110 
@b{lisp>} (gv A :right2)
110 
@b{lisp>}
@end example

But now let's change the value of the @code{:left} slot, which will invalidate
both formulas and will cause them to recompute.

@example
@b{lisp>} (s-value A :left 33)
33 
@b{lisp>} (gv A :right1)
55 
@b{lisp>} (gv A :right2)
133 
@b{lisp>}
@end example

Now they recomputed, and the difference is obvious. In the @code{o-formula},
the @code{*width*} variable reference was still hanging around, and that
expression used the current value of @code{*width*}. A @code{ps} of the
@code{o-formula} shows it's still there:

@example
@b{lisp>} (ps (get-value A :right1))
{#k<F74>
  lambda:        (+ (gvl :left) *width*)
  cached value:  (55 . T)
  on schema #k<A>, slot :RIGHT1
  }

NIL 
@b{lisp>}
@end example

On the other hand, the plain formula got rid of the @code{*width*} variable when
the "," dereferenced it.

@example
@b{lisp>} (ps (get-value A :right2))
{#k<F73>
  lambda:        (+ (gvl :left) 100)
  cached value:  (133 . T)
  on schema #k<A>, slot :RIGHT2
  }

NIL 
@b{lisp>}
@end example

Notice the 100 replaced @code{*width*} in the definition of the formula.

One occasion where this distinction between @code{formula} and @code{o-formula}
comes up is the creation of objects while iterating over a list. The following
code correctly dereferences the variable @code{obj} when constructing
formulas.

@example
(dolist (obj objlist)
  (create-instance NIL opal:rectangle
     (:left (formula `(gv ,obj :left)))
  ))
@end example




@subsection Avoid Real Number Divide
@node Avoid Real Number Divide

In all graphical objects, the position and dimension slots @code{:left},
@code{:top}, @code{:width}, and @code{:height} all take integer values.
Therefore, the integer divide functions @code{round}, @code{floor}, and
@code{ceiling}, etc. should be used more frequently than @code{/} for
division.


@section Feedback Objects
@node Feedback Objects

If all of the components of an aggregate are selectable, then any
feedback object should be put in a separate aggregate so that the
feedback object itself is not selectable.


@section Debugging
@node Debugging

The Debugging Tools Reference Manual documents many functions that are
useful in answering the most common questions that users have when
developing Garnet code. The functions will help you find objects, explain
the values of particular slots, describe inheritance and aggregate
hierarchies, and inspect constraints and interactors. This section
describes the most commonly used functions for examining Garnet objects.


@section The Inspector
@node The Inspector

There is a powerful debugging tool called the @code{Inspector} which allows
you to examine and change slot values of your objects without typing into the
lisp listener. This tool can be invoked by hitting the HELP key while the
mouse is positioned above the object to be examined.

You can easily try this tool if you have any Garnet window with objects in it.
Sections @ref{prototypes}-@ref{inspector-sec} of this tutorial provide a
simple example window with step-by-step interaction with the Inspector.


@section PS
@node PS

@code{kr:PS @emph{object}}

The function @code{ps} (which stands for "print schema") is used to examine
individual schemas. When @code{ps} is called with a Garnet object, a list
of all the object's slots and values will be printed. By default, any slot
whose value is inherited from a prototype is not printed unless @code{gv}
has already been called on that slot.

The @code{ps} function resides in the KR package, and is fully documented
in the KR manual. There are several switches and global variables that
control the amount of information that @code{ps} prints.


@section Flash
@node Flash

@defun garnet-debug:flash object &optional n

The function @code{flash} helps you to visually locate @emph{object} in a
window by flashing the bounding box of @emph{object} from black to white
@emph{n} times. The @emph{object} must already be in a window in order for
it to flash. If @code{flash} is unable to flash the object, then the
function will try to give you some explanation of why the object will
not flash.

@end defun

@section Ident
@node Ident

@defun garnet-debug:ident

The function @code{ident} takes no parameters. After you call
@code{ident}, Garnet waits for the next input event in any Garnet
window, like clicking the mouse. If you click over an object, then the
name of the object will be printed along with some other information
about the object and the window.

Clearly, this function is useful if there are many objects in a window
and you forget the names of all of them. A more interesting application is
when there are unnamed objects in the window (that is, they were given
NIL for a name in their schema definition and now have only internal names)
and you want to analyze or manipulate an unnamed object. Then, @code{ident}
will return the internal name of the object clicked on, and that name can
be used in @code{gv} or @code{s-value} calls as usual.

@end defun

@section Trace-Inter
@node Trace-Inter
@anchor{trace-inter}

@example
inter:Trace-Inter &optional @emph{interactor}@value[function]
inter:Untrace-Inter@value[function]
@end example

The function @code{trace-inter} is often used to find out why an
interactor is not working 
as you expected. Interactor problems most often arise from improper
definitions of either the interactors or the objects they work on.
Using @code{trace-inter} can help to narrow the reasons for the unexpected
behavior.

Executing @code{untrace-inter} will turn off the tracing for interactors.

@chapter Opal: The Garnet Graphical Object System
@node Opal : The Garnet Graphical Object System


by Andrew Mickish, Brad A. Myers, David Kosbie, Richard McDaniel, Edward Pervin, Matthew Goldberg

@value{DATE}

@section Abstract
@node Abstract

This chapter is a refence for the graphical object system used by the
Garnet project, which is called Opal. ``Opal'' stands for the
@b{O}bject @b{P}rogramming @b{A}ggregate @b{L}ayer. Opal makes it very
simple to create and manipulate graphical objects. In particular, Opal
automatically handles object redrawing when properties of objects are
changed.



@section Introduction
@node Introduction

This document is the reference manual for the Opal graphical object
system. Opal, which stands for the @b{O}bject @b{P}rogramming
@b{A}ggregate @b{L}ayer, is being developed as part of the Garnet
project @cite(garnet). The goal of Opal is to make it easy to create
and edit graphical objects. To this end, Opal provides default values
for all of the properties of objects, so simple objects can be drawn
by setting only a few parameters. If an object is changed, Opal
automatically handles refreshing the screen and redrawing that object
and any other objects that may overlap it. The algorithm used to
handle the automatic update is documented in @cite{Vander Zanden
89}. Objects in Opal can be connected together using
@emph{constraints}, which are relations among objects that are
declared once and automatically maintained by the system. An example
of a constraint is that a line must stay attached to a
rectangle. Constraints are discussed in @ref{Garnet Tutorial} and
@ref{KR Manual}.

Opal is built on top of the @code{gem} module, which is the
@b{G}raphics and @b{E}vents @b{M}odule that refers to machine-specific
functions. @code{gem} provides an interface to both X Windows and the
Macintosh QuickDraw system, so applications implemented with Opal
objects and functions will run on either platform without
modification.

@cindex{Window Managers}
Opal is known to work in virtually any Common Lisp environment on many
different machines (@xref{Overview}). Opal will also work with any
window manager on top of X11, such as @code{uwm}, @code{twm},
@code{awm}, etc. Additionally, Opal provides support for color and
gray-scale displays.

Within the Garnet toolkit, Opal forms an intermediary layer. It uses
facilities provided by the KR object and constraint system @cite{Giuse
89}, and provides graphical objects that comprise the higher level
gadgets. To use Opal, the programmer should be familiar with the ideas
of objects and constraints presented in the @ref{On-line Tour Through
Garnet} and @ref{Garnet Tutorial}. Opal does not handle any input
from the keyboard or mouse. That is handled by the separate
@emph{Interactors} module. On top of Opal is also the
@emph{Aggregadgets} module which makes it significantly easier to
create groups of objects. A collection of pre-defined interaction
techniques, such as menus, scroll bars, buttons, and sliders, is
provided in the Garnet Gadget set which, of course, use @emph{Opal},
@emph{Interactors}, and @emph{Aggregadgets}.

The highest level of Garnet, built using the toolkit, contains the
graphical construction tools that allow significant parts of
application graphics to be created without programming. The most
sophisticated tool is @emph{Lapidary}. When @emph{Lapidary} is used,
the programmer should rarely need to write code that calls @emph{Opal}
or any other part of the toolkit.


@subsection Basic Concepts
@node Basic Concepts

The important concepts in Opal are @emph{windows}, @emph{objects}, and
@emph{aggregates}.

@emph{X11} and @emph{Macintosh QuickDraw} both allow you to create
windows on the screen. In @emph{X} they are called "@emph{drawables}",
and in @emph{QuickDraw} they are called "views". An @emph{Opal} window
is a schema that contains pointers to these machine-specific
structures. Like in @emph{X11} and @emph{QuickDraw}, Opal windows can
be nested inside other windows (to form ``sub-windows''). Windows
clip all graphics so they do not extend outside the window's borders.
Also, each window forms a new coordinate system with @math{(0,0)} in the
upper left corner. The coordinate system is one-to-one with the pixels
on the screen (each pixel is one unit of the coordinate
system). Garnet windows are discussed fully in section @ref{windows}.

The basics of object-oriented programming are beyond the scope of this
manual. The @emph{objects} in @emph{Opal} use the @emph{KR} object
system @cite{Giuse 89}, and therefore operate as a prototype-instance
model. This means that each object can serve as a prototype (like a
class) for any further instances; there is (almost) no distinction
between classes and instances. Each graphic primitive in @emph{Opal} is
implemented as an object. When the programmer wants to cause something
to be displayed in @emph{Opal}, it is necessary to create instances of these
graphical objects. Each instance remembers its properties so it can be
redrawn automatically if the window needs to be refreshed or if
objects change.

@cindex{components}
@cindex{parent}

An @emph{aggregate} is a special kind of Opal object that holds a
collection of other objects. Aggregates can hold any kind of graphic
object including other aggregates, but an object can only be in one
aggregate at a time. Therefore, aggregates form a pure hierarchy. The
objects that are in an aggregate are called @emph{components} of that
aggregate, and the aggregate is called the @emph{parent} of each of
the components. Each window has associated with it a top-level
aggregate. All objects that are displayed in the window must be
reachable by going through the components of this aggregate
(recursively for any number of levels, in case any of the components
are aggregates themselves).

The prototype inheritance hierarchy for all graphical objects in @emph{Opal} is
shown in Figure @ref{ObjectSchemata}.

@float Figure, fig:ex1
@center @image{opal-objects, 5.5in}
@caption{The objects in Opal and their slots. Each object also inherits slots
from its prototype (the object to its left). The default
values for the slots are shown. Those with values like @code{#k<F21>} have
formulas in them (@xref{Garnet Tutorial} and @ref{KR Manual}).}
@anchor{ObjectSchemata}
@end float


@subsection The Opal Package
@node The Opal Package
@cindex{Opal Package}
@cindex{use-package}
Once Garnet is loaded, all the graphical objects reside in the @code{opal}
package. We recommend that programmers explicitly reference names
from the @code{opal} package, for example: @code{opal:rectangle}, but you
can also get complete access to all exported symbols by doing a
@code{(use-package :opal)}. All of the symbols referenced in this
document are exported from @code{opal}, unless otherwise stated.


@subsection Simple Displays
@node Simple Displays

An important goal of Opal is to make it significantly easier to create
pictures, hiding most of the complexity of the X11 and QuickDraw
graphics models. Therefore, there are appropriate defaults for all
properties of objects (such as the color, line-thickness, etc.). These
only need to be set if the user desires to. All of the complexity of
the X11 and QuickDraw graphics packages is available to the Opal user,
but it is hidden so that you do not need to deal with it unless it is
necessary to your task.

To get the string "Hello world"
displayed on the screen (and refreshed automatically if the window is
covered and uncovered), you only need the following simple program:

@cindex{Hello World}
@example
(use-package :kr)

;;@i{Create a small window at the upper left corner of the screen}
(create-instance 'win inter:interactor-window
  (:left 10)(:top 10)
  (:width 200)(:height 50))

;;@i{create an aggregate for the window}
(s-value win :aggregate (create-instance 'agg opal:aggregate))

;;@i{create the string}
(create-instance 'hello opal:text
  (:left 10)(:top 20)
  (:string "Hello World"))

(opal:add-component agg hello) ;@i{add the string to the aggregate}

(opal:update win) ;@i{cause the window and string to be displayed}
@end example

Opal also strives to make it easy to change the picture. To change the
@emph{x} position of the rectangle only requires setting the value of the
@code{:left} slot;  Opal handles the refresh:


@example
(s-value hello :left 50)  ;@i{change the position}

(opal:update win) ;@i{cause the change to be visible}
@end example

Note that the programmer never calls @emph{``draw''} or
@emph{``erase''} methods on objects. This is a significant difference
from other graphical object systems. Opal causes the objects to be
drawn and erased at the appropriate times automatically.

@ref{specificobs,Specific Graphical Objects, Specific Graphical
Objects} and @ref{fig:ex3} present all the kinds of objects
available in Opal.


@subsection Object Visibility
@node Object Visibility

@cindex{visibility}

Objects are visible if and only if their @code{:visible} slot is
non-@code{nil} and they are a component of a visible aggregate that
(recursively) is attached to a window. (Aggregates are discussed in
Chapter @ref{aggregates}.)  Therefore, to make a single object
@b{in}visible, its @code{:visible} slot can be set to @code{nil}. To make it
visible again, it is only necessary to set the @code{:visible} slot to
@code{t}. Alternatively, the object can be removed from its aggregate to
make it invisible.

Of course an object with a non-@code{nil} @code{:visible} slot in a visible
aggregate hierarchy might be completely obscured behind another object
so it cannot be seen.

Every object has a default formula in its @code{:visible} slot that
depends on the visibility of the its @emph{parent} (the @emph{parent}
is the aggregate that it is in). Therefore, to make an entire
aggregate and all its components invisible, it is only necessary to
set the @code{:visible} slot of the aggregate. All the components will
become invisible (in this case, it is important that the components
have the default formula in their @code{:visible} slot).

If you provide a specific value or formula for the @code{:visible} slot to
override the default formula, it is important that this value be @code{nil}
if the object's parent aggregate is not visible. Otherwise, routines such as
@code{point-in-gob} may report that a point is inside the object, even though
the object is invisible.

For example, if you want the @code{:visible} slot of an object to depend
on its own @code{:selected} slot, you should additionally constrain it
to depend on the visibility of its parent:

@example
(s-value obj :visible (o-formula (if (gvl :parent :visible)
                                     (gvl :selected))))
@end example


@subsection View Objects
@node View Objects
@cindex{view-object}
At the top of the class hierarchy is the class @code{opal:view-object}.

@cindex{left}
@cindex{top}
@cindex{width}
@cindex{height}
@cindex{visible}
@example
(create-instance 'opal:view-object nil
  (:left 0)
  (:top 0)
  (:width 0)
  (:height 0)
  (:visible (o-formula ...))
  ...)
@end example

Each view object has a bounding box as defined by the left, top corner and
a width and height. The @code{:left}, @code{:top}, @code{:width}, and @code{:height}
slots describe the bounding box for the object. Coordinates are given as
non-negative fixnums, so any formulas must apply @code{floor} or @code{round}
to all values that could generate floating point or ratio values. In
particular, be
careful using "@code{/}" for division, because that generates ratios or floats
which are not legal values.

With the exception of windows, coordinates of objects are relative to the
window in which the object appears. (If the window in which an object
appears has borders, then the coordinates of the object are relative to the
@emph{inner} edges of the borders.)  Windows coordinates are given in
the coordinate system of the parent of the window, or in the case of top level
windows, given in screen coordinates.

@subsection Read-Only Slots
@node Read-Only Slots
@cindex{parent (slot)}
@cindex{window (slot)}

There are many slots in graphical objects, windows, and interactors that are
set internally by Garnet and should never be set by users. For example,
the @code{:parent}, @code{:window}, and @code{:components} slots of graphical objects
are set automatically whenever the objects are added to an aggregate using
@code{opal:add-component}, and should not be set manually.

All public slots that are intended to be
read-only are labeled as such in their object's definitions. Internal slots
of an object (used for data or calculations) that are not documented should
be considered read-only. Setting these
slots "temporarily" or during initialization can lead to insidious errors
at run-time.


@subsection Different Common Lisps
@node Different Common Lisps
Running Opal under different implementations of Common Lisp should be
almost the same. The differences in the locations of files, such the
Opal binary files, and the cursors, bitmaps and fonts, are all handled in
the top level @code{garnet-loader} file, which defines variables for the
locations of the files. 

@cindex{Allegro Common Lisp}
@cindex{Lucid Common Lisp}
@cindex{CMU Common Lisp}
@cindex{lispworks}
@cindex{Main-Event-Loop}
@cindex{Update}
An important difference among Lisp interpreters is the @code{main-event-loop}.
In CMU Common Lisp, there is a process running in the background that
allows interactors to always run with automatic refresh of Garnet
windows.@footnote{Automatic refresh while an interactor is running is
different from updating a window after you manually make a change with
@code{s-value}. Unless changes are made by the interactors, you will
still have to call @code{opal:update} to see the graphics change.}
In Allegro, Lucid, and LispWorks, Garnet creates its own @code{main-event-loop}
process in the background that does the same thing. Some Lisp
interpreters have problems running this process in the background,
and you may have to call @code{inter:main-event-loop} by hand in order
to run the interactors. Consult the Interactors manual for directions
on how to control the @code{main-event-loop} process.


@section Slots of All Graphical Objects
@node Slots of All Graphical Objects

This section discusses properties shared by all graphical objects.

@example

@cindex{graphical-object}

(create-instance 'opal:Graphical-Object opal:view-object
  (:left 0)   (:top 0)
  (:width 20) (:height 20)
  (:line-style opal:default-line-style)
  (:filling-style NIL)
  (:draw-function :copy)
  (:select-outline-only NIL)
  (:hit-threshold 0)
  ...)
@end example

@subsection Left, top, width and height
@node Left, top, width and height
Graphical objects are objects with graphical properties that can be
displayed in Garnet windows. They inherit the @code{:left}, @code{:top}, @code{:width} and
@code{:height} slots from @code{view-objects}, of course.

@subsection Line style and filling style
@node Line style and filling style
@cindex{line-style}
@cindex{filling-style}
The @code{:line-style} and @code{:filling-style} slots hold instances of the
@code{opal:line-style} prototype and the @code{opal:filling-style} prototype,
respectively.
These objects parameterize the drawing of graphical objects. Graphical objects
with a @code{:line-style} of @c[nil] will not have an outline. Those with a
@code{:filling-style} of @c[nil] will have no filling. Otherwise, the
@code{:line-style} and @code{:filling-style} control various parameters of the
outline and filling when the object is drawn.
Appropriate values for the @code{:line-style} and @code{:filling-style} slots are
described below in Chapter @ref{Graphic Qualities}.

@subsection Drawing function
@node Drawing function
@cindex{draw-function}
The value of the @code{:draw-function} slot determines how the object
being drawn will affect the graphics already in the window. For example,
even though a line may be "black", it could cause objects that it covers
to be "whited-out" if it is drawn with a @code{:clear} draw-function.
A list of all allowed values for the
@code{:draw-function} slot is included in Figure @ref{fig:ex1b}.

Every time an object is displayed in a window, its drawn bits interact
with the bits of the pixels already in the window. The way the
object's bits (the source bits) interact with the window's current
bits (the destination bits) depends on the draw function.  The
@code{:draw-function} is the bitwise function to use in calculating
the resulting bits. Opal insures that black pixels pretend to be ``1''
and white pixels pretend to be ``0'' for the purposes of the drawing
functions (independent of the values of how the actual display works).
Therefore, when using the colors black and white, you can rely on
@code{:or} to always add to the picture and make it more black, and
@code{:and} to take things away from the picture and make it more
white.

Results of draw-functions on colors other than black and white tend to
be random. This is because X11 and Mac QuickDraw initialize the
colormap with colors stored in an arbitrary order, and a color's index
is unlikely to be the same between Garnet sessions. So performing a
logical operation on two particular colors will yield a different
resulting color in different Garnet sessions.

One of the most useful draw functions is @code{:xor}, which occurs frequently
in feedback objects. If a black rectangle is XOR'ed over another object,
the region under the rectangle will appear in inverse video. This technique
is used in the @code{gg:text-button}, and many other standard Garnet gadgets.

A fundamental limitation of the PostScript language prevents it from
rendering draw functions properly. If @code{opal:make-ps-file} (see Chapter
@ref{printing}) is used to generate a PostScript file from a Garnet window,
the draw functions used in the window will be ignored in the printed image.
Usually the graphics in the window can be reimplemented without using
draw-functions to get the same effect, so that the picture generated by
@code{opal:make-ps-file} matches the window exactly.

@anchor{draw-fn-fig}
@cindex{clear}
@cindex{copy}
@cindex{no-op}
@cindex{copy-inverted}
@cindex{invert}
@cindex{or}
@cindex{and}
@cindex{xor}
@cindex{equiv}
@cindex{nand}
@cindex{nor}
@cindex{and-inverted}
@cindex{and-reverse}
@cindex{or-inverted}
@cindex{or-reverse}


@float Figure, fig:ex1b
@multitable @columnfractions .30 .70
@headitem draw-function @tab function

@item @code{:clear} @tab 0

@item @code{:set} @tab 1

@item @code{:copy} @tab src

@item @code{:no-op} @tab dst

@item @code{:copy-inverted} @tab (not src)

@item @code{:invert} @tab (not dst)

@item @code{:or} @tab src or dst

@item @code{:and} @tab src and dst

@item @code{:xor} @tab src xor dst

@item @code{:equiv} @tab (not src) xor dst

@item @code{:nand} @tab (not src) or (not dst)

@item @code{:nor} @tab (not src) and (not dst)

@item @code{:and-inverted} @tab (not src) and dst

@item @code{:and-reverse} @tab src and (not dst)

@item @code{:or-inverted} @tab (not src) or dst

@item @code{:or-reverse} @tab src or (not dst)

@end multitable

@caption{Allowed values for the @code{:draw-function} slot and their logical.}
@end float

@subsection @code{select-outline-only}, @code{hit-threshold}, and @code{pretend-to-be-leaf}
@node @code{select-outline-only}, @code{hit-threshold}, and @code{pretend-to-be-leaf}

@cindex{select-outline-only}
@cindex{hit-threshold}
@cindex{pretend-to-be-leaf}
The @code{:select-outline-only}, @code{:hit-threshold}, @code{:pretend-to-be-leaf},
and @code{:visible} slots are used by functions which search for objects
given a rectangular region or an @math{(x,y)} coordinate (see sections
@ref{rect-regions} and @ref{querying-children}). If the
@code{:select-outline-only} slot is non-@c{NIL} then @code{point-in-gob} will
only report hits only on or near the outline of the object.
Otherwise, the object will be sensitive over the entire region (inside
and on the outline). The @code{:select-outline-only} slot defaults to @code{nil}.
@sp 1

The @code{:hit-threshold} slot controls the sensitivity of the internal Opal
@code{point-in-gob} methods that decide whether an event (like a mouse click)
occurred "inside" an object. If the @code{:hit-threshold} is 3, for example,
then an event 3 pixels away from the object will still be interpreted as being
"inside" the object. When @code{:select-outline-only} is T, then any event
directly on the outline of the object, or within 3 pixels of the outline,
will be interpreted as a hit on the object. The default value of
@code{:hit-threshold} is 0.

@b{Note:} it is often necessary to set the @code{:hit-threshold} slot
of all aggregates @emph{above} a target object; if an event occurs
"outside" of an aggregate, then the @code{point-in-gob} methods will
not check the components of that aggregate. The function
@code{opal:set-aggregate-hit-threshold} (see section @ref{agg-class})
can simplify this procedure.

When an aggregate's @code{:pretend-to-be-leaf} slot contains the value
@c(t), then the functions @code{point-to-component} and
@code{leaf-objects-in-rectangle} will treat that aggregate as a leaf
object (even though the aggregate has components). This might be
useful in searching for a button aggregate in an aggrelist of buttons.



@section Methods on All @code{view-objects}
@node Methods on All @code{view-objects}

@anchor{GobMethods}
There are a number of methods defined on all subclasses of
@code{opal:view-object}. This section describes these methods and other
accessors defined for all graphical objects.

@subsection Standard Functions
@node Standard Functions

@anchor{stdfuncs}
The various slots in objects, like @code{:left, :top, :width, :height,
:visible}, etc. can be set and accessed using the standard
@code{s-value} and @code{gv} functions and macros. Some additional
functions are provided for convenience in accessing and setting the size
and position slots. Some slots of objects should not be set (although they can
be accessed). This includes the @code{:left, :top, :width,} and @code{:height}
of lines and polylines (since they are computed from the end points), and
the components of aggregates (use the @code{add-component} and
@code{remove-component} functions).

@cindex{point-in-gob}

@defmethod {view-object} opal:point-in-gob graphical-object x y

This routine determines whether the point @math{(@var{x},@var{y})} is
inside the graphical object ("gob" stands for graphical object). This
uses an object-specific method, and is dependent on the setting of the
@code{:select-outline-only} and @code{:hit-threshold} slots in the
object as described above.

The @code{:point-in-gob} methods for @code{opal:polyline} and
@code{opal:arrowhead} actually check whether the point is inside the
polygon, rather than just inside the polygon's bounding
box. Additionally, the @code{:hit-full-interior-p} slot of a polygon
controls which algorithm is used to determine if a point is inside it
(see section @ref{polyline}).  If an object's @code{:visible} slot is
@code{nil}, then @code{point-in-gob} will always return @code{nil} for
that object.

@end defmethod

@defmethod opal:destroy graphical-object &optional erase

This causes the object to be removed from an aggregate (if it is in
one), and the storage for the object is deallocated.  You can
@code{destroy} any kind of object, including windows. If you destroy a
window, all objects inside of it are automatically
destroyed. Similarly, if you destroy an aggregate, all objects in it
are destroyed (recursively).  When you destroy an object, it is
automatically removed from any aggregates it might be in and erased
from the screen. If destroying the object causes you to go into the
debugger (usually due to illegal values in some slots), you might try
passing in the @var{erase} parameter as @code{nil} to cause Opal to
not erase the object from the window. The default for @var{erase} is
@code{t}.

Often, it is not necessary to destroy individual objects because they
are destroyed automatically when the window they are in is destroyed.

@end defmethod

@defmethod opal:rotate graphical-object angle &optional center-x center-y

The @code{rotate} method rotates @var{graphical-object} around
@math(@var{center-x}, @var{center-y})] by @var{angle} radians. It does
this by changing the values of the controlling points (using
@code{s-value}) for the object (e.g., the values for @code{:x1},
@code{:y1}, @code{:x2}, and @code{:y2} for lines). Therefore, it is a
bad idea to call @code{rotate} when there are formulas in these slots.
If @var{center-x} or @var{center-y} are not specified, then the
geometric center of the object (as calculated by using the center of
its bounding box) is used. Certain objects can't be rotated, namely
Ovals, Arcs, Roundtangles, and Text. A rectangle that is rotated
becomes a polygon and remains one even if it is rotated back into its
original position.
@end defmethod

@subsection Extended Accessor Functions
@node Extended Accessor Functions
@anchor{Extended-accessors}

The following macros, functions and @code{setf} methods are defined to
make it easier to access the slots of graphical objects.

When set, the first set of functions below only change the position of
the graphical object; the width and height remain the same. The
following are both accessors and valid place arguments for
@code{setf}. These use @code{s-value} and @code{g-value} so they
should not be used inside of formulas, use the @code{gv-}@var{xxx}
forms below instead inside of formulas.



@defun opal:bottom graphical-object
@defunx opal:right graphical-object
@defunx opal:center-x graphical-object
@defunx opal:center-y graphical-object

To use one of these in a @code{setf}, the form is
@example
(setf (opal:bottom obj) new-value)
@end example

In contrast to the above accessors, the four below when set change the
size of the object. For example, changing the top-side of an object
changes the top and height of the object; the bottom does not change.

@end defun

@defmac opal:top-side graphical-object value
@defmacx opal:left-side graphical-object value
@defmacx opal:bottom-side graphical-object value
@defmacx opal:right-side  graphical-object value

Opal also provides the following accessor functions which set up
dependencies and should only be used inside of formulas. For more
information on using formulas, see the example section and the KR document.
These should not be used outside of formulas.

@end defmac

@defun opal:gv-bottom graphical-object
@defunx opal:gv-right graphical-object
@defunx opal:gv-center-x graphical-object
@defunx opal:gv-center-y graphical-object


@end defun

The following functions should be used in the @code{:left} and
@code{:top} slots of objects, respectively. The first returns the
value for @code{:left} such that @code{(gv-center-x :self)} equals
@code{(gv-center-x object)}.

@defun opal:gv-center-x-is-center-of object
@defunx opal:gv-center-y-is-center-of object

In more concrete terms, if you had two objects OBJ1 and OBJ2, and
you wanted to constrain the @code{:left} of OBJ1 so that the centers of
OBJ1 and OBJ2 were the same, you would say:


@example
(s-value obj1 :left (o-formula (opal:gv-center-x-is-center-of obj2)))
@end example

@end defun

The next group of functions are for accessing multiple slots
simultaneously. These are not @code{setf}'able.


@defun opal:center graphical-object @
  (declare (values center-x center-y))

@defunx opal:set-center graphical-object center-x center-y

@defunx opal:bounding-box graphical-object
  (declare (values left top width height))

@defunx opal:set-bounding-box graphical-object left top width height

@defunx opal:set-position graphical-object left top

@defunx opal:set-size graphical-object width height

@end defun

@section Graphic Qualities
@node Graphic Qualities

@anchor{GraphicQualities}

@cindex{Graphic-quality}

Objects that are instances of class @code{opal:graphic-quality} are
used to specify a number of related drawing qualities at one time. The
@code{:line-style} and @code{:filling-style} slots present in all
graphical objects hold instances of @code{opal:line-style} and
@code{opal:filling-style} objects. The @code{opal:line-style} object
controls many parameters about how a graphical object's outline is
displayed. Likewise, the @code{opal:filling-style} object controls how
the filling of objects are displayed. @ref{fig:ex2}
shows the graphic qualities provided by Opal.

@float Figure, fig:ex2
@center @image{gquality, 5.5in}
@caption{The graphic qualities that can be applied to objects.}
@end float

The properties controlled by the @code{opal:line-style},
@code{opal:filling-style}, and @code{opal:font} objects are similar to
PostScript's graphics state (described in section 4.3 in the
PostScript Language Reference Manual) or the XLIB graphics context
(described in the X Window System Protocol Manual). The Opal design is
simpler since there are appropriate defaults for all values and you
only have to set the ones you are interested in.  The
@code{:line-style} slot in graphical objects holds an object that
contains all relevant information to parameterize the drawing of lines
and outlines. Similarly, the @code{:filling-style} controls the
insides of objects. The @code{:font} slot appears only in text and
related objects, and controls the font used in drawing the string.

@b{Note}: Although the properties of these graphic qualities can be changed
after they are created, for example to make a font change to be italic,
Garnet will not notice the change because the font object itself is
still the same (i.e., the value of the @code{:font} slot has not changed).
Therefore, line-styles, filling-styles and fonts should be considered
read-only after they are created. You can make as many as you 
want and put them in objects, but if you want to change the property of an
object, insert a @emph{new} line-style, filling-style, or font object rather
than changing the slots of the style or font itself. If a set of objects
should share a changeable graphics quality, then put a formula into each
object that calculates which graphic quality to use, so they will all change
references together, rather than sharing a pointer to a single graphic
quality object that is changed.

@cindex{color}

@subsection Color
@node Color

A graphical quality called @code{opal:color} exists which is defined
as:

@cindex{red}
@cindex{green}
@cindex{blue}
@example
(create-instance 'opal:color opal:graphic-quality
   (:constant '(:color-p))
   @emph{;; Set during initialization according to the display - t if color, nil otherwise}
   (:color-p ...)  
   (:red 1.0)
   (:green 1.0)
   (:blue 1.0)
   (:color-name nil))
@end example

The following colors are exported from Opal. They are instances of
@code{opal:color} with the appropriate values for their @code{:red},
@code{:green}, and @code{:blue} slots as shown:

@cindex{white}
@cindex{black}
@cindex{yellow}
@cindex{purple}
@cindex{cyan}
@cindex{orange}
@cindex{motif-gray}
@cindex{motif-blue}
@cindex{motif-orange}
@cindex{motif-green}

@example
opal:red   --- (:red 1.0)  (:green 0.0)  (:blue 0.0)
opal:green --- (:red 0.0)  (:green 1.0)  (:blue 0.0)
opal:blue  --- (:red 0.0)  (:green 0.0)  (:blue 1.0)
opal:yellow --- (:red 1.0)  (:green 1.0)  (:blue 0.0)
opal:purple --- (:red 1.0)  (:green 0.0)  (:blue 1.0)
opal:cyan  --- (:red 0.0)  (:green 1.0)  (:blue 1.0)
opal:orange --- (:red 0.75) (:green 0.25) (:blue 0.0)
opal:white --- (:red 1.0)  (:green 1.0)  (:blue 1.0)
opal:black --- (:red 0.0)  (:green 0.0)  (:blue 0.0)
@end example

The following objects are also instances of @code{opal:color}, with
RGB values chosen to correspond to standard Motif colors:

@vtable @code

@item opal:motif-gray

@item opal:motif-blue

@item opal:motif-green

@item opal:motif-orange

@item opal:motif-light-gray

@item opal:motif-light-blue

@item opal:motif-light-green

@item opal:motif-light-orange

@end vtable


Users can create any color they want by creating an object of type
@code{opal:color}, and setting the @code{:red}, @code{:green} and
@code{:blue} slots to be any real number between 0.0 and 1.0.

@cindex{color-name}

An @code{opal:color} can also be created using the @code{:color-name}
slot instead of the @code{:red, :green,} and @code{:blue} slots. The
@code{:color-name} slot takes a string such as @emph{"pink"} or atom
such as @emph{'pink}. These names are looked up by the Xserver, and
the appropriate color will be returned.  Usually the list of allowed
color names is stored in the file @code{/usr/misc/lib/rgb.txt} or
@code{/usr/misc/.X11/lib/rgb.txt} or @code{/usr/lib/X11/rgb.txt}.
However, if the Xserver does not find the color, an error will be
raised. There is apparently no way to ask X whether it understands a
color name. Thus, code that uses the @code{:color-name} slot may not
be portable across machines. Note that the @code{:red, :green,} and
@code{:blue} slots of the color are set automatically in color objects
defined with names.

For example:
@example
(create-instance 'fun-color opal:color (:color-name "papaya whip"))
@end example

@cindex{color-p}
The @code{:color-p} slot of @code{opal:color} is automatically set to @code{t} or
@code{nil} depending on whether or not your screen is color or
black-and-white (it is also @code{t} if the screen is gray-scale).
This should not be set by hand. The Motif widget set contains formulas
that change their display mode based on the value of @code{:color-p}.

@cindex{line-style}

@subsection @code{line-style} Class
@node @code{line-style} Class

@cindex{line-style}

@example
(create-instance 'opal:line-style opal:graphic-quality
  (:maybe-constant '(:line-thickness :cap-style :join-style :line-style :dash-pattern
		     :foreground-color :background-color :stipple))
  (:line-thickness 0)
  (:cap-style :butt)
  (:join-style :miter)
  (:line-style :solid)
  (:foreground-color opal:black)
  (:background-color opal:white)
  (:dash-pattern nil)
  (:stipple nil))

(create-instance 'opal:default-line-style opal:line-style
   (:constant t))
@end example

Before you read the sordid details below about what all these slots
mean, be aware that most applications will just use the default line
styles provided.

The following line-styles (except @code{opal:no-line}) are all instances of
@code{opal:line-style}, with particular values for their @code{:line-thickness},
@code{:line-style}, or @code{:dash-pattern} slots. Except as noted, they are
identical to @code{opal:default-line-style}. All of them are black.

@cindex{no-line}
@cindex{default-line-style}
@cindex{thin-line}
@cindex{line-0}
@cindex{line-1}
@cindex{line-2}
@cindex{line-4}
@cindex{line-8}
@cindex{dotted-line}
@cindex{dashed-line}

@vtable @code

@item @code{opal:No-Line}
@code(nil)

@item @code{opal:thin-line}
same as @code{opal:default-line-style}

@item @code{opal:line-0}
same as @code{opal:default-line-style}

@item @code{opal:line-1}
@code{:line-thickness} = 1

@item @code{opal:line-2}
@code{:line-thickness} = 2

@item @code{opal:line-4}
@code{:line-thickness} = 4

@item @code{opal:line-8}
@code{:line-thickness} = 8

@item @code{opal:dotted-line}
@code{:line-style} = @code{:dash}, and @code{:dash-pattern = '(1 1)}

@item @code{opal:dashed-line}
@code{:line-style} = @code{:dash}, and @code{:dash-pattern = '(4 4)}
@end vtable

The following line-styles are all identical to @code{opal:default-line-style},
except that their @code{:foreground-color} slot is set with the appropriate
instance of @code{opal:color}. For example, the @code{:foreground-color} slot
of @code{opal:red-line} is set to @code{opal:red}.

@vtable @code
@item opal:red-line

@item opal:green-line

@item opal:blue-line

@item opal:yellow-line

@item opal:purple-line

@item opal:cyan-line

@item opal:orange-line

@item opal:white-line
@end vtable

For each of the predefined line-styles above, you may not customize
any of the normal parameters described below. These line-styles have
been created with their @code{:constant} slot set to @code{t} for
efficiency, which prohibits the overriding of the default values.
You may use these line-styles as values of any @code{:line-style} slot,
but you may not create customized instances of them. Instead, to create
a thick red line-style, for example, you should create your own
instance of @code{opal:line-style} with appropriate values for
@code{:line-thickness}, @code{:foreground-color}, etc. See the examples at
the end of this section.


@cindex{line-thickness}
The @code{:line-thickness} slot holds the integer line thickness in pixels.
There may be a subtle difference between lines with thickness zero and
lines with thickness one. Zero thickness lines are free to use a device
dependent line drawing algorithm, and therefore may be less aesthetically
pleasing. They are also probably drawn much more efficiently. Lines with
thickness one are drawn using the same algorithm with which all the thick lines
are drawn. For this reason, a thickness zero line parallel to a thick line
may not be as aesthetically pleasing as a line with thickness one.
@sp 1

For objects of the types @code{opal:rectangle}, @code{opal:roundtangle},
@code{opal:circle} and @code{opal:oval}, increasing the @code{:line-thickness} of
the @code{:line-style} will not increase the @code{:width} or @code{:height} of
the object; the object will stay the same size, but the solid black
boundary of the object will extend @emph{inwards} to occupy more of the
object. On the other hand, increasing the @code{:line-thickness} of the
@code{:line-style} of objects of the types @code{opal:line},
@code{opal:polyline} and @code{opal:arrowhead} will increase the objects'
@code{:width} and @code{:height}; for these objects the thickness will extend
@emph{outward} on @emph{both sides} of the line or arc.


@cindex{cap-style}

The @code{:cap-style} slot (which is ignored by the Mac) describes how the
endpoints of line segments
are drawn: 
@cindex{butt}
@cindex{not-last}
@cindex{round}
@cindex{projecting}

@multitable @columnfractions .25 .75
@headitem Line @code{:capstyle} @tab Description

@item @code{:butt} @tab
Square at the endpoint (perpendicular to the slope of the line)
with no projection beyond. 

@item @code{:not-last} @tab
Equivalent to @code{:butt}, except that for
@code{:line-thickness} 0 or 1 the final endpoint is not drawn. 

@item @code{:round} @tab
A circular arc with the diameter equal to the @code{:line-thickness}
centered on the endpoint. 

@item @code{:projecting} @tab
Square at the end, but the path continues beyond the
endpoint for a distance equal to half of the @code{:line-thickness.}

@end multitable

@cindex{join-style}

The @code{:join-style} slot (which is ignored by the Mac) describes
how corners (where multiple lines come together) are drawn for thick
lines as part of poly-line, polygon, or rectangle kinds of
objects. This does not affect individual lines (instances of
@code{opal:line}) that are part of an aggregate, even if they happen
to have the same endpoints.

@cindex{miter}
@cindex{round}
@cindex{bevel}

@vtable @code
@b{Line} @code{:join-style}
@b{Result}
	
@item @code{:miter@ @ @ @ @ @ }
The outer edges of the two lines extend
to meet at an angle. 

@item @code{:round}
A circular arc with a diameter equal to the @code{:line-thickness} is
drawn centered on the join point.

@item @code{:bevel}
@itemx @code{:butt}
endpoint styles, with the triangular notch filled.

@end vtable

@cindex{foreground-color}
@cindex{background-color}
The @code{:foreground-color} slot contains an object of type
@code{opal:color} which specifies the color in which the line will appear
on a color screen. The default value is @code{opal:black}.

The @code{:background-color} slot contains an object of type
@code{opal:color} which specifies the color of the "off" dashes of
double-dash lines will appear on a color screen (see below).
The default value is @code{opal:white}. It also specifies the color
of the bounding box of a text object whose @code{:fill-background-p}
slot is set to @code{t}.

@cindex{line-style (slot)}
@cindex{double-dash}
The contents of the @code{:line-style} slot declare whether the line is solid
or dashed. Valid values are @code{:solid}, @code{:dash} or @code{:double-dash.} With
@code{:dash} only the on dashes are drawn, and nothing is drawn in the off
dashes. With @code{:double-dash}, both on and off dashes are drawn; the
on dashes are drawn with the foreground color (usually black) and the
off dashes are drawn with the background color (usually white).
@sp 1
@cindex{dash-pattern}
The @code{:dash-pattern} slot holds an (optionally empty) list of numbers
corresponding to the pattern used when drawing dashes. Each pair of
elements in the list refers to an on and an off dash. The numbers are
pixel lengths for each dash. Thus a @code{:dash-pattern} of @w[(1 1 1 1 3 1)] is
a typical dot-dot-dash line. A list with an odd number of elements is
equivalent to the list being appended to itself. Thus, the dash pattern
@w[(3 2 1)] is equivalent to @w[(3 2 1 3 2 1)].
@sp 1

Since Mac QuickDraw does not support drawing real dashed lines, Garnet
simulates dashed lines on the Mac by drawing lines with a stippled pattern.
There is only one stipple pattern available for this simulation, so lines
whose @code{:line-style} is @code{:dash} or @code{:double-dash} have the same
gray stipple. The @code{:dash-pattern} slot is ignored on the Mac.
You can supply your own stipple for this simulation in the @code{:stipple}
slot of the @code{line-style} object (see below).

@cindex{stipple}
The @code{:stipple} slot holds either @code{nil} or a @code{opal:bitmap}
object with which the line is to be stippled. The
@code{:foreground-color} of the line-style will be used for the "dark"
pixels in the stipple pattern, and the @code{:background-color} will be
used for the "light" pixels.

@sp 1
Some examples:
@example
; black line of thickness 2 pixels
opal:line-2

; black line of thickness 30 pixels
(create-instance 'THICKLINE opal:line-style (:line-thickness 30))

; gray line of thickness 5 pixels
(create-instance 'GRAYLINE opal:line-style
  (:line-thickness 5)
  (:stipple (create-instance NIL opal:bitmap
              (:image (opal:halftone-image 50))))) ; 50% gray

; dot-dot-dash line, thickness 1
(create-instance 'DOTDOTDASHLINE opal:line-style
  (:line-style :dash)
  (:dash-pattern '(1 1 1 1 3 1)))
@end example

@subsection Filling-Styles
@node Filling-Styles

@example
@cindex{filling-style}
(create-instance 'opal:Filling-Style opal:graphic-quality
  (:foreground-color opal:black)
  (:background-color opal:white)
  (:fill-style :solid)    @emph{;; Transparent or opaque. See section @ref{other-stipple-slots}}.
  (:fill-rule :even-odd)  @emph{;; For self-intersecting polygons. See section @ref{other-stipple-slots}}.
  (:stipple NIL))         @emph{;; The pattern. See section @ref{custom-stipple}}.

(create-instance 'opal:Default-Filling-Style opal:filling-style)
@end example

Before you read all the sordid details below about what all these slots
mean, be aware that most applications will just use the default filling styles
provided. There are two basic types of filling-styles: those that rely on
stipple patterns to control their shades of gray, and those that are solid
colors.

@sp 1
@b{Stippled Filling-Styles}

Stippled filling-styles rely on their patterns to control their color shades.
The @code{:stipple} slot controls the mixing of the @code{:foreground-color} and
@code{:background-color} colors, which default to @code{opal:black} and
@code{opal:white}, respectively. Thus, the default stippled filling-styles
are shades of gray, but other colors may be used as well.
Here is a list of pre-defined stippled filling-styles:

@cindex{default-filling-style}
@cindex{no-fill}
@cindex{black-fill}
@cindex{white-fill}
@cindex{gray-fill}
@cindex{light-gray-fill}
@cindex{dark-gray-fill}


@vtable @code

@item @code{opal:no-fill}
nil

@item @code{opal:black-fill}
same as @code{opal:default-filling-style}

@item @code{opal:gray-fill}
same as @code{(opal:halftone 50)}

@item @code{opal:light-gray-fill}
same as @code{(opal:halftone 25)}

@item @code{opal:dark-gray-fill}
same as @code{(opal:halftone 75)}

@item @code{opal:diamond-fill}
a special pattern, defined with
@item @code{opal:make-filling-style}
See section @ref{fancy-stipple}.
@end vtable

@sp 1
@b{Solid Filling-Styles}

The second set of filling-styles are solid colors, and do not rely on stipples.
For these filling-styles, the @code{:foreground-color} slot of the object is
set with the corresponding instance of @code{opal:color}. For example, the
@code{:foreground-color} slot of @code{opal:red-fill} is set with @code{opal:red}.
Otherwise, these filling-styles are all identical to
@code{opal:default-filling-style}.

@sp 1
@cindex{red-fill}
@cindex{green-fill}
@cindex{blue-fill}
@cindex{yellow-fill}
@cindex{purple-fill}
@cindex{cyan-fill}
@cindex{orange-fill}

@vtable @code
@item opal:white-fill

@item opal:red-fill

@item opal:green-fill

@item opal:blue-fill

@item opal:yellow-fill

@item opal:purple-fill

@item opal:cyan-fill

@item opal:orange-fill
@end vtable

@sp 1
@cindex{motif-(light-)gray-fill}
@cindex{motif-(light-)blue-fill}
@cindex{motif-(light-)green-fill}
@cindex{motif-(light-)orange-fill}

@vtable @code
@item opal:motif-gray-fill

@item opal:motif-blue-fill

@item opal:motif-green-fill

@item opal:motif-orange-fill

@item opal:motif-light-gray-fill

@item opal:motif-light-blue-fill

@item opal:motif-light-green-fill

@item opal:motif-light-orange-fill
@end vtable


@subsection Creating Your Own Stippled Filling-Styles
@node Creating Your Own Stippled Filling-Styles
@anchor{custom-stipple}

@cindex{stipple}
The @code{:stipple} slot of a @code{filling-style} object is used to specify
patterns for mixing the foreground and background colors. The @code{:stipple}
slot is either NIL or an @code{opal:bitmap} object, whose image can be generated
from the @code{/usr/misc/.X11/bin/bitmap} Unix program (see section
@ref{bitmap-sec}). Alternatively, there is a Garnet
function supplied for generating halftone bitmaps to get various gray
shades.

@defun opal:halftone percentage


@anchor{halftone} The @code{halftone} function returns an
@code{opal:filling-style} object. The @var{percentage} argument is
used to specify the shade of the halftone (0 is white and 100 is
black). Its halftone is as close as possible to the var{percentage}
halftone value as can be generated. Since a range of @var{percentage}
values map onto each halftone shade, two additional functions are
provided to get halftones that are guaranteed to be one shade darker
or one shade lighter than a specified value.
@end defun

@cindex{halftone-darker}
@cindex{halftone-lighter}

@defun opal:halftone-darker percentage
@defunx opal:halftone-lighter percentage

The @code{halftone-darker} and @code{halftone-lighter} functions return a stippled
@code{opal:filling-style} object that is guaranteed to be exactly one shade
different than the halftone object with the specified
@emph{percentage}. With these functions you are guaranteed to get a different
darker (or lighter) @code{filling-style} object. Currently, there are 17
different halftone shades.


Examples of creating rectangles that are: black, 25% gray, and 33% gray are:

@example
(create-instance 'BLACKRECT opal:rectangle
   (:left 10)(:top 20)(:width 50)(:height 70)
   (:filling-style opal:black-fill))
(create-instance 'LIGHTGRAYRECT opal:rectangle
   (:left 10)(:top 20)(:width 50)(:height 70)
   (:filling-style opal:light-gray-fill))
(create-instance 'ANOTHERGRAYRECT opal:rectangle
   (:left 10)(:top 20)(:width 50)(:height 70)
   (:filling-style (opal:halftone 33)))
@end example

@end defun

@subsection Fancy Stipple Patterns
@node Fancy Stipple Patterns

@cindex{make-filling-style}
@cindex{diamond-fill}
Another way to create your own customized filling styles is to use
the function @code{opal:make-filling-style}:


@defun opal:make-filling-style description &key from-file-p @
       (foreground-color opal:black) (background-color opal:white)


The @var{description} can be a list of lists which represent the bit-mask of the
filling style, or may be the name of a file that contains a bitmap. The
@var{from-file-p} parameter should be T if a filename is being supplied as the
@var{description}.

As an example, the filling-style @code{opal:diamond-fill} is defined by:

@example
(setq opal:diamond-fill
      (opal:make-filling-style
       '((1 1 1 1 1 1 1 1 1)
	 (1 1 1 1 0 1 1 1 1)
	 (1 1 1 0 0 0 1 1 1)
	 (1 1 0 0 0 0 0 1 1)
	 (1 0 0 0 0 0 0 0 1)
	 (1 1 0 0 0 0 0 1 1)
	 (1 1 1 0 0 0 1 1 1)
	 (1 1 1 1 0 1 1 1 1)
	 (1 1 1 1 1 1 1 1 1))))
@end example

@end defun

@subsection Other Slots Affecting Stipple Patterns
@node Other Slots Affecting Stipple Patterns


@cindex{fill-style}
The @code{:fill-style} slot specifies the colors used for drawing the
"off" pixels in the stippled pattern of filling-styles. The "on"
pixels are always drawn with the @code{:foreground-color} of the filling-style.

@cindex{solid}
@cindex{stippled}
@cindex{opaque-stippled}

@vtable @code
@item @b{Line @code{:fill-style}}
@b{Color used for "off" pixels}
	
@item :solid
Color in @code{:foreground-color}

@item :stippled
Transparent

@item :opaque-stippled
Color in @code{:background-color}
@end vtable

@cindex{even-odd}
@cindex{winding}

@cindex{fill-rule}

The @code{:fill-rule} is either @code{:even-odd} or
@code{:winding}. These are used to control the filling for
self-intersecting polygons. For a better description of these see any
reasonable graphics textbook, or the X11 Protocol Manual.


@subsection Fast Redraw Objects
@node Fast Redraw Objects


@cindex{fast-redraw-p}
@cindex{fast redraw objects}
When an interface contains one or more objects that must be redrawn
frequently, the designer may choose to define these objects as fast
redraw objects. Such objects could be feedback rectangles
that indicate the current selection, or text strings which are updated
after any character is typed. Fast redraw objects are redrawn with an
algorithm that is much faster than the standard update procedure for
refreshing Garnet windows.

However, because of certain requirements
that the algorithm makes on fast redraw objects, most objects in an
interface are not candidates for this procedure. Primarily, fast
redraw objects cannot be covered by other objects, and they must be
either drawn with @emph{xor}, or else are guaranteed to be over only a solid
background. Additionally, aggregates cannot be fast-redraw objects;
only instances of @code{opal:graphical-object} (those with their own @code{:draw}
methods) can be fast-redraw objects.

To define an object as a fast redraw object, the @code{:fast-redraw-p}
slot of the object must be set to one of three allowed values -- 
@code{:redraw}, @code{:rectangle}, or @code{t}. These values determine how the
object should be erased from the window (so that it can be redrawn at
its new position or with its new graphic qualities). The following
paragraphs describe the functions and requirements of each of these values.

@vtable @code 

@item :redraw
The object will be erased by drawing it a second time
with the line style and filling style defined in the slots
@code{:fast-redraw-line-style} and @code{:fast-redraw-filling-style}.
These styles should be defined to 
have the same color as the background behind the object.
Additionally, these styles should have the same structure as the line
and filling styles of the object. For example, if the object has a
line thickness of 8, then the fast redraw line style must have a
thickness of 8 also. This value may be used for objects on color screens
where there is a uniform color behind the object.


@item :rectangle
The object will be erased by drawing a rectangle over
it with the filling style defined in the slot @code{:fast-redraw-filling-style}.
This filling style should have the same color as the
background behind the object. Like @code{:redraw}, this value assumes
that there is a uniform color behind the object. However, @code{:rectangle}
is particularly useful for complicated objects like bitmaps and text,
since drawing a rectangle takes less time than drawing these intricate
objects. 


@item t
In this case, the object must additionally have its
@code{:draw-function} slot set to @code{:xor}. This will cause the object
to be XOR'ed on top of its background. To erase the object, the
object is just drawn again, which will cause the two images to cancel out.
This value is most useful when the background is white and the objects
are black (e.g., on a monochrome screen), and can be used with a
feedback object that shows selection by inverse video.

@end vtable

@section Specific Graphical Objects
@node Specific Graphical Objects

This chapter describes a number of specific subclasses of the
@code{opal:graphical-object} prototype that implement all of the graphic
primitives that can be displayed, such as rectangles, lines, text strings, etc.

For all graphical objects, coordinates are specified as fixnum quantities
from the top, left corner of the window. All coordinates and distances are
specified in pixels.

Most of these objects can be filled with a filling style, have a border
with a line-style or both.
The default for closed objects is that @code{:filling-style} is @code{nil}
(not filled) and the @code{:line-style} is @code{opal:default-line-style}.

Note that only the slots that are not inherited from view objects and
graphic objects are shown below. In addition, of course, all of the
objects shown below have the following slots (described in the previous sections):
@cindex{left}
@cindex{top}
@cindex{width}
@cindex{height}
@cindex{visible}
@cindex{line-style}
@cindex{filling-style}
@cindex{draw-function}
@cindex{draw-function}
@cindex{select-outline-only}
@cindex{hit-threshold}
@example
  (:left 0)
  (:top 0)
  (:width 0)
  (:height 0)
  (:visible (o-formula ...))
  (:line-style opal:default-line-style)
  (:filling-style NIL)
  (:draw-function :copy)
  (:select-outline-only NIL)
  (:hit-threshold 0)
@end example

@cindex{maybe-constant}
@cindex{constant slots}
Most of the prototypes in this section have a list of slots in their
@code{:maybe-constant} slot, which generally correspond to the
customizable slots of the object. This is part of the @emph{constant
slots} feature of Garnet which allows advanced users to optimize their
Garnet objects by reusing storage space. Consult the KR manual for
documentation about how to take advantage of constant slots.

@b{HINT:} If you want a black-filled object, set the line-style to be
@code{nil} or else the object will take twice as long to draw (since
it draws both the border and the inside).

@ref{fig:ex3} shows examples of the basic object types in Opal.

@float Figure, fig:ex3
@center @image{allobjspic, 5.5in}
@caption{Examples of the types of objects supported by Opal: lines,
rectangles, rounded rectangles, text, multipoints, polylines,
arrowheads, ovals, circles, arcs, and bitmaps, with a variety of line
and filling styles.}
@end float

@subsection Line
@node Line

@example

@cindex{line}

(create-instance 'opal:line opal:graphical-object
  (:maybe-constant '(:x1 :y1 :x2 :y2 :line-style :visible))
  (:x1 0)
  (:y1 0)
  (:x2 0)
  (:y2 0))
@end example

The @code{opal:line} class describes an object that displays a line
from @math{(@code{:x1}, @code{:y1})} to @math{(@code{:x2},
@code{:y2})}. The @code{:left}, @code{:top}, @code{:width}, and
@code{:height} reflect the correct bounding box for the line, but
cannot be used to change the line (i.e., @b{do not set the}
@code{:left}, @code{:top}, @code{:width}, @b{or} @code{:height}
@b{slots}). Lines ignore their @code{:filling-style} slot.

@subsection Rectangles
@node Rectangles

@example

@cindex{rectangle}

(create-instance 'opal:rectangle opal:graphical-object
  (:maybe-constant '(:left :top :width :height :line-style :filling-style
		     :draw-function :visible)))
@end example

The @code{opal:rectangle} class describes an object that displays a
rectangle with top, left corner at @math{(@code{:left}, @code{:top})}, width
of @code{:width}, and height of @code{:height}.

@subsection Rounded-corner Rectangles
@node Rounded-corner Rectangles

@example

@cindex{roundtangle}
@cindex{radius}

(create-instance 'opal:roundtangle opal:rectangle
  (:maybe-constant '(:left :top :width :height :radius :line-style
		     :filling-style :draw-function :visible))
  (:radius 5))
@end example

Instances of the @code{opal:roundtangle} class are rectangles with rounded
corners. Objects of this class are similar to rectangles,
but contain an additional slot, @code{:radius}, which specifies the
curvature of the corners. The values for this slot can be either
@code{:small}, @code{:medium}, @code{:large}, or a numeric value interpreted as the
number of pixels to be used. The keyword values do not correspond directly
to pixels values, but rather compute a pixel value as a fraction of the
length of the shortest side of the bounding box.

@cindex{small}
@cindex{medium}
@cindex{large}

@vtable @code
@item 
@code{:radius} Fraction
	
@item :small
1/5

@item :medium
1/4

@item :large
1/3

@end vtable

Figure @ref{fig:ex4} demonstrates the meanings of the slots of
roundtangles. If the value of @code{:radius} is 0, the roundtangle looks
just like a rectangle. If the value of @code{:radius} is more than half
of the minimum of @code{:width} or @code{:height}, the roundtangle is drawn as
if the value of @code{:radius} were half the minimum of @code{:width} and @code{:height}.

@float Figure, fig:ex4
@center @image{roundtangle, 5.5in}
@caption{The parameters of a roundtangle.}
@end float

@subsection Polyline and Multipoint
@node Polyline and Multipoint

@example

@cindex{polyline}
@cindex{multipoint}

(create-instance 'opal:multipoint opal:graphical-object
  (:maybe-constant '(:point-list :line-style :filling-style :draw-function :visible))
  (:point-list nil))

(create-instance 'opal:polyline opal:multipoint
  (:hit-full-interior-p NIL))
@end example

The @code{opal:polyline} prototype provides for multi-segmented
lines. Polygons can be specified by creating a polyline with the same
first and last points.  The point list is a flat list of values
@code{(@var{x-1} @var{y-1} @var{x-2} @var{y-2} ...  @var{x-n}
@var{y-n})}. If a polyline object has a filling-style, and if the last
point is not the same as the first point, then an invisible line is
drawn between them, and the resulting polygon is filled.

The @code{:point-in-gob} method for the @code{opal:polyline} actually
checks whether the point is inside the polygon, rather than just
inside the polygon's bounding box. If the @code{:hit-full-interior-p}
slot of a @code{polyline} is NIL (the default), then the
@code{:point-in-gob} method will use the "even-odd" rule to determine
if a point is inside it. If the value of @code{:hit-full-interior-p}
is T, the method will use the "winding" rule. The slot
@code{:hit-threshold} has its usual functionality.

The @code{:left}, @code{:top}, @code{:width}, and @code{:height} slots
reflect the correct bounding box for the polyline, but cannot be used
to change the polyline (i.e., @b{do not set the} @code{:left},
@code{:top}, @code{:width}, @b{or} @code{:height} @b{slots}).


For example:
@example
@center @image{polyline, 5.5in}
(create-instance nil opal:polyline
   (:point-list '(10 50 50 10 90 10 130 50))
   (:filling-style opal:light-gray-fill)
   (:line-style opal:line-4))
@end example

A multipoint is like a polyline, but only appears on the screen as
a collection of disconnected points. The line-style and filling-style
are ignored.

@subsection Arrowheads
@node Arrowheads

@cindex{arrowhead}
@example
(create-instance 'opal:arrowhead opal:polyline
  (:maybe-constant '(:line-style :filling-style :length :diameter :open-p
		     :head-x :head-y :from-x :from-y :visible))
  (:head-x 0) (:head-y 0)
  (:from-x 0) (:from-y 0)
  (:connect-x (o-formula ...))  @emph{; Read-only slot}
  (:connect-y (o-formula ...))  @emph{; Read-only slot}
  (:length 10)
  (:diameter 10)
  (:open-p T)
  ...)
@end example

@cindex{head-x}
@cindex{head-y}
@cindex{from-x}
@cindex{from-y}
@cindex{connect-x}
@cindex{connect-y}
@cindex{length}
@cindex{diameter}
@cindex{open-p}
The @code{opal:arrowhead} class provides arrowheads. Figure @ref{arrowfig}
shows the meaning of the slots for arrowheads. The arrowhead is
oriented with the point at (@code{:head-x}, @code{:head-y}) and will point away
from (@code{:from-x}, @code{:from-y}). (@b{Note:} no line is
drawn from (@code{:from-x}, @code{:from-y}) to (@code{:head-x}, @code{:head-y}); the
@code{:from-} point is just used for reference.)  The @code{:length} slot
determines the distance (in pixels) from the point of the arrow to the base
of the triangle. The @code{:diameter} is the distance across the base. The
@code{:open-p} slot determines if a line is drawn across the base.

The arrowhead can have both a filling and an outline (by using the standard
@code{:filling-style} and @code{:line-style} slots). Arrowhead objects
also have 2 slots that describe the point at the center of the base to
which one should attach other lines. This point is (@code{:connect-x,
:connect-y}) and is set automatically by Opal; do not set these slots.
These slots are useful if the arrow is closed (see Figure
@ref{arrowfig} below).

If you want an arrowhead connected to a line, you might want to use the
@code{arrow-line} object (with one arrowhead) or @code{double-arrow-line} (with
arrow-heads optionally at either or both ends) supplied in the Garnet
Gadget Set @cite{GarnetGadgetsManual}.

@float Figure, fig:ex5
@center @image{arrow-illus, 5.5in}

@multitable @columnfractions .25 .15 .15 .15 .15 .15
@headitem @tab 1st @tab 2nd @tab 3rd @tab 4th @tab 5th
@item @code{:open-p:}
@tab T
@tab NIL
@tab T
@tab NIL
@tab T
@item @code{:filling-style:}
@tab NIL
@tab nil
@tab opal:light-gray-fill
@item @code{:line-style:}
@tab ....
@tab opal:line-0
@tab ....
@tab nil
@end multitable

@caption{The slots that define an arrowhead. At the bottom are various 
arrowheads with different styles. Note that a shaft for the arrow must be
drawn by the user.}

@anchor{arrowfig}
@end float


@subsection Arcs
@node Arcs

@example

@cindex{arc}

(create-instance 'opal:arc opal:graphical-object
  (:maybe-constant '(:left :top :width :height :line-style :filling-style
		     :draw-function :angle1 :angle2 :visible))
  (:angle1 0)
  (:angle2 0))
@end example

The @code{opal:arc} class provides objects that are arcs, which are
pieces of ovals. The arc segment is parameterized by the values of the
following slots: @code{:left}, @code{:top}, @code{:width},
@code{:height}, @code{:angle1}, and @code{:angle2}.

The arc is a section of an oval centered about the point
@math{(@code{center-x @var{arc}}, @code{center-y @var{arc}})}
calculated from the arc's @code{:left}, @code{:top}, @code{:width} and
@code{:height}, with width @code{:width} and height
@code{:height}. The arc runs from @code{:angle1} counterclockwise for
a distance of @code{:angle2} radians. That is, @code{:angle1} is
measured from 0 at the center right of the oval, and @code{:angle2} is
measured from @code{:angle1} (@code{:angle2} is relative to
@code{:angle1}).

Arcs are filled as pie pieces to the center of the oval.

For example:
@example
@center @image{arcexample, 5.5in}
;; the rectangle is just for reference
(create-instance 'myrect opal:rectangle
  (:left 10)(:top 10)(:width 100)(:height 50)) 
(create-instance 'myarc opal:arc
  (:left 10)(:top 10)
  (:width 100)(:height 50)
  (:angle1 (/ PI 4))
  (:angle2 (/ PI 2))
  (:line-style opal:line-2)
  (:filling-style opal:light-gray-fill))
@end example

@subsection Ovals
@node Ovals

@example

@cindex{oval}

(create-instance 'opal:Oval opal:arc)
@end example

Instances of the @code{:oval} class are closed arcs parameterized by the slots
@code{:left@r[,] :top@r[,] :width@r[, and] :height}.

@subsection Circles
@node Circles

@example

@cindex{circle}

(create-instance 'opal:Circle opal:arc)
@end example

The circle is positioned at the top, leftmost part of the bounding box
described with the @code{:left}. @code{:top}, @code{:width}, and @code{:height} slots.
The circle drawn has diameter equal to the @emph{minimum} of the width
and height, though the effective bounding box (used by
@code{point-in-gob}, for example) will still be defined by the actual
values in @code{:width} and @code{:height}. Both @code{:width} and
@code{:height} need to be specified.


@subsection Fonts and Text
@node Fonts and Text

@subsection Fonts
@node Fonts
There are two different ways to get fonts from Garnet. One way is to
explicitly create your own font object, and supply the object with a
description of the desired font, either with family, face, and size
descriptions, or with a font pathname. The other way is to use the function
@code{get-standard-font} which will create a new font object for you if
necessary, or return a previously created font object that you can use again.

There are two different types of font objects -- one which handles the
standard Garnet fonts (described by family, face, and size parameters), and
one which handles fonts specified by a filename. The @code{get-standard-font}
function only returns font objects that can be described with the three
standard parameters. Either kind of font object may be used anywhere a
@emph{font} is called for.

@subsection Built in Fonts
@node Built in Fonts

@cindex fonts
@cindex prototype
@example
(create-instance 'opal:font opal:graphic-quality
  (:maybe-constant '(:family :face :size))
  (:family :fixed)
  (:face :roman)
  (:size :medium)
   ...)

@cindex{default-font}
(create-instance 'opal:default-font opal:font
   (:constant t))
@end example

To use the standard Garnet fonts, create an instance of @code{opal:font} with
your desired values for the @code{:family}, @code{:face}, and @code{:size} slots.
Opal will automatically find the corresponding font for your display. The
allowed values for each slot are as follows:

@cindex{family}
@cindex{fixed}
@cindex{serif}
@cindex{sans-serif}
@cindex fonts
@cindex family

Values for @code{:family} can be:
@vtable @code
@item :fixed
a fixed width font, such as Courier. All characters are the
same width.

@item :serif
a variable-width font, with ``serifs'' on the characters,
such as Times.

@item :sans-serif
a variable-width font, with no serifs on the characters,
such as Helvetica.
@end vtable

@cindex{face}
@cindex{roman}
@cindex{italic}
@cindex{bold}
@cindex{bold-italic}
@cindex{plain}
@cindex{condense}
@cindex{extend}
@cindex{outline}
@cindex{shadow}
@cindex{underline}
@cindex fonts
@cindex face
Values for @code{:face} can be a single keword or a list of the following:

@vtable @code 
Faces available for both X windows and the Mac:

@item :roman

@item :italic

@item :bold

@item :bold-italic
@end vtable

Faces available for the Mac only:
@vtable @code 

@item :plain

@item :condense

@item :extend

@item :outline

@item :shadow

@item :underline
@end vtable

@cindex{size}
@cindex{small}
@cindex{medium}
@cindex{large}
@cindex{very-large}
@cindex fonts
@cindex size

Values for @code{:size} can be:

@vtable @code
:small
a small size, such as 10 points.

:medium
a normal size, such as 12 points.

:large
a large size, such as 18 points.

:very-large
a larger size, such as 24 points.

@end vtable

The exported @code{opal:default-font} object contains the font described by
@code{:fixed}, @code{:roman}, and @code{:medium}. This object should be
used when a font is required and you want to use the default values.
However, since this object's slots have been made constant for efficiency,
do not create instances of the @code{opal:default-font} object.
Instead, create instances of the @code{opal:font} objects with customized
values for the parameters, or use @code{get-standard-font} (explained below).

@subsection Reusing Fonts
@node Reusing Fonts

Instead of creating a new font object every time one is needed, you may
use the same font object in multiple applications. The function
@code{get-standard-font} remembers what fonts have been created, and will
return a previously created font object if a new font is needed that has
a matching description. Otherwise, @code{get-standard-font} will allocate a
new font object and return it, remembering it for later.

@defun opal:get-standard-font family face size

The parameters are all the keywords that are allowed for standard fonts.
For example: @code{(opal:get-standard-font :fixed :italic :medium)}. In
addition, any of the parameters can be @code{nil}, which means to use the
defaults (@code{:fixed :roman :medium}). It is more efficient to use
this procedure than to repeatedly allocate new font objects.

Since all the font objects returned by @code{get-standard-font} have
been declared constant for efficiency, you may not change the font
descriptions after the objects have been created.

Note:  @code{get-standard-font} only remembers those fonts that were allocated
by using @code{get-standard-font}. If a requested font matches an
independently-generated font, @code{get-standard-font} will not know about it
and will allocate a new font.

@end defun

@subsection Fonts from Files
@node Fonts from Files

@cindex fonts
@cindex font-from-file
@cindex{font-from-file}

@example
(create-instance 'opal:font-from-file opal:graphic-quality
  (:font-path nil)
  (:font-name "")
   ...)
@end example

This allows you to specify a file name to load a font from.

@cindex{font-path}
@cindex{font-name}
@cindex fonts
@cindex font directories
@cindex{xset}

X11 keeps a set of font directories, called the current "Font Path".
You can see what directories are on the font path by typing @code{xset
q} to the Unix shell, and you can add and remove directories from the
font path by using the @code{xset fp+} and @code{xset fp-} commands.

If the @code{:font-path} slot of a @code{:font-from-file} is a string
which is a directory, Opal pushes that directory onto
the X font path and then looks up the font. If the font name is
somewhere on the path already, you can let the @code{:font-path} slot be @code{nil}.
You can usually access fonts in the standard system font area (often
@code{/usr/misc/.X11/lib/fonts/}) without specifying a path name.

For example, for the font @code{vgi-25.snf} in the default
directory, use:
@example
(create-instance nil opal:font-from-file
   (:font-name "vgi-25"))
@end example

If the font was not in the default font path, then use something like:

@example
(create-instance nil opal:font-from-file
   (:font-path "/usr/misc/.X11/lib/fonts/75dpi/")
   (:font-name "vgi-25"))
@end example

@cindex{fonts.dir}
The font name @code{"vgi-25"} is looked up in a special file in the font
directory called @code{fonts.dir}. This file contains a long list of fonts
with the file name of the font on the left and the name for the server to
use on the right. For example, the entry corresponding to
@code{opal:default-font} may look like this:

@example
courier12.pcf           -adobe-courier-medium-r-normal--17-120-100-100-m-100-iso8859-1
@end example

On some displays, this font lookup may not proceed smoothly, and you may have
to supply the long @code{"-adobe-..."} name as the value of @code{:font-name}
instead of the more convenient @code{"courier12"}. Garnet internally builds
these names for the standard fonts, so font name lookup should never be a
problem for them.

@subsection Opal:Cursor-Font
@node Opal:Cursor-Font
@cindex{cursor-font}

@example
(create-instance 'opal:cursor-font opal:font-from-file
  (:constant t)
  (:font-name "cursor"))
@end example

The @code{opal:cursor-font} object accesses the
font used by your window manager to display cursors. This object is an
instance of @code{opal:font-from-file}, and may not be fully portable on
different machines. Regular text strings may be printed in this font, but
it is specifically intended for use when changing the cursor of Garnet
windows (see section @ref{the-cursor-slot}).


@subsection Functions on Fonts
@node Functions on Fonts

@cindex{string-width}
@cindex{string-height}

@example
opal:String-Width @emph{font-obj string} &key (@emph{start} 0) @emph{end}@ref{function}

opal:String-Height @emph{font-obj string} &key (@emph{actual-heightp} NIL)@ref{function}
@end example
The function @code{string-width} takes a font object (which can be a
@code{font} or a @code{font-from-file}) and a Lisp string, and
returns the width in pixels of that string written in that font.
The @emph{start} and @emph{end} parameters allow you to specify the beginning and
ending indices of the portion of @emph{string} that you want to measure.

The function @code{string-height} takes a font (or font-from-file) and a Lisp
string, and returns the height in pixels of that string written in that
font. There is an optional keyword parameter @emph{actual-heightp} which
defaults to @code{nil}, and has exactly the same effect on the return value of
@code{string-height} that the @code{:actual-heightp} slot of an @code{opal:text}
object has on the value of the @code{:height} slot of that @code{opal:text}
object (see section @ref{actualheightp}).

@subsection Text
@node Text
@anchor{text}
@example

@cindex{text}
@cindex{string}
@cindex{actual-heightp}

(create-instance 'opal:Text opal:graphical-object
  (:maybe-constant '(:left :top :string :font :actual-heightp :line-style :visible))
  (:string "")
  (:font opal:default-font)
  (:actual-heightp NIL)
  (:justification :left)
  (:fill-background-p NIL)
  (:line-style opal:default-line-style)
  (:cursor-index NIL))
@end example

Instances of the @code{opal:text} class appear as a horizontal string of glyphs
in a certain font. The @code{:string} slot holds the string to be displayed,
and can contain multiple lines. The @code{:font} slot specifies a font object
as described in the previous section (an instance of @code{opal:font} or
@code{opal:font-from-file}).

@cindex{line-style}
@cindex{fill-background-p}
The @code{:line-style} slot can control the color of the object, and can hold
any instance of @code{opal:line-style}, such as @code{opal:red-line}. The
@code{:foreground-color} slot of the @code{line-style} object determines the
color of the text. When the @code{:fill-background-p} slot is T,
then the background of each glyph of the text is drawn with the color in the
@code{:background-color} slot of the @code{line-style}. If the
@code{:fill-background-p} slot is @code{nil}, then the background is unaffected.

@cindex{justification}
@cindex{left (justification)}
@cindex{center (justification)}
@cindex{right (justification)}
The @code{:justification} slot can
take one of the three values @code{:left}, @code{:center}, or @code{:right},
and tells whether the multiple-line string is left-, center-, or
right-justified. The default value is @code{:left}.

A vertical bar cursor before the @code{:cursor-index}th
character. If @code{:cursor-index} is 0, the cursor is at the left of the
string, and if it is >= the length of the string, then it is at the right
of the string. If @code{:cursor-index} is @code{nil}, then the cursor is turned
off. The @code{:cursor-index} slot is set by the @code{inter:text-interactor}
during text editing.

@sp 1
@cindex{get-cursor-index}
@example
opal:Get-Cursor-Index @emph{string-obj x y}@ref{function}
@end example
This function returns the appropriate cursor-index for the (x,y) location
in the string. It assumes that the string is displayed on the screen.
This is useful for getting the position in the string when the user presses
over it with the mouse.

@anchor{actualheightp}
The slot @code{:actual-heightp} determines whether the height of the string
is the actual height of the characters used, or the maximum height of the
font. This will make a difference in variable size fonts if you have boxes
around the characters or if you are using a cursor (see section
@ref{text}). The
default (@code{nil}) means that the height of the font is used so all strings
that are drawn with the same font will have the same height.

The @code{:width} and @code{:height} slots reflect the correct width and height
for the string, but cannot be used to change the size (i.e., @b{do not
set the} @code{:width} @b{or} @code{:height} @b{slots}).



@subsection Scrolling Text Objects
@node Scrolling Text Objects
@anchor{auto-scroll}

@cindex auto scroll
@cindex opal:text
When an @code{opal:text} or @code{opal:multifont-text} object is used inside a
scrolling-window, there is an option that allows the window to scroll
automatically whenever the cursor is moved out of the top or bottom of
the visible region. To use this feature, two things need to be done:

@enumerate
The @code{:scrolling-window} slot of the text object must contain the scrolling
window object.
@cindex{scrolling-window slot}
@cindex auto scroll
@cindex scrolling-window slot

The text object must also have its @code{:auto-scroll-p} slot set to T.
@cindex auto scroll
@cindex auto-scroll-p slot
@end enumerate

@cindex auto scroll
@cindex vs. word wrap
@cindex{word wrap (in multifont-text)}
NOTE: Auto scroll is NOT the same as word wrap. If the cursor is
moved out of the right edge of the window, auto-scroll will not do
anything. 

@cindex{demo-multifont}
For an example of how the auto-scroll feature works, look at the code
for Demo-Multifont. Try the demo with the
@code{:auto-scroll-p} slot of the object @code{demo-multifont::text1} set to
both T and NIL.

Auto scroll does not keep track of changes in family, font, size, or
when a segment is cut or pasted. The @code{:auto-scroll} method has to be
invoked explicitly in such cases, using the following method:

@defmethod gg:auto-scroll  text-obj

For examples of calling @code{gg:auto-scroll} explicitly, look at the menu
functions in Demo-Multifont.
@end defmethod

@subsection Bitmaps
@node Bitmaps
@anchor{bitmap-sec}

@example
@cindex{bitmap}
@cindex{image}
(create-instance 'opal:Bitmap opal:graphical-object
  (:maybe-constant '(:left :top :image :filling-style :visible))
  (:image NIL)
  (:filling-style opal:default-filling-style)
  ...)
@end example
On the Mac, and in the
usual case with X11, the @code{:image} slot contains a machine-dependent
structure generated by the function @code{opal:read-image} (see below).
Under X11, there are a variety of other CLX image objects that can be
stored in this slot (consult your CLX manual for details on images). 

Bitmaps can be any size. Opal provides a function to read in a bitmap
image from a file:
@cindex{read-image}
@example
opal:Read-Image @i{file-name}@ref{function}
@end example
The @code{read-image} function reads a bitmap image from @emph{file-name} which
is stored in the default X11 ".bm" file format. Files of this format may
be generated by using the Unix program @code{/usr/misc/.X11/bin/bitmap}.

The @code{:filling-style} slot can contain any instance of
@code{opal:filling-style}. If the @code{:fill-style} of the bitmap's
@code{:filling-style} is @code{:solid} or @code{:opaque-stippled}, then the bitmap
will appear with that filling-style's foreground-color and background-color.
If, however, the @code{:fill-style} of the filling-style is @code{:stippled},
then the bitmap will appear with the filling-style's @code{:foreground-color},
but its background will be transparent. For example, the following
code creates a bitmap which will be drawn with a red and white stipple
(because white is the default @code{:background-color} of
@code{opal:filling-style}):  @cindex{stippled}

@example
(create-instance 'RED-ARROW opal:arrow-cursor
   (:filling-style (create-instance NIL opal:filling-style
                      (:foreground-color opal:red)
                      (:fill-style :stippled))))
@end example


There are several functions supplied for generating halftone images, which
can then be supplied to the @code{:image} slot of a bitmap object. These
functions are used to create the filling styles returned by the
@code{halftone} function (section @ref{halftone}).
@sp 1
@cindex{halftone-image}
@example
opal:Halftone-Image @emph{percentage}@ref{function}
@end example
The @code{halftone-image} function returns a image for use in the
@code{:image} slot of a bitmap object. The @emph{percentage} argument is
used to specify the 
shade of the halftone (0 is white and 100 black). This image is as close
as possible to the @emph{percentage} halftone value as can be generated.
Since a range of @emph{percentage} values map onto each halftone image, two
additional functions are provided to get images that are guaranteed to be
one shade different or one shade lighter than a specified value.

@sp 1

@cindex{halftone-image-darker}
@cindex{halftone-image-lighter}
@example
opal:Halftone-Image-Darker @emph{percentage}@ref{function}

opal:Halftone-Image-Lighter @emph{percentage}@ref{function}
@end example

The @code{halftone-image-darker} and @code{halftone-image-lighter}
functions return a halftone that is guaranteed to be exactly one shade
darker than the halftone with the specified @emph{percentage}. With these
functions you are guaranteed to get a different darker (or lighter)
image. Currently, there are 17 different halftone shades.

The @code{:width@r[, and] :height} slots reflect the correct width and
height for the bitmap, but cannot be used to change the size (i.e.,
@b{do not set the} @code{:width} @b{or} @code{:height} slots)).

@subsection Pixmaps
@node Pixmaps

@example
@cindex{pixmap}
@cindex{image}
(create-instance 'opal:pixmap opal:bitmap
  (:image NIL)
  (:line-style opal:default-line-style)
  (:pixarray (o-formula (if (gvl :image)
			    (gem:image-to-array (gv-local :self :window)
						(gvl :image))))))
  ...)

@end example

This object is similar to the @code{opal:bitmap} object, except that it handles
images which use more than one bit per pixel.

@cindex{image}The @code{:image} slot works exactly like that of
@code{opal:bitmap}, in conjunction with the function @code{opal:read-xpm-file}
(see below).

@cindex{pixarray}
The @code{:pixarray} slot contains an array of colormap indices.
This is useful if you want to manipulate a pixmap directly,
as in the demo "demo-pixmap".

The @code{:width@r[, and] :height} slots reflect the correct width and
height for the pixmap, but cannot be used to change the size (i.e.,
@b{do not set the} @code{:width} @b{or} @code{:height} @b[slots]).


@subsection Creating a pixmap
@node Creating a pixmap
@cindex{creating pixmaps}

The following routine can be used to create an image for a pixmap.

@cindex{read-xpm-file}
@example
opal:Read-XPM-File @emph{pathname} @value{function}
@end example

The argument @emph{pathname} should be the name of a file containing a C
pixmap image. @code{Read-xpm-file} returns an X-specific or Mac-specific
object, which then should be put in the @code{:image} slot of an
@code{opal:pixmap}. The file @emph{pathname} containing the C pixmap image
should be in the @emph{xpm} format. Please refer to the X Window System
documentation for more details about that format.

The function @code{read-xpm-file} will read pixmaps in the XPM1 or XPM2 format.
Files in these formats are produced by the program @code{ppmtoxpm} and the
OpenLook @code{IconEditor} utility. The @code{ppm} collection of
utilities are useful for converting one format into another. If you
do not have them, you can @c[ftp] them from one of the standard sites that
store Unix utilities.

In Unix, to convert the contents of a color window into an @emph{xpm} format
file, you can use programs such as @code{xwd}, @code{xwdtopnm}, @code{ppmtoxpm},
etc. For example, inside a Unix shell, type:

@cindex{xwd}
@example
xwd > foo.xwd
@end example

When the cursor changes to a plus, click on the window you want to dump.
Then type:

@cindex{xwdtopnm}
@cindex{ppmtoxpm}
@cindex{ppm}
@example
xwdtopnm foo.xwd > foo.ppm
ppmtoxpm foo.ppm > foo.xpm
@end example

This will create a file named "foo.xpm". @comment[in the ??? format]
Finally, in Garnet, type:

@example
(create-instance 'FOO opal:pixmap
   (:image (opal:read-xpm-file "foo.xpm")))
@end example


Here are two more routines that can be used to create images for pixmaps.

@cindex{create-pixmap-image}
@example
opal:Create-Pixmap-Image @emph{width height} &optional @emph{color} @ref{Function}
@end example
This creates a solid color pixmap image. If you wanted to create a
pixmap whose image was, say, a 20x30 blue rectangle, you
would say:

@example
(create-instance 'BLUE-PIXMAP opal:pixmap
   (:image (opal:create-pixmap-image 20 30 opal:blue)))
@end example

If no color is given, the color defaults to white.

@cindex{creating the image of a window}
@cindex{window-to-pixmap-image}
@example
opal:Window-To-Pixmap-Image @emph{window} &key @emph{left top width height} @ref{Function}
@end example
This creates an image containing the contents of a Garnet window,
within a rectangular region specified by the values @emph{left},
@emph{top}, @emph{width}, and @emph{height}. Left and top default to 0.
@emph{Width} and @emph{height} default to the values of the @code{:width} and
@code{:height} slots of the window, respectively.


@subsection Storing a pixmap
@node Storing a pixmap

@sp 1
@cindex{saving pixmaps}
@cindex{write-xpm-file}
@example
opal:Write-XPM-File @emph{pixmap pathname} &key @emph{(xpm-format :xpm1)} @ref{Function}
@end example

This function writes the @code{:image} of a pixmap object into a C pixmap file
whose name is @emph{pathname}. @code{Write-xpm-file} will write pixmap files in
either XPM1 or XPM2 format, depending on the value of the @emph{xpm-format} key,
which may be either @code{:xpm1} or @code{:xpm2}. By default, the function
generates files in XPM1 format, which can be read by the @code{xpmtoppm}
utility.

@section Multifont
@node Multifont
@cindex{multifont-text}

@example
(create-instance 'opal:Multifont-Text opal:aggregate
   (:left 0)
   (:top 0)
   (:initial-text ...)
   (:word-wrap-p NIL)
   (:text-width 300)
   (:current-font ...)
   (:current-fcolor ...)
   (:current-bcolor ...)
   (:fill-background-p T)
   (:draw-function :copy)
   (:show-marks NIL))
@end example

The @code{multifont-text} object is loaded by default, since it is used
by the new @code{garnet-debug:Inspector}. If you are not already
loading the @code{Inspector}, you can load @code{multifont-text} and all
of its interactors with @w{@code{(garnet-load "opal:multifont-loader")}}.

@sp 1

@cindex{word wrap (in multifont-text)}
The @code{opal:multifont-text} object is designed to allow users to create more
complicated editing applications. The object is similar to the 
@code{opal:text} object with many added abilities. As the name implies,
the @code{opal:multifont-text} object can accept text input in multiple fonts.
Also, the object has a word wrap mode to permit word-processor-like editing as
well as the ability to highlight text for selection.

Positioning the object is
performed with @code{:left} and @code{:top} as with most Garnet objects. The slots
@code{:width} and @code{:height} are read-only and can be used to
see the size of the object, 
but should not be changed by the user. The @code{:initial-text} slot is used to
initialize the contents of the @code{multifont-text}. The format of the
@code{:initial-text} slot is complicated enough that the next section is devoted
to discussing it. If the user is not particular about the font of the initial
contents, a simple string is sufficient for the 
@code{:initial-text} slot. The slots
@code{:word-wrap-p} and @code{:text-width} control the word wrap mode.
If @code{:word-wrap-p} is T, the text will wrap at the pixel width given in the
@code{:text-width} slot. If @code{:word-wrap-p} is @code{nil}, word wrap mode will
not be activated and no wrapping will occur. In this case, your
string should contain @code{#\newline}s wherever required.
Both @code{:word-wrap-p} and @code{:text-width} can be modified at run time.

The @code{:current-font} slot can
be used to control what font newly added characters will appear as. Also, the
@code{:current-font} slot can be polled to determine the last font of the
character the cursor most recently passed over. The slots @code{:current-fcolor}
and @code{:current-bcolor} act similarly for the foreground and background colors
of the text. The slot
@code{:fill-background-p} controls the background of the characters. If
@code{:fill-background-p} is T, the background of the character will be drawn in
the @code{:current-bcolor}. If @code{:fill-background-p} is @code{nil},
the background of the glyphs will not be drawn at all (allowing
whatever is behind the multifont text object to show through). The slot 
@code{:show-marks} turns on and off the visibility of text marks. If
@code{:show-marks} is T, text-marks will be visible, appearing as little carats
pointing to the character to which they are stuck. When @code{:show-marks} is
NIL, the marks will be invisible.

Along with the multi-font text object are a pair of special
interactors that make them editable (see section
@ref{multifontinters}). The font 
object and the two interactors are combined into the
@code{multifont-gadget} gadget for convenience (section
@ref{multifontgadgetsec}).

There are two demos that show off multifont capabilities. @code{Demo-text}
shows how to use the @code{multifont-text} object with the
@code{multifont-text-interactor}. @code{Demo-multifont} shows how to use
multiple text fields in a single window with the
@code{focus-multifont-textinter} and @code{selection-interactor}, and
demonstrates the indentation and paren-matching features of lisp mode.

@subsection Format of the @code{:initial-text} Slot
@node Format of the :initial-text Slot

The format used in the @code{:initial-text} slot of @code{multifont-text}
is also used by many of the procedures and
functions that can be called using the multifont object.

In its simplest form, the @code{:initial-text} format can be a single
string. In this form, the default font and colors are used.
The simplest values for @code{:initial-text} are:

@example
"Here is my example string."

"An example string
with multiple lines."
@end example

All other formats require a list structure. The outermost list is the list of
lines:  @code{(list line1 line2 ... )}. A line can either be a string in which
case the default font and colors are used, or 
a line can be a list of fragments:
@code{(list frag1 frag2 ... )}. Each line acts as though it ends with a newline
character. If the @code{multifont-text} has word wrap activated, each line will
also be broken at places where the length of the text exceeds the
@code{:text-width}, thus the user need not compute how to break up the text to
be placed in the window. A fragment is the unit that allows the user to enter
font data into the @code{:initial-text} format. A fragment can be 
one of the following:
@itemize
a string,  in which case the defaults are used.

a "cons"ing of a string with a Garnet font:  @code{(cons "string" garnet-font)}.

a list of a string, font, foreground color, and background color:
@code{(list "string" font f-color b-color)}. If @emph{font} or
@emph{color} is NIL, the default will be used.

a @code{view-object} (see @ref{objects}).

a mark, in the form @code{(list :mark sticky-left name info)} (see @ref{marks}).
@end itemize

Note that only the fragment level contains font or color information.
For instance, a single line in bold font may look like this:


@example
 `((("Here is my example string" . ,(opal:get-standard-font :fixed :bold :medium))))
@end example

Here is a set of sample values for the @code{:initial-text} slot. Each
of these examples are pictured in Figure @ref{multifont-pix}. Details
on using fonts, colors, marks, and graphical objects are given in
section @ref{multifont-fns}.

@example
@emph{; Define some fonts for brevity, and a circle to use in a string.}
(setf ITALIC (opal:get-standard-font :fixed :italic :medium))
(setf BOLD   (opal:get-standard-font :fixed :bold :medium))
(create-instance 'MY-CIRCLE opal:circle)

@emph{; A pair of lines. Both lines are strings.}
'("An example string" "with multiple lines")

@emph{; Same pair of lines in italics.}
`((("An example string" . ,ITALIC))
  (("with multiple lines" . ,ITALIC)))

@emph{; A single line with multiple fragments. Note fragments can be strings}
@emph{; when default font is desired.}
`(("Here " ("is" . ,ITALIC) " my " ("example" . ,BOLD) " string."))

@emph{; A single line containing a graphical object}
`(("Here is a circle:" ,MY-CIRCLE))

@emph{; A single line with colored fragments}
`(("Here is " ("yellow" ,BOLD ,opal:yellow) " and " ("red" ,BOLD ,opal:red) " text"))

@emph{; A single line with marks. Note: make marks visible by setting} :show-marks @emph{to} T.
`(("The " (:mark NIL) "(parentheses)" (:mark T) " are marked")))
@end example

@float Figure, fig:ex6
@center @image{multifont-pix, 5.5in}
@caption{Examples of the multifont-text object}
@anchor{multifont-pix}
@end float

@subsection Functions on Multifont Text
@node Functions on Multifont Text
@anchor{multifont-fns}

The @code{opal:multifont-text} differs from most objects in that it has a great
number of functions that operate on it. The functions range
from mundane cursor movement to complicated operations upon selected
text. Very few operations can be performed by manipulating the slots of a
multifont object.

@subsection Functions that Manipulate the Cursor
@node Functions that Manipulate the Cursor

@cindex{set-cursor-visible}
@example
opal:Set-Cursor-Visible @emph{text-obj vis}@ref{function}
@end example

This makes the cursor of a @code{multifont-text} visible or invisible, depending
on whether @emph{vis} is @code{t} or @code{nil}. Having a visible cursor is
not required for entering text, but is recommended for situations
requiring user feedback. This function does not return any useful value.

@cindex{set-cursor-to-x-y-position}
@cindex{set-cursor-to-line-char-position}
@example
opal:Set-Cursor-To-X-Y-Position @emph{text-obj x y}@ref{function}

opal:Set-Cursor-To-Line-Char-Position @emph{text-obj line# char#}@ref{function}
@end example

These move the cursor to a specific location in the @code{multifont-text}. The
function @code{set-cursor-to-x-y-position} sets the cursor to the position
nearest the <x, y> pixel location. The function
@code{set-cursor-to-line-char-position} tries to place the cursor at the
position indicated (zero-based). If the line or character
position is not legal, it will
try to find a reasonable approximation of the location given. Neither
function returns any useful value.

@cindex{go-to-next-char}
@cindex{go-to-prev-char}
@cindex{go-to-next-word}
@cindex{go-to-prev-word}
@cindex{go-to-next-line}
@cindex{go-to-prev-line}
@example
opal:Go-To-Next-Char @emph{text-obj}@ref{function}

opal:Go-To-Prev-Char @emph{text-obj}@ref{function}

opal:Go-To-Next-Word @emph{text-obj}@ref{function}

opal:Go-To-Prev-Word @emph{text-obj}@ref{function}

opal:Go-To-Next-Line @emph{text-obj}@ref{function}

opal:Go-To-Prev-Line @emph{text-obj}@ref{function}
@end example

These functions move the cursor relative to where it is currently located.
The functions @code{go-to-next-char} and @code{go-to-prev-char} move the cursor one
character at a time. The functions @code{go-to-next-word} and @code{go-to-prev-word}
move the cursor one word at a time. In this case, a word is defined by
non-whitespace characters separated by whitespace. A whitespace character is
either a space or a newline. These functions will skip over all
non-whitespace until they reach a whitespace character. They will then skip
over the whitespace until they find the next non-white character. The
functions @code{go-to-next-line} and @code{go-to-prev-line} moves down and up one
line at a time. The horizontal position of the cursor will be maintained as
close as possible to its position on the original line. The functions
@code{go-to-next-char}, @code{go-to-prev-char}, @code{go-to-next-word}, and
@code{go-to-prev-word} all return the characters that were passed over including
newlines as a simple string. @code{nil} will be returned if the cursor
does not move as a
consequence of being at the beginning or end of the text. The
functions @code{go-to-next-line} and @code{go-to-prev-line} do not return
useful values. 

@cindex{go-to-beginning-of-line}
@cindex{go-to-end-of-line}
@cindex{go-to-beginning-of-text}
@cindex{go-to-end-of-text}
@example
opal:Go-To-Beginning-Of-Line @emph{text-obj}@ref{function}

opal:Go-To-End-Of-Line @emph{text-obj}@ref{function}

opal:Go-To-Beginning-Of-Text @emph{text-obj}@ref{function}

opal:Go-To-End-Of-Text @emph{text-obj}@ref{function}
@end example

These functions move the cursor to a position at the beginning or end of
something. The functions @code{go-to-beginning-of-line} and
@code{go-to-end-of-line} move the cursor to the beginning or end of its current
line. The functions @code{go-to-beginning-of-text} and @code{go-to-end-of-text}
move the cursor to the beginning or end of the entire document. None of these
functions return a useful value.


@subsection Functions for Text Selection
@node Functions for Text Selection

@cindex{toggle-selection}
@example
opal:Toggle-Selection @emph{text-obj mode}@ref{function}
@end example

This will turn off and on the selection mode. When selection mode is on,
moving the cursor will drag the selection highlight to include characters
that it passes over. Moving the cursor back over selected text will unselect
and unhighlight the text. Setting @emph{mode} to @code{t} turns on
selection mode, and setting it to @code{nil} turns off selection mode.
Turning off selection mode will unhighlight all highlighted text.

@cindex{set-selection-to-x-y-position}
@cindex{set-selection-to-line-char-position}
@example
opal:Set-Selection-To-X-Y-Position @emph{text-obj  x y}@ref{function}

opal:Set-Selection-To-Line-Char-Position @emph{text-obj  line# char#}@ref{function}
@end example

These functions are similar to the functions @code{set-cursor-to-x-y-position}
and @code{set-cursor-to-line-char-position}. The selection highlight has two
ends. One end is bound by the cursor; here, the other end is called the
selection end. To move the cursor end of the highlight, use the cursor
functions. To move the selection end, use these two functions. The function
@code{set-selection-to-x-y-position} sets the selection end based on pixel
position. The function @code{set-selection-to-line-char-position} is based on
line and character position. Neither function returns a useful value.

@cindex{copy-selected-text}
@cindex{delete-selection}
@example
opal:Copy-Selected-Text @emph{text-obj}@ref{function}

opal:Delete-Selection @emph{text-obj} &optional @emph{lisp-mode-p} @ref{function}
@end example

These functions are used to manipulate the selected text. The
@code{copy-selected-text} function just returns the selected text without affecting
the multifont object. The function @code{delete-selection} removes all selected
text from the multifont object and returns it. Both functions return the text
in the @code{text} format described above. The function @code{delete-selection}
will also automatically turn off selection mode. Since special bookkeeping
is done to keep track of parentheses and function names in lisp-mode, you must
supply a value of T for @emph{lisp-mode-p} when the interactors currently working
on the @emph{text-obj} are in lisp-mode.

@cindex{change-font-of-selection}
@example
opal:Change-Font-Of-Selection @emph{text-obj  font} &key @emph{family size italic bold}@ref{function}
@end example

The font of selected text can be updated using this function. There are two
options. The new font can be given explicitly using the @emph{font} parameter,
or it can be updated by setting @emph{font} to @code{nil} and using the key
parameters. 

Valid values for @emph{family} are:
@itemize
@code{:fixed} - makes font fixed width

@code{:serif} - makes font variable-width with "serifs" on the characters

@code{:sans-serif} - makes font variable-width with no serifs on the characters
@end itemize

Values for @emph{size} are:
@itemize
@code{:small} - makes font smallest size

@code{:medium} - makes font medium size

@code{:large} - makes font large size

@code{:very-large} - makes font the largest size

@code{:bigger} - makes font one size larger than it is

@code{:smaller} - makes font one size smaller than it is
@end itemize

Values for @emph{italic} and @emph{bold} are:
@itemize
@code{T} - makes font italic or bold

@code{NIL} - undoes italic or bold

@code{:toggle} - toggles italic or bold throughout the selected region.


@code{:toggle-first} - looks at the first character of the selection,
and changes the entire region by toggling based on the bold or italic
of that character
@end itemize

The function @code{change-font-of-selection} is also used to change the value
of the slot @code{:current-font} even if there is no text selected.


@cindex{change-color-of-selection}
@example
opal:Change-Color-Of-Selection @emph{text-obj  foreground-color background-color}@ref{function}
@end example

This function will change the color of the selected text. If only one of
foreground-color and background-color needs to be changed, the other should
be sent as NIL. This function also changes the values of the slots @code{:current-fcolor} and @code{:current-bcolor}.


@subsection Functions that Access the Text or Cursor
@node Functions that Access the Text or Cursor

@cindex{get-string}
@cindex{get-text}
@example
opal:Get-String @emph{text-obj}@ref{function}

opal:Get-Text @emph{text-obj}@ref{function}
@end example

These functions return the entire contents of the @code{multifont-text} object.
The function @code{get-string} returns the contents as a single string with
@code{#\newline}s separating lines. The function @code{get-text} returns the
contents in the @code{:initial-text} slot format.

@cindex{get-cursor-line-char-position}
@cindex{get-selection-line-char-position}
@example
opal:Get-Cursor-Line-Char-Position @emph{text-obj}@ref{function}

opal:Get-Selection-Line-Char-Position @emph{text-obj}@ref{function}
@end example

These return the position of the cursor or the selection end of a highlight.
The values are returned using multiple return values: (@emph{values line char}).

@cindex{fetch-next-char}
@cindex{fetch-prev-char}
@example
opal:Fetch-Next-Char @emph{text-obj}@ref{function}

opal:Fetch-Prev-Char @emph{text-obj}@ref{function}
@end example

These return the character before or after the cursor. The function
@code{fetch-next-char} returns the character after the cursor, and
@code{fetch-prev-char} returns the character before the cursor. Neither function
affects the text of the object. The functions will return @code{nil} if the cursor
is at the beginning or end of the text where there is no character before or
after the cursor.


@subsection Adding and Editing Text
@node Adding and Editing Text

@cindex{add-char}
@cindex{insert-string}
@cindex{insert-text}
@example
opal:Add-Char @emph{text-obj  char} &optional @emph{font  foreground-color  background-color lisp-mode-p}@ref{function}

opal:Insert-String @emph{text-obj  string} &optional @emph{font  foreground-color  background-color}@ref{function}

opal:Insert-Text @emph{text-obj  text}@ref{function}
@end example

These functions are used to add text to a multifont object. The function
@code{add-char} adds a single character, the function @code{insert-string} adds
a whole string possibly including newline, and @code{insert-text} adds
text that is in @code{:initial-text} slot format.

The optional @emph{font} and @emph{color} parameters indicate the font and color
of the new text. If any of these parameters are NIL, the newly added text
will use the value of the @code{:current-font}, @code{:current-fcolor}, and/or
@code{:current-bcolor} slots, which can be set manually or allowed to take on
the font and colors of the character over which the cursor last passed.

The optional @emph{lisp-mode-p} argument indicates whether the interactors
currently working on the multifont object are in lisp-mode. Extra operations
are performed on the string to keep track of parentheses and function names
when in lisp-mode, and this parameter is required to keep the bookkeeping
straight.


@cindex{delete-char}
@cindex{delete-prev-char}
@cindex{delete-word}
@cindex{delete-prev-word}
@example
opal:Delete-Char @emph{text-obj}@ref{function}

opal:Delete-Prev-Char @emph{text-obj}@ref{function}

opal:Delete-Word @emph{text-obj}@ref{function}

opal:Delete-Prev-Word @emph{text-obj}@ref{function}
@end example

These functions are used to delete text from a multifont object. The functions
@code{delete-char} and @code{delete-prev-char} delete a single character after
or before the cursor. The functions @code{delete-word} and @code{delete-prev-word}
delete a single word. A word is defined the same way as in the functions
@code{go-to-next-word} and @code{go-to-prev-word}. The word will be deleted by
deleting whitespace characters up to the first non-whitespace character and
then deleting all non-whitespace up to the next whitespace character. The
value returned by these functions is the characters deleted. @code{NIL} is returned
if no characters are deleted.

@cindex{delete-substring}
@cindex{kill-rest-of-line}
@example
opal:Delete-Substring @emph{text-obj start-line# start-char# end-line# end-char#}@ref{function}

opal:Kill-Rest-Of-Line @emph{text-obj}@ref{function}
@end example

These functions are used to delete larger portions of text. The function
@code{delete-substring} removes all characters within the given range. If the
start position is after the end position, nothing will happen. The function
@code{kill-rest-of-line} deletes all characters from the cursor to the end
of the current line. When word wrap is on, the end of a wrapped line is where
the wrap occurs. Both functions return the deleted text as a string.

@cindex{set-text}
@example
opal:Set-Text @emph{text-obj  text}@ref{function}
@end example

This function is used to reset everything in the multifont object. All
previous text is deleted and the new @emph{text} is put in its place. The
@emph{text} parameter uses the @code{:initial-text} slot format. The new cursor
position will be at the beginning of the text. This function does not return
a useful value.


@subsection Operations on :initial-text Format Lists
@node Operations on :initial-text Format Lists

@cindex{text-to-pure-list}
@cindex{pure-list-to-text}
@example
opal:Text-To-Pure-List @emph{text}@ref{function}

opal:Pure-List-To-Text @emph{list}@ref{function}
@end example

These functions converts text in the @code{:initial-text} slot format into a format
that is similar but uses a list representation for fonts, colors,
marks, and view-objects. Converting the
fonts from Garnet objects to lists makes operations such as reading or writing
text objects to files easier. To convert from @code{:initial-text}
format to list use @code{text-to-pure-list} and to convert back use
@code{pure-list-to-text}. 

@cindex{text-to-string}
@example
opal:Text-To-String @emph{text}@ref{function}
@end example

This function converts text in the @code{:initial-text} format into a regular
character string, losing all font, color, and mark information.

@cindex{concatenate-text}
@example
opal:Concatenate-Text @emph{text1 text2}@ref{function}
@end example

This function is like the lisp function @code{concatenate} for arrays. The
function will return the concatenation of @emph{text2} onto the end of
@emph{text1}. The function will not affect @emph{text1} or @emph{text2}.


@subsection Using View-Objects as Text
@node Using View-Objects as Text
@anchor{objects}
@cindex{add-object}
@cindex{get-objects}
@cindex{notice-resize-object}
@example
opal:Add-Object @emph{gob object}@ref{function}

opal:Get-Objects @emph{gob}@ref{function}

opal:Notice-Resize-Object @emph{object}@ref{function}
@end example

These functions are useful when you want to include a shape or other
view-object in the multifont text. The function @code{add-object} will insert
a view-object at the cursor. The object will act just like a character;  the 
cursor can move over it, and it can be selected, deleted, etc. The function 
@code{get-objects} will return a list of all the objects currently in the text. 
When the size of an object which is in the text changes, the function 
@code{notice-resize-objects} should be used to notify multifont of the change.


@subsection Using Marks
@node Using Marks
@anchor{marks}
@cindex{marks}
@cindex{show-marks}

Another feature of the multifont object is the ability to use text-marks. The
function @code{insert-mark} will insert a mark at the cursor. Marks are
invisible to the cursor as you are typing, and are primarily used as
place-holders in the text. The lisp-mode feature uses marks to keep
track of parentheses when it is paren-matching. To make all of the
marks in a multifont object visible (so you can see them), set the
@code{:show-marks} slot to @code{T}.

@cindex{insert-mark}
@example
opal:Insert-Mark @emph{gob sticky-left} &key @emph{name info}@ref{function}
@end example

The @emph{sticky-left} parameter should be T if the mark should stick to
the character
on its left, and NIL if it should stick to the one on its right. When
a mark "sticks" to a character, the cursor cannot be inserted between
the character and the mark. This makes the position of the mark
equivalent to the position of the character, so it is easy to
determine whether the cursor is on the left or right side of the mark.

One implication of "stickiness" is that a mark moves through the
string along with the character that it is stuck to (i.e., if you are
typing with the cursor in front of the mark, the mark will be pushed forward
along with the character in front of it). Another implication is
that when a character is deleted, the mark(s) stuck to it will be
deleted as well.

The @emph{name} parameter is a useful way to differentiate between marks,
and @emph{info} can be used to let the mark carry any additional
information that might be useful.

@cindex{search-for-mark}
@cindex{search-backwards-for-mark}
@cindex{between-marks-p}
@example
opal:Search-For-Mark @emph{gob} &key @emph{name info}@ref{function}

opal:Search-Backwards-For-Mark @emph{gob} &key @emph{name info}@ref{function}

opal:Between-Marks-P @emph{gob} &key @emph{name info}@ref{function}
@end example

The functions @code{search-for-mark} and 
@code{search-backwards-for-mark} will return the mark which is nearest to the
cursor. Leaving out the keywords will search for any mark, or include a
@emph{name} or @emph{info} to search for a specific type of mark.
The function @code{between-marks-p} can help to use marks as a type of region.
It will search right and left, and  will return T if the mark found to the 
left is sticky-left and the one on the right is sticky-right. 


@subsection Interactors for Multifont Text
@node Interactors for Multifont Text
@anchor{multifontinters}

It may seem strange to find a section about interactors in the Opal chapter,
Since the interactors mentioned here are integral to using the
@code{opal:multifont-text} object, it was decided to include their description
here, near the description of the @code{multifont-text}. If you are not
familiar with the basic principles of interactors, you will be best served
if you read the interactors manual first, particularly the parts about the
@code{inter:text-interactor} and the slots of all interactors.

There are three interactors for multifont-text objects. The
@code{multifont-text-interactor} is similar to the standard
@code{text-interactor}, and is used in much the same way. Two other
interactors, the @code{focus-multifont-textinter} and
@code{selection-interactor} are designed to work together in more
complicated situations, like when there are two or more multifont
objects being edited in the same window.

The convenient @code{multifont-gadget} (section @ref{multifontgadgetsec})
combines the @code{focus-multifont-textinter} and @code{selection-interactor} 
with a @code{multifont-text} object, so you might be able to use it rather
than explicitly creating the interactors below. However, the gadget
is only useable when you have exactly one @code{multifont-text} object in
a window. If you want more than one text object, then you should
create the interactors explicitly because there should still be only
one pair of @emph{interactors} in each window, and the interactors should
be set up so the @code{:start-where} will return one of the multifont
objects. So, it could be an @code{:element-of...} type
specification or a @code{:list-of...} or whatever that will return
multifonts, just so long that it doesn't return other types of objects.

@subsection Multifont Text Interactor
@node Multifont Text Interactor
@anchor{multifontkeyboardcmds}

@example
@cindex{multifont-text-interactor}

(create-instance 'inter:Multifont-Text-Interactor inter:text-interactor
   (:window NIL)
   (:edit-func #'inter::MultiFont-Text-Edit-String)
   (:lisp-mode-p NIL)             @emph{; See section @ref{lisp-mode}}
   (:match-parens-p NIL)          @emph{;  "        "          "} 
   (:match-obj ...)               @emph{;  "        "          "}
   (:drag-through-selection? T)   @emph{; See below}
   (:button-outside-stop?    T)   @emph{; See the} text-interactor @emph{section of the Interactors Manual}
   (:stop-action #'inter::MultiFont-Text-Int-Stop-Action)
   (:after-cursor-moves-func NIL) @emph{; (lambda (inter text-obj))}
   )
@end example

This interactor was designed to appeal to people familiar with the
@code{inter:text-interactor}. The interactor is started when you click
the mouse on a text object, and it stops when you type the stop-event,
like #\RETURN. The editing commands (listed below) are similar to
@code{inter:text-interactors}'s commands, with many additional ones.

@cindex{drag-through-selection?}
The new slot @code{:drag-through-selection?} controls whether dragging
through the string with the mouse will cause the indicated region to
become selected. You can apply all the standard multifont commands to
a region that is selected this way. Note: since we use "pending-delete"
like the Macintosh, if you type anything when something is selected,
the selected text is deleted. 

@cindex{font changing keys}
@cindex{Editing commands for multifont}
The words in upper case are labelings of the keys
(on the Sun keyboard). If your keyboard has keys labeled differently,
let us know and we will insert them into the code.
@cindex{key bindings}

@table @code
    @item @code{^f ^b ^d ^h}
    = forward, backwards, delete forwards, delete backwards char
    @item @code{leftarrow}, @code{rightarrow}
    =  backwards, forwards
    @item @code{META-f, META-b, META-d, META-h}
    = same but by words
    @item @code{^p}
    = previous line, @item @code{^n}
    = next line
    @item @code{uparrow}, @code{downarrow}
    = previous line, next line
    @item @code{^,} or @code{HOME}
    = beginning of document
    @item @code{^.} or @code{END}
    = end of document
    @item @code{^a}
    = beginning of line
    @item @code{^e}
    = end of line

    @item @code{^k}
    = kill line, @item @code{^u}
    = delete entire string, @item @code{^w}, @code{CUT}
    = delete selection
    @item @code{META-w}, @code{COPY}
    = copy selection to interactor cut buffer
    @item @code{^c}
    = copy entire string to X cut buffer
    @item @code{^y}, @code{PASTE}
    = yank interactor cut buffer or X cut buffer into string
    @item @code{^Y}, @code{^PASTE}
    = yank X buffer
    @item @code{META-y}, @code{META-PASTE}
    = yank interactor cut buffer
@end table

The following ones extend the selection while moving:

@table @code
       @item @code{^leftarrow}, @code{^rightarrow}
       = prev, next char selecting
       @item @code{META-leftarrow}, @code{META-rightarrow}
       = prev, next word selecting
       @item @code{^uparrow}, @code{^downarrow}
       = up-line, down-line selecting
       @item @code{^HOME}, @code{^END}
       = beginning, end of string selecting
       @item @code{^*}
       = select all

   @item @code{CONTROL-META} is Lisp stuff if you have lisp mode on (see below):
       @code{^-META-b}, @code{^-META-leftarrow}
       = prev lisp expression
       @item @code{^-META-f}, @code{^-META-rightarrow}
       =  next lisp expression
       @item @code{^-META-h}, @code{^-META-backspace}, @code{^-META-delete}
       = delete prev s-expr
       @item @code{^-META-d}
       = delete next s-expr

   @item @code{^-shift-} is for font stuff:
       @code{^-shift-B}
       = toggle bold
       @item @code{^-shift-I}
       = toggle italic
       @item @code{^-shift-F}
       = fixed font (courier)
       @item @code{^-shift-T}
       = times font (serif)
       @item @code{^-shift-H}
       = helvetica font (sans-serif)
       @item @code{^-shift-<}
       = smaller font
       @item @code{^-shift->}
       = bigger font
       @item @code{^1 ^2 ^3 ^4}
       = small, medium, large, and very-large fonts
@end table

Of course, you can change the mapping of all these functions, using
the standard @code{inter:bind-key} mechanism described with the regular
@code{text-interactor}.

@subsection Focus Multifont Text Interactor
@node Focus Multifont Text Interactor

@example
@cindex{focus-multifont-textinter}

(create-instance 'inter:Focus-Multifont-Textinter inter:interactor
   (:window NIL)
   (:obj-to-change NIL)
   (:stop-event NIL)
   (:lisp-mode-p NIL)
   (:match-parens-p NIL)
   (:match-obj ...)
   (:final-function NIL)           @emph{; (lambda (inter obj final-event final-string x y))}
   (:after-cursor-moves-func NIL)  @emph{; (lambda (inter text-obj))}
   )
@end example

For applications where one wants the user to be able to type text into a
multifont text object without first having to click on the object, the
@code{focus-multifont-textinter} was created. This interactor provides
a feel more like a text editor. The demo @code{demo-text} shows how to
use the @code{focus-multifont-textinter} to create and edit @code{multifont-text}
objects. The @code{demo-multifont} text editor shows how to use this
interactor along with the @code{selection-interactor} described in the
next section.

Unlike other interactors, this interactor never goes into the "running" state.
The interactor can only "start."  This means that aborting this interactor,
or setting the @code{:continuous} slot to non-@code{NIL} is meaningless. The only
way to stop the interactor is either to deactivate it (set the @code{:active-p}
slot to @code{NIL}) or to destroy it. If two or more of these interactors are in
the same window, all of the interactors will fetch the keyboard events and
send them to their corresponding multifont text objects. Extreme caution
is urged when having two or more focus interactors in the same window to avoid
having keystrokes go to multiple objects. Ways to avoid having keystrokes go
to multiple destinations are to have non-overlapping @code{:start-where}
positions for all the interactors or to make certain that all idle interactors
have their @code{:obj-to-change} slot set to @code{NIL}.

Usually this interactor will continue running until it is destroyed, but you may
want to execute a final function whenever a particular key is pressed.
Whenever the user issues the event specified in the @code{:stop-event} slot
(like #\RETURN), the function in @code{:final-function} is executed.
The parameters to the final-function are the same as for the standard
@code{text-interactor}:
@code{(lambda (an-interactor obj-being-edited final-event final-string x y))}

When a @code{focus-multifont-textinter}
is in a window, all keyboard input will be fed directly into the multifont
text object that is in its @code{:obj-to-change} slot. If the
@code{:obj-to-change} slot is @code{NIL}, then no multifont text object has
the focus.

The @code{inter:focus-multifont-textinter} has the same key bindings as the 
@code{inter:multifont-text-interactor}.

The @code{inter:focus-multifont-textinter} also has several functions that can
be used on it. These functions are used mainly to manipulate the multifont
text that the interactor is focused upon.

@cindex{set-focus}
@example
inter:Set-Focus @emph{interactor multifont-text}@ref{function}
@end example

This function changes the focus of a @code{focus-multifont-textinter} from one
text object to another. The cursor of the newly activately text object will
become visible indicating that it is ready to accept text. The cursor of the
previous text object will become invisible and any selected text will become
unselected. If the @emph{multifont-text} parameter is NIL, then the currently
selected text object will become unselected and no object will have the
focus. This function does not return any useful value.

@cindex{copy-selection}
@cindex{cut-selection}
@cindex{paste-selection}
@example
inter:Copy-Selection @emph{interactor}@ref{function}

inter:Cut-Selection @emph{interactor}@ref{function}

inter:Paste-Selection @emph{interactor}@ref{function}
@end example

These functions perform cut, copy, and paste operations upon the text object
that currently has the focus. The @code{cut-selection} and @code{copy-selection}
operations copy the selected text into the cut-buffer. @code{Cut-selection}
will delete the selected text, but @code{copy-selection} will leave it
unaffected. @code{Paste-selection} inserts the cut buffer at the position of
the cursor.

@subsection Selection Interactor
@node Selection Interactor

@example
@cindex{selection-interactor}

(create-instance 'inter:Selection-Interactor inter:interactor
   (:focus-interactor ...)
   (:match-parens-p NIL)
   (:match-obj ...))
@end example

The @code{selection-interactor} is a complementary interactor to the
@code{focus-multifont-textinter}. The @code{selection-interactor} controls
mouse input so that the user may click and drag the mouse in order to select
text and choose a new multifont object to edit. The @code{:focus-interactor}
slot must be filled with a valid @code{inter:focus-multifont-textinter}
interactor. It is the interactor in that slot that will be used to reset the
focus if a new multifont object is clicked upon. The @code{:start-where} slot
must include all possible multifont objects that the @code{selection-interactor}
operates upon. If a new multifont object is clicked upon the
@code{selection-interactor} will reset the focus to the new object and place the
cursor at the point where the mouse was clicked. If the mouse is clicked in
the multifont object that contains the cursor, the cursor will be moved to
position of the click. Dragging the mouse across a multifont object will
select the text that was passed over by the mouse. Clicking the mouse while
holding the shift key (or clicking the mouse with the right button instead
of the left) causes the selection highlight to extend to the newly clicked
position.

The @code{selection-interactor} uses a key translation table to decode different
types of clicking operations. The current table translates @code{:leftdown}
to @code{:start-selection} and @code{:shift-leftdown} and @code{:rightdown} to
@code{:start-selection-continue}. These combinations can be changed and other
combinations added by using the @code{inter:bind-key} function.


@subsection Lisp Mode
@node Lisp Mode
@anchor{lisp-mode}
@cindex{lisp mode in multifont}

Multifont supports a special text-entry mode which is useful for typing 
Lisp functions or programs. This mode can be used by setting the 
@code{:lisp-mode-p} slot of the @code{multifont-text-interactor} or 
@code{focus-multifont-textinter} to T. When in lisp mode, lines of text will 
tab to the appropriate spot, and semicolon comments will appear in italics. 
It is important that the fonts of the text are not changed during lisp-mode,
since certain fonts hold special meaning for tabs and parenthesis-matching. 

@sp 1
@cindex{indent in lisp-mode}
@example
inter:Indent @emph{string how-many how-far}@ref{function}
@end example

This function can be used to define a special indent amount for your
own function. The  
argument @emph{string} is the name of the function, @emph{how-many} is the number  
of arguments (starting with the first) that should be indented the special 
amount, and @emph{how-far} is an integer signifying how many spaces from the 
start of the function name these special arguments should be placed. If 
@emph{how-far} is -1, then the indent will line up with the first argument on the 
line above it. The argument following the last special argument will be 
placed one space in from the start of the function name, and all following 
arguments will line up with the first argument on the line above it.
Here are some examples of the default indentations:

@sp 1

@example
(indent "defun" 2 4)

(indent "create-instance" 2 4)

(indent "let" 1 4)

(indent "do" 2 -1)

(indent "cond" 0)

(indent "define-method" 3 4)
@end example


There are several keys which are bound specially during lisp mode:

@table @code
@cindex{key descriptions}
@item @code{^-META-f}, @code{^-META-rightarrow}
= skip forward lisp expression

@item @code{^-META-b}, @code{^-META-leftarrow}
= skip backward lisp expression

@item @code{^-META-d}
= delete lisp expression

@item @code{^-META-h}, @code{^-META-backspace}
= delete previous lisp expression
@end table

@cindex{match-parens-p}
@cindex{parenthesis matching}
Also helpful in lisp mode is setting the @code{:match-parens-p} of the 
interactors to T. When the cursor is next to a close parenthesis, the
corresponding open parenthesis will be highlighted in boldface. Also, if 
the interactors' @code{:match-obj} is set to another multifont object, that 
object's text will be set to the text of the line that the matching 
open parenthesis is on.

@cindex{turn-off-match}
@example
inter:Turn-Off-Match @emph{interactor}@ref{function}
@end example

This function can be used to externally turn off a matched parenthesis, since 
it will only be automatically turned off when the cursor is moved away from the
close parenthesis.


@cindex{add-lisp-char}
@cindex{delete-lisp-region}
@example
inter:Add-Lisp-Char @emph{text-obj char} &optional @emph{new-font new-foreground-color new-background-color}@ref{function}

inter:Delete-Lisp-Region @emph{text-obj}@ref{function}
@end example

Because lisp mode does some extra things during addition and deleting of text, 
these special functions should be used when in lisp mode in the place of 
@code{opal:add-char} and @code{opal:delete-selection}. If changes are made 
externally without using these functions, future tabs and parenthesis-matching 
may not work properly. Note: you can also use the @emph{lisp-mode-p} parameter
of @code{opal:add-char} and @code{opal:delete-selection} to indicate that the
operation is taking place while lisp-mode is active.

@sp 1
@cindex{lispify}
@example
inter:Lispify @emph{string}@ref{function}
@end example

This function takes a plain string and will return text which will work in 
lisp mode. The returned text is in @code{:initial-text} format, and can be used
with functions such as @code{set-text}. The text will already be indented and 
italicized properly.

@subsection Auto-Scrolling Multifont Text Objects
@node Auto-Scrolling Multifont Text Objects
@cindex Auto scroll
@cindex opal:multifont-text

A companion to the word-wrap feature is the vertical auto scroll feature.
The auto scroll option can be utilized when a multifont-text object is
used inside a scrolling-window along with a focus-multifont-textinter,
multifont-text-interactor, or selection-interactor.

The interface for auto-scrolling @code{opal:multifont-text} is the same as for
@code{opal:text}, which is described in section @ref{auto-scroll}

@subsection After Cursor Moves
@node After Cursor Moves
@cindex{after-cursor-moves-func}
To support lisp-mode, there is a slot of the three multifont
interactors (@code{multifont-textinter}, @code{focus-multifont-textinter},
@code{selection-interactor}) called @code{:after-cursor-moves-func}. If
non-NIL, it should be a function called as @code{(lambda (inter text-obj))}
and will be called whenever the cursor moves, or the
text to the left of the cursor changes.

If the function in this slot is overridden with a user-supplied function,
the new function should do a @code{(call-prototype-method ...)} to ensure
that the default lisp-mode indentation function is executed, also.

@subsection A Multifont Text Gadget
@node A Multifont Text Gadget
@anchor{multifontgadgetsec}

Putting a gadget description into the Opal section is fairly
strange. Just as the interactors section above, it was decided that the
@code{multifont-gadget} should be described in the
@code{multifont-text} section.

@example
@cindex{multifont-gadget}

(create-instance 'gg:Multifont-Gadget opal:aggregadget
   (:left 0)
   (:top 0)
   (:initial-text (list ""))
   (:fill-background-p NIL)
   (:word-wrap-p NIL)
   (:text-width 300)
   (:stop-event NIL)
   (:selection-function NIL))
@end example

This gadget is @b{not} automatically loaded by the
@code{multifont-loader}. Instead, you should load
@code{multifont-gadget-loader} from the gadgets directory to load the
gadget and all of the required multifont files.

The @code{multifont-gadget} is a conglomeration of a @code{multifont-text},
a @code{focus-multifont-textinter}, and a @code{selection-interactor}.
These are all put together to take some of the trouble out of assembling the
pieces by hand. The slots of the gadget are the same as the
@code{multifont-text}. To use the gadget just create it and go. The keyboard
and mouse handling are built in. The trouble with this gadget is that you
cannot have more than one @code{multifont-gadget} per window. If you have more
than one, all the gadgets will receive the same keystrokes; thus, all the
gadgets will respond to the keyboard at the same time.

Usually the gadget will continue running until it is destroyed, but you may
want to execute a selection function whenever a particular key is pressed.
Whenever the user issues the event specified in the @code{:stop-event} slot
(like #\RETURN), the function in @code{:selection-function} is executed. The
selection function takes the usual parameters (the gadget and its value), where
the value is the pure text representation of the gadget's current string.

There is a small demo of how to use the multifont text gadget in the
gadget file. To run it, execute @w[@code{(garnet-gadgets:multifont-gadget-go)}].

@section Aggregate objects
@node Aggregate objects

@anchor{aggregates}
Aggregate objects hold a collection of
other graphical objects (possibly including other aggregates). The objects
in an aggregate are called its @emph{components} and the aggregate is the
@emph{parent} of each component. An aggregate itself has no filling or
border, although it does have a left, top, width and height.

Note: When you create an aggregate and add components to it, creating an
instance of that aggregate afterwards does @emph{not} create instances of the
children. If you use Aggregadgets instead, then you @emph{do} get copies
of all the components. Aggregadgets also provide a convenient syntax for
defining the components. Therefore, it is often more appropriate to use
Aggregadgets than aggregates. See the Aggregadgets manual
@cite{AggregadgetsManual}.

@subsection Class Description
@node Class Description
@anchor{agg-class}
@example

@cindex{aggregate}

(create-instance 'opal:Aggregate opal:view-object
  (:components NIL)
  (:hit-threshold 0)
  (:overlapping T))
@end example

@cindex{components}
The @code{:components} slot holds a list of the graphical objects that are
components of the aggregate. @i{This slot should
not be set directly but rather changed using @code{add-component} and
@code{remove-component} (section @ref{addremsection}).}
The covering (which is the ordering among children) in the
aggregate is determined by the order of components in the @code{:components}
slot. @b{The list of components is stored from bottommost to topmost.}  This
slot cannot be set directly.

@cindex{hit-threshold}
@cindex{set-aggregate-hit-threshold}
@example
opal:Set-Aggregate-Hit-Threshold @emph{agg}@ref{function}
@end example
As is the case with graphical objects, the @code{:hit-threshold} slot of an
aggregate controls the sensitivity of the @code{point-in-gob} methods to hits
that are near to that aggregate. The value of the @code{:hit-threshold} slot
defaults to 0, but calling @code{set-aggregate-hit-threshold}
sets the @code{:hit-threshold} of an aggregate to be the maximum of all
its components.

@cindex{overlapping}
The @code{:overlapping} slot is used as a hint to the aggregate as to whether
its components overlap. This property allows the aggregate to redraw it's
components more efficiently. You can set the @code{:overlapping} slot to @code{nil}
when you know that the first level children of this aggregate will never
overlap each other on the screen. @emph{Currently, this slot is not used, but
it may be in the future.}

Aggregates have a bounding box, which, by default, is calculated from the
sizes and positions of all its children. If you want to have the position
or size of the children depend on that of the parent, it is important to
provide an explicit value for the position or size of the aggregate, and
then provide formulas in the components that depend on the aggregate's
values. Be careful to avoid circularities: either the aggregate should
depend on the sizes and positions of the children (which is the default)
@b{or} the children should depend on the parent. These cannot be easily
mixed in a single aggregate. It is important that the size and position of
the aggregate correctly reflect the bounding box of all its components, or
else the redisplay and selection routines will not work correctly.


@subsection Insertion and Removal of Graphical Objects
@node Insertion and Removal of Graphical Objects
@anchor{addremsection}

@sp 1
@cindex{add-component}
@example
opal:Add-Component @emph{aggregate graphical-object} [[:where] @emph{position}[@i{locator}]]@ref{method}
@end example

The method @code{add-component} adds @emph{graphical-object} to @emph{aggregate}. The
@emph{position} and @emph{locator} arguments can be used to adjust the
placement/covering of @emph{graphical-object} with respect to the rest of the
components of @emph{aggregate}.
@sp 1

@cindex{position}
@cindex{front}
@cindex{back}
@cindex{behind}
@cindex{in-front}
@cindex{at}
There are five legal values for @emph{position}; these are: @code{:front},
@code{:back}, @code{:behind}, @code{:in-front}, and @code{:at}. Putting an object
at the @code{:front} means that it is not covered by any other objects in
this aggregate, and
at the @code{:back}, it is covered by all other objects in this aggregate.
Positioning @emph{graphical-object} at either @code{:front} or @code{:back}
requires no value
for @emph{locator}, as these are unique locations. If position is either
@code{:behind} or @code{:in-front} then the value of @emph{locator} should be a
graphical object already in the component list of the aggregate, in which
case @emph{graphical-object} is placed with respect to @emph{locator}. In the
final case, with @emph{position} being @code{:at}, @emph{graphical-object} is placed
at the @emph{locator}th position in the component list, where 0 means at
the head of the list (the back of the screen).

If none are supplied, then the new object is
in front of all previous objects. The @code{:where} keyword is optional
before the locators, so all of the following are legal calls:
@example
(opal:add-component agg newobj :where :back)
(opal:add-component agg newobj :back)
(opal:add-component agg newobj)       @emph{; adds newobj at the :front}
(opal:add-component agg newobj :behind otherobj)
(opal:add-component agg newobj :at 4)
@end example

Objects cannot belong to more than one aggregate. Attempting to add a
component of one aggregate to a second aggregate will cause Opal to signal
an error. If the @emph{locator} for @code{:behind} or @code{:in-front} is not a
component of the aggregate Opal will also signal an error.

@sp 1
@cindex{add-components}
@example
opal:Add-Components @i{aggregate} &rest @i{graphical-objects}@ref{function}
@end example

This function adds multiple components to an aggregate. Calling
this function is equivalent to:

@example
(dolist (gob (list {@emph{graphical-object}}@+[*]))
   (add-component @i{aggregate} gob))
@end example

An example of using @code{add-components} is:
@example
(opal:add-components agg obj1 obj2 myrect myarc)
@end example

Note that this has the effect of placing the list of graphical objects from
back to front in @i{aggregate} since it inserts each new object with the
default @code{:where :front}.

@cindex{remove-component}
@example
opal:Remove-Component @emph{aggregate graphical-object}@ref{method}
@end example

The @code{remove-component} method removes the
@emph{graphical-object} from @emph{aggregate}. If @i{aggregate} is connected to
a window, then @i{graphical-object} will be erased when the window next has
an update message (section @ref{windowfuncs}) sent to it.

@cindex{remove-components}
@example
opal:Remove-Components @emph{aggregate} &rest @emph{graphical-object}@ref{function}
@end example

Removes all the listed components from @i{aggregate}.

@cindex{move-component}
@example
opal:Move-Component @emph{aggregate graphical-object} [[:where] @emph{position}[@i{locator}]]@ref{method}
@end example

@code{Move-component} is used to change the drawing order of objects in an
aggregate, and therefore change their covering (since the order of objects
in an aggregate determines their drawing order). For example, this function
can be used to move an object to the front or back. The object should
already be in the aggregate, and it is moved to be at the position specified.
It is like a @code{remove-component} followed by an @code{add-component} except
that it is more efficient. The parameters are the same as @code{add-component}.


@subsection Application of functions to components
@node Application of functions to components

There are two methods defined on aggregates to apply functions to some
subset of the aggregate's components. The methods work on either the
direct components of the aggregate or all objects that are either direct or
indirect components of the aggregate.

@cindex{do-components}
@example
opal:Do-Components @emph{aggregate function} &key @emph{type self}@ref{method}
@end example

The @code{do-components} method applies @emph{function} to all components of
@emph{aggregate} in back-to-front order. The @emph{function} should take one
argument which will be the
component. If a type is specified, the function is only applied to
components that are of that type. If the call specifies @code{:self} to be @c[t]
(the default is @code{nil}), and the aggregate is of the specified type,
then the function is applied to @emph{aggregate} after being applied to
all of the components.

The @emph{function} must be non-destructive, since it will be applied to the
components list of @emph{aggregate}, not to a copy of the components
list. For instance, @emph{function} cannot call @emph{remove-component} on
the components. If you want to use a @emph{function} that is
destructive, you must make a copy of the components list and call
dolist yourself.

@sp 1
@cindex{do-all-components}
@example
opal:Do-All-Components @emph{aggregate function} &key @emph{type self}@ref{method}
@end example

The @code{do-all-components} method works similarly to @code{do-components},
except that in the case that a component is an aggregate,
@code{do-all-components} is first called recursively on the component
aggregate and then applied to the component aggregate itself.
@code{Self} determines whether to call the function on the top level
aggregate (default=@code{nil}) after all components.

@subsection Finding objects under a given point
@node Finding objects under a given point
@anchor{querying-children}

@cindex{point-to-component}
@sp 1
@example
opal:Point-To-Component @emph{aggregate x y} &key @emph{type}@ref{method}

@cindex{point-to-leaf}
opal:Point-To-Leaf @emph{aggregate x y} &key @emph{type}@ref{method}
@end example

@code{Point-to-component} queries the aggregate for the first generation
children at point (@emph{x},@emph{y}). The value of @emph{type} can limit the search to
graphical objects of a specific type. This function returns the topmost
object at the specified point (@emph{x},@emph{y}).

@code{Point-to-leaf} is similar except that the query continues to the deepest
children in the aggregate hierarchy (the leaves of the tree). Sometimes you
will want an aggregate to be treated as a leaf in this search, like a button
aggregate in a collection of button aggregates. In this case, you should set
the @cindex{pretend-to-be-leaf} @code{:pretend-to-be-leaf} slot of each
aggregate that should be treated like a leaf. The search will not
proceed through the components of such an aggregate, but will return
the aggregate itself.

The @emph{type} slot can be either @code{t} (the default), a type, or a list
of types. 
If @emph{type} is specified as an atom, only objects that are of that
@emph{type} will be tested. If @emph{type} is specified as a list, only
objects whose type belongs to that list will be tested.
The value @code{t} for @emph{type} will match all objects. If the @emph{type} is
specified for a @code{point-to-leaf} call, and the @code{type} is a kind of
aggregate, then the search will stop when an aggregate of that type (or
types) is found at the specified (x,y) location, rather than going all
the way to the leaves. For example:
@example
(create-instance 'MYAGGTYPE opal:aggregate)
(create-instance 'MYAGG MYAGGTYPE)
(create-instance TOP-AGG opal:aggregate)
(opal:add-component TOP-AGG MYAGG)

(create-instance OBJ1 ...)
(create-instance OBJ2 ...)
(opal:add-components MYAGG OBJ1 OBJ2)

(opal:point-to-leaf TOP-AGG x y) ;@i{will return obj1, obj2, or NIL}
(opal:point-to-leaf TOP-AGG x y :type MYAGGTYPE) ;@i{will return MYAGG or NIL}
@end example

@cindex{point-in-gob}
@code{Point-to-leaf} and @code{point-to-component} always use the function
@code{point-in-gob} on the components.



@subsection Finding objects inside rectangular regions
@node Finding objects inside rectangular regions
@anchor{rect-regions}
@cindex{components-in-rectangle}

@sp 1
@example
opal:Components-In-Rectangle @emph{aggregate  top  left  bottom  right} &key @emph{type  intersect}@ref{function}
@end example

@cindex{leaf-objects-in-rectangle}
@example
opal:Leaf-Objects-In-Rectangle @emph{aggregate  top  left  bottom  right} &key @emph{type  intersect}@ref{function}
@end example

@cindex{obj-in-rectangle}
@example
opal:Obj-In-Rectangle @emph{object  top  left  bottom  right} &key @emph{type intersect}@ref{function}
@end example

The routine @code{components-in-rectangle} queries the aggregate for the first
generation children that intersect the rectangle bounded by @emph{top}, @emph{left},
@emph{bottom}, and @emph{right}. If @emph{intersect} is @code{nil}, then the
components which 
are returned must be completely inside the rectangle, whereas if
@emph{intersect} is non-@code{nil} (the default), then the components need only
intersect the rectangle. The value of @emph{type} can limit the search
to graphical objects of a specific type. 
@sp 1


@code{Leaf-objects-in-rectangle} is similar except that the query
continues to the deepest children in the aggregate hierarchy (the
leaves of the tree). Sometimes you will want an aggregate to be
treated as a leaf in this search, like a button aggregate in an
aggregate of buttons. In this case, you should set the
@cindex{pretend-to-be-leaf} @code{:pretend-to-be-leaf} slot of each
aggregate that should be treated like a leaf. The search will not
proceed through the components of such an aggregate, but will return
the aggregate itself.

@code{Obj-in-rectangle} tells whether the bounding box of @emph{object}
intersects the rectangle bounded by @emph{top}, @emph{left}, @emph{width} and
@emph{height}. If @emph{intersect} is non-@code{nil} (the default) 
then @emph{object} need only intersect the rectangle, whereas if
@emph{intersect} is @code{nil} then @emph{object} must lie completely inside the
rectangle. If @emph{type} is not @code{t} (the default) then @emph{object} must be
of type @emph{type}. 

@section Virtual-Aggregates
@node Virtual-Aggregates
@cindex{virtual-aggregates}

@emph{Virtual-aggregates} are used when you are going to create a very large
number of objects (e.g., 300 to 50,000) all of which are fairly similar.
For example, they are useful for points in a scatter plot, squares in
a "fat-bits" bitmap editor, line segments in a map, etc. The virtual
aggregate @emph{pretends} to provide an object for each element, but actually
doesn't. This can save an enormous amount of memory and time, while
still providing an interface consistent with the rest of Garnet.

The primary restriction is that there cannot be references or
constraints from external objects @emph{to} or @emph{from} any of the
elements of the virtual-aggregate. Typically, all the constraints
will be internal to each object displayed, and all the properties will
be determined by the values in the @code{:items} array.

The interface is similar to @emph{aggrelists}. The programmer provides an
item-prototype, used for all the elements, and an (optional) items
list to form the initial value. To be more efficient, the items list
is actually an array for virtual-aggregates. The item-prototype can
be an arbitrary object or aggregadget structure, and can use whatever
formulas are desired to calculate the appropriate display based on the
corresponding value of the items list and the object's rank in the
item's list.

We have implemented two styles of virtual-aggregates, with
a third style in planning.
The first style is for arbitrary overlapping objects, and is described
below. The second style is for non-overlapping 2-D arrays of objects,
such as bitmap-editor tiles. 

The third style is like the first, for arbitrary overlapping objects.
However, unlike the first style, it would use more sophisticated
techniques for computing the overlapping of objects, rather than using
linear search like the first style. For example, it might use
quad trees or whatever.

So far, we have implemented the first and second style only. Examples
of using these virtual-aggregates are in demo-circle for the first
style and demo-array for the second.

@subsection Virtual-Aggregates Slots
@node Virtual-Aggregates Slots

A virtual-aggregate is a graphical object, with its own @code{:draw},
@code{:point-to-component}, @code{:add-item}, and @code{:remove-item} methods.
It is defined as:
@example
(create-instance 'opal:virtual-aggregate opal:graphical-object
    ...
   (:item-prototype ...)  @emph{;; you must provide this}
   (:point-in-item ...)   @emph{;; you must provide this}
   (:item-array ...)      @emph{;; you may provide this}
   (:dummy-item ...)
   )
@end example

For example, in demo-circle the virtual-aggregate is:

@example
    (create-instance NIL opal:virtual-aggregate
       (:item-prototype MY-CIRCLE)
       (:point-in-item #'My-Point-In-Circle))
@end example

Here are the slots you must provide for a virtual-aggregate.

@b{:ITEM-PROTOTYPE}@*
In the :item-prototype slot, you put the Garnet object of your choice
(primitive object or aggregadget). You must, however, have formulas
in your :item-prototype object that depend on its
@code{:item-values} and/or @code{:rank} slot. The @code{:rank} is set with
the object's rank in the @code{:items} array. The @code{:item-values} is
set with the appropriate data from the @code{:item-array}. For instance, in
demo-circle, the item-prototype is:

@example
(create-instance 'MY-CIRCLE opal:circle
   (:filling-style (o-formula (fourth (gvl :item-values))))
   (:radius (o-formula (third (gvl :item-values))))
   (:left (o-formula (- (first (gvl :item-values)) (gvl :radius))))
   (:top (o-formula (- (second (gvl :item-values)) (gvl :radius))))
   (:width (o-formula (* 2 (gvl :radius))))
   (:height (o-formula (gvl :width))))
@end example

In this case the @code{:item-values} slot contains a list of four numbers:
the x and y coordinates of the center of the circle, the radius of the
circle, and an Opal color. 
For your item-prototype, the format for
the item-values data can be anything you like, and you don't have to
set the @code{:item-values} slot yourself: Opal will do that for you.

@sp 1
@b{:POINT-IN-ITEM}@*
This slot contains a function of the form
@example
(lambda (virtual-aggregate item-values x y) ...)
@end example
which returns @code{t} or @code{nil} depending on whether the point <x,y> lies within
an @code{:item-prototype} object with @code{:item-values} item-values.
Typically, you will be able to compute this function efficiently based
on your knowledge of the how the objects will look.
For instance, in demo-circle, the @code{:point-in-item} slots contains:

@example
(lambda (virtual-aggregate item-values x y)
  (<= (+ (expt (- x (first item-values)) 2)
         (expt (- y (second item-values)) 2))
      (expt (third item-values) 2)))
@end example

@b{:ITEM-ARRAY}@*
This is a slot you @emph{may}, but need not provide. If you don't provide
one, then all of the items will be added using the add-item function, below.
@code{:item-array} contains either a 1-dimensional array of item-values, ordered
from back to front on your display, or a 2-dimensional array. So for the
demo-circle example, it will look something like:
@example
#((304 212 12 #k<RED-FILL>)
  (88 64 11 #k<GREEN-FILL>)
  ...)
@end example
The array may have @code{nil}s in it. Each @code{nil} represents a gap in this items
list.

@subsection Two-dimensional virtual-aggregates
@node Two-dimensional virtual-aggregates
You can create a virtual-aggregate whose @code{:item-array} is a @emph{two}
dimensional array. The formulas in the @code{:dummy-item} of the aggregate
must depend on two slots @code{:rank1} and @code{:rank2} instead of the single
slot @code{:rank}. This is useful for non-overlapping tables, such as
bitmap editors (fat-bits), spreadsheets, etc. See the example in
demo-array.


@subsection Manipulating the Virtual-Aggregate
@node Manipulating the Virtual-Aggregate
These are the routines exported by Opal that you can use to manipulate
the item array:

@cindex{add-item}
@example
opal:Add-Item @emph{a-virtual-aggregate  item-values}@ref{method}
@end example

This adds a new item to the @code{:item-array} of @emph{a-virtual-aggregate}.
@emph{Item-values} is a list containing the values for an @code{:item-values} slot
of the item-prototype. @code{Add-item} returns the rank into the
@code{:item-array} where the new item was inserted. The
@code{:item-array} must be one-dimensional. 

@cindex{remove-item}
@example
opal:Remove-Item @emph{a-virtual-aggregate  rank}@ref{method}
@end example
  This removes an item from the @code{:item-array} of @emph{a-virtual-aggregate}.
Actually, it puts a @code{nil} in the @code{:item-array} (it does not compress the
array). The @code{:item-array} must be one-dimensional.

@cindex{change-item}
@example
opal:Change-Item @emph{a-virtual-aggregate  new-item  rank} &optional @emph{rank2}@ref{method}
@end example
This changes the @emph{rank}'th entry of the @code{:item-array} of the
virtual-aggregate to be @emph{new-item}. (It also marks that item to be
redrawn at the next update). To manipulate a two-dimensional array, use
@emph{rank} and @emph{rank2} as the two indices. Note: you have to use
this function and cannot directly modify the items array after the
virtual-aggregate has been displayed.

@cindex{point-to-rank}
@example
opal:Point-To-Rank @emph{a-virtual-aggregate  x  y}@ref{method}
@end example

Returns the rank of the front-most item in the virtual-aggregate
that contains point <x,y>. (This is why you had to supply @code{:point-in-item}.)
The virtual-aggregate must be one-dimensional.

@cindex{point-to-component}
@example
opal:Point-To-Component @emph{a-virtual-aggregate  x  y}@ref{method}
@end example
  This is like @code{point-to-rank}, but it returns an actual Opal object.
However, the object is actually a dummy object with the appropriate
value placed in its @code{:item-values} and @code{:rank} slots. So you cannot call
Point-to-component twice and hope to hold on the first value.
(The virtual-aggregate must be one-dimensional.)

@cindex{recalculate-virtual-aggregate-bboxes}
@example
opal:Recalulate-Virtual-Aggregate-Bboxes @emph{a-virtual-aggregate}@ref{function}
@end example
  The purpose of this routine is to re-initialize all the bounding
boxes of the items of the virtual-aggregate. This would come in
handy if, for instance, you created a virtual-aggregate whose items
depended for their position on the position of the virtual-aggregate
itself. After you changed the @code{:left} or @code{:top} of the
virtual-aggregate,
you would call @code{recalculate-virtual-aggregate-bboxes} to re-calculate
the bounding boxes of the items.


There is a macro for performing operations iteratively on
elements of a 2-dimensional virtual-aggregate:
@cindex{do-in-clip-rect}
@example
opal:Do-In-Clip-Rect (@emph{var1  var2  a-virtual-aggregate  clip-rect}) &body @emph{body}@ref{macro}
@end example
The variables @emph{var1} and @emph{var2} take on all values for which the item with
@code{:rank1} = @emph{var1} and @code{:rank2} = @emph{var2} intersect the
clip-rectangle @emph{clip-rect}.
The @emph{clip-rect} is a list of left, top, width, and height -- the kind of
argument that is returned from a two-point-interactor.

As an example, consider the following code borrowed from demo-array:
@example
(defun Whiten-Rectangle (dum clip-rect)
  (declare (ignore dum))
  (do-in-clip-rect (index-1 index-2 the-array clip-rect)
    (change-item the-array 1 index-1 index-2)))

(create-instance 'WHITER inter:two-point-interactor
   (:start-event :leftdown)
   (:continuous T)
   (:start-where `(:in ,The-Array))
   (:window w)
   (:feedback-obj FEED-RECT)
   (:final-function #'Whiten-Rectangle))
@end example
The-array is a 2-dimensional virtual-aggregate. The routine
@code{Whiten-Rectangle}
performs @code{opal:change-item} on every element of the-array that is
inside the clip-rect (the second argument to the @code{:final-function} of
a two-point interactor is always a rectangle).



This is a macro for performing operations iteratively on
elements of a 2-dimensional virtual-aggregate. The variables @emph{var1} and
@emph{var2} take on all values for which the item with @code{:rank1} = @emph{var1} and
@code{:rank2} = @emph{var2} intersect the clip-rectangle clip-rect. The clip-rect
is a list of left, top, width, and height -- the kind of argument
that is returned from a two-point-interactor.

@section Windows
@node Windows

@anchor{windows}
@cindex{window} 

Graphical objects can only display themselves in a @emph{window}. 

@example
(create-instance 'inter:Interactor-Window opal::window
  (:maybe-constant '(:left :top :width :height :visible))
  (:left 0)
  (:top 0)
  (:width 355)
  (:height 277)
  (:border-width 2)
  (:left-border-width ...) (:top-border-width ...)     @emph{;; Read-only slots -- Do not set!}
  (:right-border-width ...) (:bottom-border-width ...) @emph{;; See section @ref{border-widths}.}
  (:max-width NIL) (:max-height NIL)
  (:min-width NIL) (:min-height NIL)
  (:cursor opal:Arrow-Pair)    @emph{;; Shape of the pointer in this window. (See section @ref{window-cursors}).}
  (:position-by-hand NIL)
  (:title "Opal @emph{N}")
  (:omit-title-bar-p NIL)
  (:icon-title "Opal @emph{N}")
  (:icon-bitmap NIL)
  (:draw-on-children NIL)
  (:background-color NIL)
  (:double-buffered-p NIL)
  (:save-under NIL)
  (:aggregate NIL)
  (:parent NIL)
  (:visible ...)
  (:modal-p NIL)               @emph{;; Whether to suspend input while visible. See the Interactors Manual.}
  (:in-progress NIL)           @emph{;; Read by }opal:update-all@emph{. See section @ref{quarantine-slot}.}
  ...)
@end example

@b{Caveats:}
@itemize
Garnet windows will not appear on the screen until they are
updated, by calling the functions @code{opal:update} or @code{opal:update-all}.
These functions will also cause all of the graphics in the window to be
brought up-to-date.

Windows are not usually used as prototypes for other windows. If a window
is created with its @code{:visible} slot set to T, then it should be expected
to appear on the screen (even if @code{opal:update} is not explicitly called
on it). When similar windows need to be generated, it is recommended that
a function be written (like at the end of the Tutorial) that will return
the window instances.
@end itemize


@cindex{top}
@cindex{left}
@cindex{width}
@cindex{height}
The @code{:left}, @code{:top}, @code{:width}, and @code{:height} slots of the
window control its position and dimensions.
These slots can be set using @code{s-value} to change the window's
size and position (which will take affect after the next @code{update} call).
If the user changes the size or position of a window using the window manager
(e.g., using the mouse), this will @emph{usually} be reflected in the values
for these slots.@footnote{There are bugs in some window managers that make
this difficult or impossible.}  Some special issues involving the position and
dimensions of Garnet windows when adorned with window manager title bars are
discussed in section @ref{border-widths}.

@cindex{min-width}
@cindex{max-width}
@cindex{min-height}
@cindex{max-height}
If you create a window with values in its @code{:max-width}, @code{:max-height},
@code{:min-width}, and @code{:min-height}, then the window manager will make sure
the user doesn't change the
window's size to be outside of those ranges. However, you can
still @code{s-value} the @code{:width} and @code{:height} of @code{win} to be
any value. The slots @code{:max-width} and @code{:max-height} can only be
set at creation time. Furthermore, due to peculiarities in X windows, you
must set @emph{both} @code{:max-width} and @code{:max-height} 
to be non-@code{nil} at creation time to have any effect.
The slots @code{:min-width} and @code{:min-height} behave in the analogous
manner. 

@cindex{title}
The @code{:title} slot contains a string specifying the title of the Garnet
window. The default title is "Opal @emph{N}", where @emph{N} starts at 1, and
increments each time a new window is created in that Lisp.

@cindex{omit-title-bar-p}
The @code{:omit-title-bar-p} slot tells whether or not the Garnet window should
have a title bar. If the slot has value @code{nil} (the default), and the window
manager permits it, then the window will have a title bar; otherwise the
window will not have a title bar.

@cindex{icon-title}
The @code{:icon-title} slot contains a string specifying the icon title
of the window. The default icon title is the same as the
@code{:title.}  This is the string that gets displayed when a window is
iconified. 

@cindex{icon-bitmap}
You may set the icon of a window to be an arbitrary bitmap by setting
its @code{:icon-bitmap} slot. The value should be a filename which
specifies the location of a bitmap file.

@cindex{draw-on-children}
In the rare case when you want to have graphics drawn on a parent
window appear over the enclosed (child) windows, you can set the
@code{:draw-on-children} of the parent to be non-@code{nil}.
Then any objects that belong to that window will appear on top of
the window's subwindows (rather than being hidden by the subwindows).
Note:  Because of the inability to redraw the graphics in the window and the
subwindows simultaneously, objects that will appear over the subwindows must
be fast-redraw objects drawn with @code{:xor}
(see section @ref{fast-redraw-objects}).

@cindex{background-color}
The @code{:background-color} slot of an @code{inter:interactor-window} can be set
to be any @code{opal:color}. The window will then appear with that as its
background color. This is more efficient than putting a rectangle
behind all the objects.

@cindex{double-buffered-p}
When the @code{:double-buffered-p} slot is T, then an exact copy of the window
will be maintained internally by Garnet. Then, when the graphics in the window
change, the change occurs first in the copy, and then the changed region is
transferred as a pixmap to the original window. This has the potential to
reduce flicker in the redrawing of the window. By default, windows do not use
this feature because of the extra memory required by the internal buffer.

@cindex{save-under}
When the @code{:save-under} slot is T, then Garnet internally stores the
contents of the screen under the window. If the window is made invisible,
then Garnet does not have to redraw any Garnet windows under it, because the
image can simply be redrawn from the saved contents. This option is used in
the @code{menubar} and @code{option-button} gadgets.

@cindex{aggregate}
The @code{:aggregate} slot specifies an aggregate object to hold all the
objects to be displayed in the
window. Each window must contain exactly one aggregate in this slot, and
all objects in the window should be put into this aggregate. This
slot should be set after the window is created, not during the
@code{create-instance} call. This will ensure that the proper demons
are running when the slot is set.
@b{Performance hint: specify the top, left, width and height of this
aggregate to be formulas depending on the window, rather than using the
default formulas, which depend on all of the objects in the aggregate}.

@cindex{visible}
The @code{:visible} slot specifies if the window is currently visible on the
screen or not. In X terminology, this
determines if the window is mapped or not. You can set the @code{:visible}
slot at any time to change the visibility (which will take effect after an
@code{update} call).

@cindex{position-by-hand}
If you create a window and set the @code{:position-by-hand} slot to be
T, then when you call @code{opal:update} the first time, the cursor on your
screen will change to a
prompt asking you where to position the window, and the initial values of
@code{:left} and @code{:top} will be ignored.

@cindex{parent}
If a window is created with a window object in its @code{:parent} slot, then
the new window will be a sub-window of the parent window.
Each window sets up its own coordinate system, so the @code{:left} and
@code{:top} of the subwindow will be with respect to the parent window.
@b{The parent window must be updated before the subwindow is created.}
Using @code{nil} for the @code{:parent} makes the window be at the top level. Only
top-level windows can be manipulated by the window manager (i.e, by using
the mouse).



@subsection Window Positioning
@node Window Positioning

When top-level windows first become visible, their @code{:left} and @code{:top}
slots may change values slightly to accomodate the title bars added by the
window manager. When you create a
regular top-level window with a @code{:top} of 100, for example, the inside
edge of the window will appear at 100. The window manager frame of
the window (the outside edge) will appear a little higher, depending on
the window manager, but somewhere around 25 pixels higher.
The window manager then notifies Garnet that this frame has been added by
changing the @code{:top} of the window to 75. The drawable region of the window
remains at 100.

When the @code{:top} of the window is changed (via @code{s-value}) after it is
visible, then it is the outside edge of the window that is being changed,
which is the top of the frame.
You can always determine the height of the window's title bar in the
@code{:top-border-width} slot (see section @ref{border-widths}).
There are corresponding slots for @code{:left-}, @code{:right-}, and
@code{:bottom-border-width}. All of these slots are read-only,
and are set by Garnet according to your window manager.

When stacking windows in a cascading arrangement, it is
sufficient to be consistent in setting their positions either before or
after updating them. If the two kinds of position-setting strategies need to
be mixed, then the @code{:top-border-width} of the windows that have already
been made visible should be taken into account, versus those that have
never been updated.


@subsection Border Widths
@node Border Widths
@anchor{border-widths}

There are two different meanings of "border widths" in windows. One involves
the user-settable thickness of subwindows, and the other kind involves
@emph{read-only} widths that are determined by the window manager:

@itemize
@cindex{border-width}
@b{Subwindow Border Width} - The @code{:border-width} slot affects the width
of the border on a subwindow.
Setting the @code{:border-width} slot of a subwindow to 0 during its
@code{create-instance} call will cause the window to have no border at all,
but setting it to a value larger than the default usually has no effect.
Currently, the border width cannot be changed after the window is created.

@cindex{left-border-width}
@cindex{right-border-width}
@cindex{top-border-width}
@cindex{bottom-border-width}
@b{Window Manager Frame Widths} - After a window has been created, the
@code{:left-border-width}, @code{:right-border-width},
@code{:top-border-width}, and
@code{:bottom-border-width} slots tell what thicknesses the left, right, top,
and bottom borders of the windows actually have. These slots are set
by the window manager, and should @b{not} be set by Garnet users.
@end itemize


@subsection Window Cursors
@node Window Cursors
@anchor{window-cursors}
@cindex{cursor (pointer)}
@cindex{pointer}

The default cursor shape for Garnet windows is an arrow pointing to the
upper left. However, it would be nice to change this shape sometimes,
particularly when an application is performing a long computation and you
would like to display an hourglass cursor. Several functions and objects
make it easy to change the cursors of Garnet windows.

The following sections discuss how to change window cursors, starting with
some background at the lowest level of the cursor interface. The later
sections, particularly @ref{with-hourglass-sec}, describe the high-level
functions that allow you to change the cursor with a single function call.


@subsection The @code{:cursor} Slot
@node The @code{:cursor} Slot
@anchor{the-cursor-slot}
@cindex{cursor slot syntax}

At the lowest level, the cursor of a Garnet window is governed by the value
of its @code{:cursor} slot. The default value for an
@code{inter:interactor-window}'s @code{:cursor} slot is a list of two objects,
@code{(#k<OPAL:ARROW-CURSOR> . #k<OPAL:ARROW-CURSOR-MASK>)}, which are
pre-defined bitmaps whose images are read from the @code{garnet/lib/bitmaps/}
directory. The @code{opal:arrow-cursor} object is the black part of the
pointer, and the @code{opal:arrow-cursor-mask} is the underlying white part.
@footnote{Whenever you change the cursor of a window, it is a good idea to have a
contrasting mask beneath the primary image. This will keep the cursor
visible even when it is over an object of the same color.}

@sp 1
The @code{:cursor} slot permits three different syntaxes which all describe
a cursor/mask pair for the window. The most basic syntax is used for the
default value:

@code{(list @var{bitmap-1} @var{bitmap-2})}

The second syntax allows you to use a font as the source for your cursor,
with the primary image and mask specified by indices into the font:

@code{(list @var{my-font}  @var{index-1}  @var{index-2})}

Most machines come with a font specifically for the window manager cursors,
and this font can be accessed with the @code{opal:cursor-font} object.
So you could try the syntax above with the @code{opal:cursor-font} object
and two consecutive indices, like this:

@code{(s-value @var{win} :cursor (list @var{opal:cursor-font} @var{50} @var{51}))}

You have to update the window to make the cursor change take effect.
It appears that sequential pairs, like 50 and 51,
reliably yield primary cursors and their masks.
It is easy to experiment to find a nice cursor.

Since so many cursors are created from the cursor font, a third syntax is
provided that is analogous to the previous one:

@defop {Slot Syntax} :cursor index-1 index-2

Any of these three syntaxes can be used to @code{s-value} the @code{:cursor}
slot of a window. Changing the @code{:cursor} slot of a window changes
it permanently, until you @code{s-value} the @code{:cursor} slot again.
@end defop

@subsection Garnet Cursor Objects
@node Garnet Cursor Objects
@cindex{arrow-cursor}
@cindex{hourglass-cursor}

@example
(create-instance 'opal:ARROW-CURSOR opal:bitmap
  (:image (opal:Get-Garnet-Bitmap "garnet.cursor")))

(create-instance 'opal:ARROW-CURSOR-MASK opal:bitmap
  (:image (opal:Get-Garnet-Bitmap "garnet.mask")))

(defparameter opal:Arrow-Pair
              (cons opal:ARROW-CURSOR opal:ARROW-CURSOR-MASK))



(create-instance 'opal:HOURGLASS-CURSOR opal:bitmap
  (:image (opal:Get-Garnet-Bitmap "hourglass.cursor")))

(create-instance 'opal:HOURGLASS-CURSOR-MASK opal:bitmap
  (:image (opal:Get-Garnet-Bitmap "hourglass.mask")))

(defparameter opal:HourGlass-Pair
              (cons opal:HOURGLASS-CURSOR opal:HOURGLASS-CURSOR-MASK))
@end example
@sp 1

The arrow-cursors are used for the default value of the @code{:cursor} slot
in Garnet windows. The Gilt interface builder and the @code{save-gadget} use
the hourglass-cursors when they are busy with file I/O and performing long
calculations. Users are free to use these objects in their own applications.

The variables @code{opal:Arrow-Pair} and @code{opal:HourGlass-Pair} are provided
so that users can avoid
cons'ing up the same list repeatedly. Setting the @code{:cursor} slot of
a window to be @code{opal:HourGlass-Pair} and then updating the window
will change the cursor in the window.



@subsection Temporarily Changing the Cursor
@node Temporarily Changing the Cursor
@anchor{with-hourglass-sec}

Often when the cursor needs to be changed, we will be changing it back to
the default very soon (e.g., when the application has finished its
computation).
Also, usually we want to change all of the windows in an application, rather
than just one window. For this situation, the functions
@code{opal:change-cursors} and
@code{opal:restore-cursors} were written to change the cursors of multiple
windows @b{without} changing the @code{:cursor} slots.

@cindex{change-cursors}
@defun opal:change-cursors cursor-list &optional window-list

The @emph{cursor-list} argument is a pair or triplet that adheres to the syntax
for the @code{:cursor} slot, discussed in the previous section. When
@emph{window-list} is supplied, the cursor of each window is temporarily set
with a cursor constructed out of the
@emph{cursor-list} spec. When @emph{window-list} is NIL (the default), then @b{all}
Garnet windows are set with the temporary cursor. The value of the
@code{:cursor} slot of
each window remains unchanged, allowing the window's normal cursor to be
restored with @code{opal:restore-cursors}.

@end defun

@cindex{restore-cursors}
@defun opal:restore-cursors &optional window-list

This function undoes the work of @code{opal:change-cursors}. Each window is set
with the cursor described by the value of its @code{:cursor} slot (which was
not changed by @code{opal:change-cursors}).


Even the work of calling @code{opal:change-cursors} and @code{opal:restore-cursors}
can be abbreviated, by using the following macros instead:

@end defun

@cindex{with-cursor}
@cindex{with-hourglass-cursor}
@defmac opal:with-cursor cursor &body body
@defmacx opal:with-hourglass-cursor &body body

The @emph{cursor} parameter must be a pair or triplet adhering to the @code{:cursor}
syntax. These macros change the cursor of all Garnet windows while executing
the @emph{body}, and then restore the old cursors. These are the highest level
functions for changing window cursors.
To test the @code{opal:with-hourglass-cursor} macro, bring up any Garnet window
(demos are fine) and execute the following instruction:

@code{(opal:with-hourglass-cursor (sleep 5))}

While lisp is sleeping, the cursors of all the Garnet windows will change
to hourglass cursors, and then they will change back to normal.

@end defmac

@subsection Update Quarantine Slot
@node Update Quarantine Slot
@anchor{quarantine-slot}
@cindex{quarantine slot}
@cindex{in-progress}

A "quarantine slot" named @code{:in-progress} exists in all Garnet windows.
If there was a crash during the last update of the window, then the window
will stop being updated automatically along with the other Garnet windows,
until you can fix the problem and update the window successfully.

Usually when there is an update failure, it is while the main-event-loop
process is running and it is repeatedly calling @code{opal:update-all}.
Without a quarantine slot, these repeated updates
would keep throwing Garnet into the debugger, even as you tried to figure
out what the problem was with the offending window. With the quarantine slot,
@code{opal:update-all} first checks to see if the @code{:in-progress} slot of
the next window is T. If so, then the last update to that window must not
have terminated successfully, and the window is skipped. After you fix
the problem in the window, a successful call to @code{opal:update} will clear
the slot, and it will resume being updated automatically.

Here is an example of a typical interaction involving the quarantine slot.

@enumerate
Execute @code{(garnet-load "demos:demo-multiwin")} and
 @code{(demo-multiwin:do-go)}.

Artificially create an error situation by executing
@example
(kr:with-types-disabled
 (kr:s-value demo-multiwin::OBJ1 :left 'x))
@end example

Try to move an object in the demo by clicking on it and dragging with the
mouse. Even if you did not click on OBJ1 (the rectangle), the main-event-loop
called @code{opal:update-all}, which caused OBJ1's window to update. This
caused a crash into the debugger when @code{'x} was found in the @code{:left}
slot. Get out of the debugger with @code{:reset} or @code{q} or whatever your
lisp requires.

Now move objects again. As long as your first mouse click is not in the same
window as OBJ1, you will not get the crash again. You can even drag
objects into and through OBJ1's window, but that window will not be
updated.

After you give OBJ1's @code{:left} slot a reasonable value and do a @b{total}
update on its window -- @code{(opal:update demo-multiwin::WIN1 T)} -- the window
will be treated normally again. Note: the total update is sometimes required
because the bad @code{:left} value can get stored in an internal Opal data
structure. A total update clears these data structures.
@end enumerate

We have found that this feature makes it much easier to find the source
of a problem in a window that cannot update successfully. Without this
feature, useful tools like the @code{Inspector} would not be able to run
while there was one broken window, since interacting with the @code{Inspector}
requires repeated calls to @code{opal:update-all}.



@subsection Windows on other Displays
@node Windows on other Displays
@cindex{windows on other displays}
@cindex{machines}
@cindex{displays}

An important feature of the X window manager is that it allows you to run a
process on one machine and have its window appear on another machine. Opal
provides a simple way to do this, although many commands have to be given
to the Unix Shell.

Let's suppose that you want to run Opal on a machine named 
@code{OpalMachine.cs.edu} and you want the windows to appear on a machine
named @code{WindowMachine.cs.edu} (of course you will substitute your own
full machine names). Assuming you are sitting at
@code{WindowMachine.cs.edu}, perform the following steps before starting Garnet:

@itemize
Create an extra Xterm (shell) window and use it to telnet to
@code{OpalMachine.cs.edu} and then log in.


Type the following to @code{OpalMachine.cs.edu} to tell Opal where the
windows should go:
@example
setenv DISPLAY WindowMachine.cs.edu:0.0
@end example


Now go to another Xterm (shell) window on @code{WindowMachine.cs.edu}
and type the following to allow @code{OpalMachine.cs.edu} to talk to X:
@example
xhost + OpalMachine.cs.edu
@end example

Now go back to the telnet window, and start Lisp and load Garnet and any
programs. All windows will now appear on @code{WindowMachine.cs.edu}.
@end itemize

@cindex{*screen-width*}
@cindex{*screen-height*}
The exported variables @code{opal:*screen-width*} and @code{opal:*screen-height*}
contain the width and height of the screen of the machine you are using. Do
not set these variables yourself.

@subsection Methods and Functions on Window objects
@node Methods and Functions on Window objects
@anchor{windowfuncs}

There are a number of functions that work on window objects, in addition to
the methods described in this section. All of the extended accessor
functions (@code{bottom}, @code{left-side}, @code{set-center}, etc.) described in
section @ref{Extended-accessors} also work on windows.

@cindex{update}


@defmethod {Window} opal:update window &optional total-p


The @code{update} method updates the image in @var{window} to reflect
changes to the objects contained inside its aggregate. If @var{total-p} is a
non-@code{nil} value, then the window is erased, and all the components of the
window's aggregate are redrawn. This is useful for when the window is
exposed or when something is messed up in the window (e.g., after a bug).
The default for @var{total-p} is @code{nil}, so the window only redraws the
changed portions. @code{update} must be called on a newly-created window
before it will be visible. Updating a window also causes its subwindows to
be updated.

@cindex{fix-up-window}
If @code{update} crashes into the debugger, this is usually because there is
an object with an illegal value attached to the window. In this case, the
debugging function @code{garnet-debug:fix-up-window} is very useful; see
the Debugging Manual.

@end defmethod

@cindex{destroy}

@defmethod {Window} opal:destroy window


The @code{destroy} method unmaps and destroys the X
window, destroys the @emph{window} object, and calls destroy on the
window's aggregate and the window's subwindows.

@end defmethod

@cindex{update-all}

@defun opal:update-all &optional total-p

been created but never @code{update}d (so they are not yet visible).
When @emph{total-p} is T, then @code{opal:update-all} will redraw the entire
contents of all existing Garnet windows. Since this procedure is expensive,
it should only be used in special situations, like during debugging.

@end defun

@cindex{clean-up}

@defun opal:clean-up how-to


This function is useful when debugging for deleting the windows created using
Opal. It can delete windows in various ways:

@cindex{orphans-only}
@cindex{clx}

@multitable @columnfractions .3 .7
@headitem @code{how-to} @tab Result])

@item @code{:orphans-only}
Destroy all orphaned garnet windows. Orphans are
described below.

@item @code{:opal}
Destroy all garnet windows by calling @code{xlib:destroy-window}
or @code{ccl:window-close} on orphaned CLX "drawables" and
Mac "views", and @code{opal:destroy} on non-orphaned windows.

@item @code{:opal-set-agg-to-nil}
Same as above, but before calling @code{opal:destroy},
set the aggregate to @code{nil} so it won't get destroyed as well.

@item @code{:clx}
Destroy all Garnet windows by calling @code{xlib:destroy-window}
or @code{ccl:window-close}. Does not call the @code{:destroy} method on
the window or its aggregate.

@end multitable

@end defun

A window is "orphaned" when the Opal name is no longer attached to the
CLX drawable or Mac view.
This can happen, for example, if you create an instance of a window
object, update it, then create another instance of a window with the same
name, and update it as well. Then the first window will not be
erased and will be orphaned.

@cindex{fix-up-window}
The default is @code{orphans-only}. Another useful value is @code{:opal}. The
other options are mainly useful when attempts to use these fail due to
bugs. See also the function @code{Fix-Up-Window} in the Garnet Debugging
Manual @cite{Garnetdebugmanual}.

@cindex{convert-coordinates}

@defun opal:convert-coordinates win1 x1 y1 &optional win2 @
  (declare (values @emph{x2 y2}))

This function converts the coordinates @code{x1} and @code{y1} which are in
window @code{win1}'s
coordinate system to be in @code{win2}'s. Either window can be @code{nil}, in which
case the screen is used.

@end defun

@cindex{cut buffer}

@defun opal:get-x-cut-buffer window
@defunx opal:set-x-cut-buffer window newstring

These manipulate the window manager's cut buffer. @code{get-x-cut-buffer}
returns the string that is in the X cut buffer, and @code{set-x-cut-buffer}
sets the string in the X cut buffer.

@end defun


@defun opal:raise-window window
@defunx opal:lower-window  window
@defunx opal:iconify-window window
@defunx opal:deiconify-window window

@code{Raise-window} moves a window to the front of the screen, so that
it is not covered by any other window. @code{Lower-window} moves a
window to the back of the screen. @code{Iconify-window} changes the
window into an icon, and @code{deiconify-window} changes it back to a window.

@end defun

@section Printing Garnet Windows
@node Printing Garnet Windows
@anchor{printing}
@cindex{make-ps-file}
@cindex{PostScript}
@cindex{printing}

The function @code{make-ps-file} is used to generate a PostScript file for
Garnet windows. This file can then be sent directly to any PostScript
printer. The file is in "Encapsulated PostScript"
format, so that it can also be included in other documents, such as Scribe,
LaTeX and FrameMaker on Unix, and Pagemaker on Macintoshes.

The PostScript files generated by this function will produce pictures that
are prettier, have much smaller file sizes, and work better in color than
those produced by the window utilities like @code{xwd} and @code{xpr}. However,
a limitation of PostScript is that it is not possible to print with XOR.
It is usually possible to change the implementation of Garnet objects or
hand-edit the generated PostScript file to simulate the XOR draw function.

By default, the contents of the window and all subwindows are
reproduced exactly as on the screen, with the image scaled and
centered on the output page. Other options (see the @code{clip-p}
parameter) allow this function to be
used to output the entire contents of a window (not just what is on
the screen), so it can be used to do the printing for application data
that might be in a scrolling-window, for example. This is used in the
demo @code{demo-arith}.

@sp 1

@defun opal:make-ps-file window-or-window-list  filename @
       &key position-x  position-y  left-margin  right-margin  top-margin  bottom-margin  left  top @
       scale-x  scale-y  landscape-p  borders-p  clip-p  subwindows-p  color-p  background-color @
       paper-size  title  creator  for  comment

The only two required parameters to @code{make-ps-file} are the Garnet window
to be printed and the name of the file in which to store the PostScript
output. The @emph{window-or-window-list} parameter may be either a single window
or a list of
windows. When multiple windows are printed, the space between the windows is
filled with the color specified by @emph{background-color}.

The optional arguments affect the position and appearance of the
picture:

@vtable @code

@item @emph{position-x}
Either @code{:left}, @code{:center}, or @code{:right}.
Determines the position of the picture on the page horizontally.
Ignored if a value is supplied for @emph{left}. Default is @code{:center}.

@item @emph{position-y}
Either @code{:top}, @code{:center}, or @code{:bottom}.
Determines the position of the picture on the page vertically.
Ignored if a value is supplied for @emph{top}. Default is @code{:center}.

@item @emph{left-margin, right-margin, top-margin, bottom-margin}
These parameters specify the minimum distance (in points) from the
corresponding edge of the page to the rendered image. All four values
default to 72, which is one inch in PostScript.

@item @emph{left, top}
The distance (in points) from the left and top margins
(offsets from @emph{left-margin} and @emph{top-margin}) to
the rendered image. The defaults are @code{nil}, in which
case the values of @emph{position-x} and @emph{position-y} are used instead.

@item @emph{scale-x, scale-y}
Horizontal and vertical scaling for the image. The
default is @code{nil}, which will ensure that the image fits within the specified
margins (the scaling will be the same for vertical and horizontal).

@item @emph{landscape-p}
If @code{nil} (the default) then the top of the picture will be
parallel to the short side of the page (portrait).
If T, then the picture will be rotated 90 degrees, with the top of the picture
parallel to the long side of the page.

@item @emph{subwindows-p}
Whether to include the subwindows of the specified window
in the image. Default is T.

@item @emph{borders-p}
Whether to draw the outline of the window (and subwindows,
if any). The allowed values are @code{T}, @code{NIL},
@code{:generic}, and @code{:motif}. The default value of @code{:motif} gives your
image a simulated Motif window manager frame, like the picutres in the Gilt
Reference Manual. The value of @code{:generic} puts a plain black frame around
your printed image, with the title of the window centered in the title bar.
The value @code{T} gives the image a thin black border, and @code{NIL} yields no
border at all.

@item @emph{clip-p}
How to clip the objects in the window. Allowed values are:

@itemize
@item @code{T}
This is the default, which means that the printed picture will look
like the screen image. If the graphics inside the window extend outside the
borders of the window, then they will be clipped in the printed image.

@item @code{NIL}
This value causes the window in the printed image to be the same
size as the top-level aggregate, whether it is larger or smaller than the
actual window. That is, if the window is too small to show all of the objects
in its aggregate, then the printed window will be enlarged to show all of the
objects. Conversely, if the top-level aggregate is smaller than the dimensions
of the window on the screen, then the printed window will be "shrink wrapped"
around the objects.

@item @code{(@emph{left top width height})}
A list of screen-relative coordinates that
describe absolute pixel positions for the printed window. This makes it
possible to clip to a region when you are printing @emph{multiple} windows.
Clip regions can be used to make multiple-page PostScript
files -- you have to manually divide the image into its component regions,
and generate one PostScript file for each region. In the future, we may
attempt to automate the process of multiple-page printing.
@end itemize

@item @emph{color-p}
Whether to generate a file that will print out the real colors
of the window's objects (T), or pretend that all the colors are
black (@c[nil]). Default is T. (Many PostScript printers will
automatically produce half-tones for colors, so usually T will work
even for color pictures printed on black and white printers.)  @b{Note:}
@cindex{pixmap}
@cindex{colorimage}
Pixmaps print in full color when they are being displayed on a color
screen and the @emph{color-p} parameter is T. However, older
printers may not know the PostScript command @code{colorimage} which is
required to render a color pixmap. This command is only defined on Level 2
printers. If your printer cannot print your pixmap (it crashes with a
"colorimage undefined" error), then try using a @emph{color-p} argument of
@code{NIL}.

@item @emph{background-color}
When @emph{window-or-window-list} is a list of windows,
the space between the windows will be filled with this color. The value of
this parameter may be any Opal color. The default is @code{opal:white}.

@item @emph{paper-size}
This parameter is provided mainly for users in the
United Kingdom. Allowed values are @code{:letter}, @code{:a4}, or a list
of (@emph{width height}). The default value of @code{:letter} generates a
PostScript image for 612x792 point size paper. The @code{:a4} value generates
an image for 594x842 point size paper, which is commonly used in the UK.

@item @emph{title, creator, for}
These parameters should take strings to be printed
in the header comments of the PostScript file. These comments are sometimes
used to print user information on the header sheets of printer output.
The default @emph{title} is based on the window's title. The default @emph{creator}
is Garnet, and the default @emph{for} is "".


allows you to put a single line of text at the top of your PostScript file.
In the generated file, the characters @code{"%%"} are concatenated to the front
of your comment, telling PostScript to ignore the text in the line. If you
wish to use multiple lines in the comment, you will have to add the @code{"%%"}
to the second line of the string and every line thereafter.


@end vtable

@end defun

@section Saving and Restoring
@node Saving and Restoring
@cindex{lisp image}
@cindex{core image}
@cindex{saving lisp images}
Opal includes the ability to save and restore Garnet core images.
The function @code{opal:make-image}, described below, can be used to automate
the process of closing the connection to the display server and generating
a core file. Low-level details are provided below also, in case you need
more control over the saving process.


@subsection Saving Lisp Images
@node Saving Lisp Images
@cindex{make-image}

@sp 1
@defun opal:make-image filename &key quit (verbose t) (gc t) &rest other-args

The function @code{opal:make-image} is used to save an image of your current
lisp session. Without @code{make-image}, you would have to call
@code{opal:disconnect-garnet}, use your implementation-dependent function
to save your lisp image, and then call @code{opal:reconnect-garnet} if you
wanted to continue the session. @code{Opal:make-image} does all of this for
you, and also does a total garbage collection before the save if the @emph{gc}
parameter is T. If the @emph{quit} parameter is T, then your lisp image will
automatically exit after saving itself. The @emph{verbose} parameter controls
whether the function should announce when it is in the stages of garbage
collection, disconnection, saving, and reconnection.

The @emph{other-args} parameter is supplied to accomodate the miscellaneous
parameters of each lisp vendor's image-saving function. For example, with
Allegro's @code{dumplisp} command, you can supply the keywords @code{:libfile}
and @code{:flush-source-info?}. Since @code{opal:make-image} calls @code{dumplisp}
for Allegro, you can supply the extra parameters to @code{opal:make-image} and
they will be passed on to @code{dumplisp}. Therefore, it is not necessary to
call your lisp's image-saving function manually; you can always pass the
additional desired parameters to @code{opal:make-image}.

When you restart the saved image, it will print a banner indicating the time
at which the image was saved, and will automatically call
@code{opal:reconnect-garnet}. Some lisps (like Allegro) allow you to restart
the saved image just by executing the binary file, while others (like CMUCL)
require that the binary file is passed as an argument when the standard lisp
image is executed. Consult your lisp's reference manual for instructions on
restarting your saved image.

@end defun

@subsection Saving Lisp Images Manually in X11
@node Saving Lisp Images Manually in X11

It recommended that you use @code{opal:make-image} whenever possible to save
images of lisp. In particular, restarted images of MCL containing Garnet that
were created by other means will probably not work right, due to the skipping
of initialization steps that would have been performed automatically if the
image had been saved with @code{opal:make-image}.

When you do not want to use the function @code{opal:make-image} to generate
an executable lisp image, and instead want to perform the saving procedure
manually, you can use the functions @code{opal:disconnect-garnet} and
@code{opal:reconnect-garnet}, along with your implementation-dependent
function for saving lisp images.

@example
@cindex{disconnect-garnet}
opal:Disconnect-Garnet@ref{function}

opal:Reconnect-Garnet &optional @emph{display-name} @ref{function}
@end example

Before saving a core image of Garnet, you must first close all connections
to the X server by calling @code{opal:disconnect-garnet}. All windows which are
currently visible will disappear (but will reappear when
@code{opal:reconnect-garnet} is executed).

While the connection to the X server is closed, you
may save a core image of Garnet by calling the appropriate Lisp
command. In Lucid Lisp the command is @code{(disksave)}, in
Allegro Lisp it is @code{(excl:dumplisp)}, and in CMU Common Lisp
it is @code{(ext:save-lisp)}. Consult your Common Lisp manual to
find the disk save command for your version of Common Lisp, as
well as how to start up a saved Lisp core.

It is usually convenient to specify @code{opal:reconnect-garnet} as the
@emph{restart-function} during your save of lisp. For example, the following
instruction will cause @code{opal:reconnect-garnet} to be invoked in
Allegro lisp whenever the saved lisp is restarted:

@example
(excl:dumplisp :name "garnet-image" :restart-function #'opal:reconnect-garnet)
@end example

Otherwise, you will need to call @code{opal:reconnect-garnet} manually when
the lisp image is restarted in order to restore the connection to the server
and make all Garnet windows visible again.

If the @emph{display-name} parameter to @code{opal:reconnect-garnet} is specified,
it should be the name of a machine (e.g., "ecp.garnet.cs.cmu.edu").
If not specified, @emph{display-name} defaults to the current machine.

@section Utility Functions
@node Utility Functions

@subsection Executing Unix Commands
@node Executing Unix Commands
@cindex{unix}
@cindex{shell-exec}

@defun opal:shell-exec command

The function @code{opal:shell-exec} is used to spawn a Unix shell and
execute Unix commands. The @emph{command} parameter should be a string of the
Unix command to be executed. The spawned shell does not read the @code{.cshrc}
file, in order to save time. The function returns a string of the output
from the shell.

In Lucid, CMUCL, and LispWorks, the shell spawned by @code{opal:shell-exec}
is @code{/bin/sh}. In Allegro and CLISP, the shell is the user's default.
Executing this function in other lisps, including MCL, causes an error
(please let the Garnet group know how to enhance this function to run in
your lisp).

@end defun

@subsection Testing Operating System Directories
@node Testing Operating System Directories
@cindex{directory-p}

This function is used to determine whether a string describes an
existing directory or not.

@defun opal:Directory-P string

The @emph{string} should name a potential directory, like @code{"/usr/garnet/"}.
If your lisp is running on a Unix system, this function spawns a shell and
executes a Unix command to test the directory.
There is no other standard way to test directories on different
lisps and operating systems. On the Mac, a lisp-specific directory command
is executed.

@end defun

@section Aggregadgets and Interactors
@node Aggregadgets and Interactors

@cindex{aggregadgets}
The @emph{Aggregadgets} module makes it much easier to create instances of an
aggregate and all its components. With an aggregadget, you only have to
define the aggregate and
its components once, and then when you create an instance, it creates all
of the components automatically. Aggregadgets also allow lists of items to
be created by simply giving a single prototype for all the list elements,
and a controlling value that the list iterates through. Aggregadgets are
described in their own manual @cite{AggregadgetsManual}. 

@cindex{Interactors}
@emph{Interactors} are used to handle all input from the user. Interactor
objects control input and perform actions on Opal graphical objects.
There are high-level interactor objects to
handle all the common forms of mouse and keyboard input. Interactors are
described in their own manual @cite{InterManual}.

Together Opal and Interactors should hide all details of X and QuickDraw
from the programmer. There should never be a need to reference any symbols in
@code{xlib} or @code{ccl}.


@section Creating New Graphical Objects
@node Creating New Graphical Objects

An interesting feature of object-oriented programming in Garnet is that
users are expected to create new objects only by combining existing
objects, not by writing new methods. Therefore, you should only need to
use Aggregadgets to create new kinds of graphical objects. It should never
be necessary to create a new @code{:draw} method, for example.

If for some reason, a new kind of primitive object is desired (for example,
a spline or some other primitive not currently supplied by X11), then
contact the Garnet group for information about how this can be done. Due
to the complexities of X11, Mac QuickDraw, and automatic update and
redrawing of objects in Opal, it is not particularly easy to create
new primitives.

@verbatim
*************************************************************
@b{BAM: I am not sure this section is correct.}

Most users of Opal will only use the pre-defined graphical objects, and
will combine them into aggregates and use formulas to attach them together.
It will be rare to create new kinds of graphical objects. This should only
be needed when new primitives are available, such as splines. 

This chapter discusses how to create new types of graphical objects, should
that be necessary.

@section Internal slots in graphical objects
@node Internal slots in graphical objects

There are numerous extra slots in all graphical objects that are used
internally by Opal. This section will attempt to describe these slots and
their potential uses when designing new graphical objects.

@subsection :update-slots
@node :update-slots
@anchor{opaldemons}

@cindex{update-slots}
The @code{:update-slots} slot contains an association list of all slots in
the object that affect the output picture from the object.
For example:

@example
* (gv opal:arc :update-slots)
((:VISIBLE) (:LINE-STYLE) (:FILLING-STYLE) (:DRAW-FUNCTION) (:LEFT)
 (:TOP) (:WIDTH) (:HEIGHT) (:ANGLE1) (:ANGLE2))
@end example

If any of the values of these objects slots in an instance of an
@code{opal:arc} object change, the instance will need to be redrawn at the
next window update. 

@cindex{demons}
Anytime a slot on the @code{:update-slots} list is changed (either with
@code{s-value} or by a formula being invalidated) the KR's invalidate demon
is called with the object, the slot, and the slot's value on the association
list.

Opal doesn't use the second value of the association pair, so it should be
left as @code{nil}.

When creating an object that is a specialized instance of a prototype
object, one should inherit all the slots on the @code{:update-slots}
list, and then add any others as necessary. Commonly this is done by
something of the form:

@example
(create-instance 'opal:arc opal:graphical-object
  ...
  (:update-slots
   (append (gv opal:graphical-object :update-slots)
	   '((:left) (:top) (:width) (:height)
	     (:angle1) (:angle2))))
  ...)
@end example

By doing this, you insure that all the necessary slots are inherited, and
add any new slots as necessary.

@subsection :drawable
@node :drawable

@cindex{drawable}
The @code{:drawable} slot contains a structure that is the CLX drawable
object that the
object is to display itself into when it is sent a @code{draw} message. This
object may not be the physical window that the object is to be displayed
into, it may be a pixmap that is double buffered onto the screen somewhere
in the update algorithm. All objects should trust the value in this slot,
even though is may not correspond to the drawable of their window. This
slot may not contain a value until the object (or one of its parents) is
placed in a Garnet window.

@subsection :display-info
@node :display-info
@cindex{display-info}

The @code{:display-info} slot holds information used by many of the CLX
primitives for
computation, and drawing. Once an object is placed in a window, this slot
contains an opal structure:

@example

(defstruct (display-info 
            (:print-function display-info-printer))
  display
  screen
  root-window
  default-gcontext)

@end example

The form @code{(display-info-@emph{xxx} (gv @emph{object} :display-info))}
returns the @emph{xxx} structure from @emph{object}'s @code{:display-info} slot.
These fields are useful as follows:

@cindex{display-info-display}
@cindex{display}
@cindex{display-info-screen}
@cindex{screen}
@cindex{display-info-root-window}
@cindex{root-window}
@cindex{display-info-default-gcontext}
@cindex{default-gcontext}
@begin[itemize]

@code{display} is the CLX structure corresponding to the current display
connection to the X server. This is used in calls that affect or query the
server directly, such as @t<xlib:open-font>, @code{xlib:display-force-output},
and @t<xlib:global-pointer-position>.

@code{screen} is the CLX structure containing information about the window's
screen. This is used most often with structure accessors to get
information on values for the screen's white and black pixels, width and
height in pixels or millimeters.

@code{root-window} is the CLX window that corresponds to @code{@w{(xlib:screen-root @emph{screen})}} for use in calls to @code{xlib:create-window}.

@code{default-context} is a CLX graphical context structure used all drawing
requests. Opal maintains a cache on this object, so it should not be
changed. It is acceptable to use this structure in an
@code{xlib:with-gcontext} form when it is necessary to modify a gcontext
outside the bounds of @code{with-filling-styles @r[and ]with-line-styles}.

@end[itemize]

@subsection :x-tiles
@node :x-tiles

@cindex{x-tiles}
The @code{x-tiles} slot contains a formula that computes a pixmap for use in drawing
tiled lines, or pattern filled regions. The formula evaluates to a cons
cell the car of which is the pixmap to use for tiling lines, and the cdr of
which is a pixmap to use when drawing fillings. These are computed from
values in the object's @code{:line-style @r[and] :filling-style} slots.

@subsection :x-draw-function
@node :x-draw-function
@cindex{x-draw-function}

This slot contains a formula that is used to compute the CLX drawing
function from the @code{:draw-function} slot. It probably won't ever be
necessary to change the formula in this slot.

@section Methods on all graphical objects
@node Methods on all graphical objects

The following methods are defined on all graphical objects and may be
specialized upon when creating new classes of graphical objects.

@cindex{draw}
@example
opal:Draw @emph{graphical-object}@ref{method}
@end example

The @code{draw} method on a graphical object causes the object to display
itself in the window of its aggregate. This is only called by the update
methods, never directly by users of Opal.

@cindex{initialize}
@example
initialize @emph{graphical-object}@ref{method}
@end example

This method is called immediately after an instance of an object is
created. It is passed the new object as its only argument. 

@example
opal:Point-In-Gob @emph{graphical-object x y}@ref{method}
@end example

This method should be provided for all new objects. It is used by
@code{point-to-component} and @code{point-to-leaf} to query an object for a hit.
The method should return @c[t] if the object is under the point
@w{(@emph{x,y})}. This function should also take into account the values in the
@code{:hit-threshold}, @code{:select-outline-only}, and @code{:visible} slots of
the object, as described in section @ref{stdfuncs}. Objects that are not
visible should return @code{nil}.

@cindex{fix-properties}
@example
opal::Fix-Properties @emph{graphical-object changed-slots}@ref{method}
@end example

This method is called on aggregates and windows at the time when the update
algorithm passes them during an update. The method is called with an
object, and a list of slots that have changed since it was last called.
This function is often useful for calling functions that cannot
easily be put into formulas.

Currently @code{fix-properties} is not called on graphical objects, but this
functionality can be added to Opal by talking to the maintainer.

@section Draw Methods
@node Draw Methods

There are several things that are worthy of note when working on @code{draw}
methods for new objects. 

Objects @emph{must} draw entirely within their bounding box. The redisplay
algorithm will not work properly if things are drawn outside of their
bounding boxes.

There are two macros for use in writing draw methods that prepare a
gcontext from the gcontext cache that is appropriate for drawing outlines
or fillings as described by the values in the @code{:line-style} and
@code{:filling-style} slots of the object.

@cindex{with-filling-styles}

@defmac with-filling-styles (variable graphical-object) body


This form executes the forms inside @emph{body} with @emph{variable} bound to a
CLX gcontext structure suitable for drawing the filling of an object with
respect to @emph{graphical-object}'s filling style object in the slot
@code{:filling-style}.

@end defmac

@cindex{with-line-styles}

@defmac with-line-styles (variable graphical-object) body


This form executes the forms inside @emph{body} with @emph{variable} bound to a
CLX gcontext structure suitable for drawing the outline of an object with
respect to @emph{graphical-object}'s line style object in the slot
@code{:line-style}.

These forms are commonly used like this:

@example
(define-method :draw opal:polyline (polyline)
  (let ((point-list (gv polyline :point-list))
	(drawable (gv polyline :window :drawable)))      
    (with-filling-styles (gcontext polyline)
      (xlib:draw-lines drawable gcontext
	               point-list :fill-p t))
    (with-line-styles (gcontext polyline)
      (xlib:draw-lines drawable gcontext
	               point-list))))
@end example

@end defmac

@anchor{creating-new-gobs}
*************************************************************
@end verbatim

@ref{References}

@chapter Gem: Low-level Graphics Library
@node Low-level Graphics Library

@section Creating New Graphics Backends
@emph{<TODO>}

@section Using the module directly
@emph{<TODO>}

@section Function Reference

@defop {Gem Window} :all-garnet-windows root-window
@end defop

(gem-method :beep (root-window))

(gem-method :bit-blit (window source s-x s-y width height destination d-x d-y))

(gem-method :black-white-pixel (window))

(gem-method :character-width (root-window font character))

(gem-method :check-double-press (root-window state code time))

(gem-method :clear-area (window &optional (x 0) (y 0) width height buffer-p))

(gem-method :color-to-index (root-window a-color))

(gem-method :colormap-property (root-window property &optional a b c))

(gem-method :copy-to-pixmap (root-window to from width height))

(gem-method :create-cursor (root-window source mask foreground background
					from-font-p x y))

(gem-method :create-image (root-window width height depth from-data-p
				       &optional color-or-data properties
				       bits-per-pixel left-pad data-array))

(gem-method :create-image-array (root-window width height depth))

(gem-method :create-pixmap (root-window width height depth
					&optional image bitmap-p data-array))

(gem-method :build-pixmap (window image width height bitmap-p))


(gem-method :create-state-mask (root-window modifier))

(gem-method :create-window
	    (parent-window x y width height
	     title icon-name background border-width
	     save-under visible
	     min-width min-height max-width max-height
	     user-specified-position-p user-specified-size-p
	     override-redirect))

(gem-method :delete-font (root-window font))

(gem-method :delete-pixmap (root-window pixmap &optional buffer-too))

(gem-method :delete-window (root-window x-window))

(gem-method :device-image (root-window index))

(gem-method :discard-mouse-moved-events (root-window))

(gem-method :discard-pending-events (root-window &optional timeout))

(gem-method :draw-arc (window x y width height angle1 angle2 function
			      line-style fill-style &optional pie-slice-p))

(gem-method :draw-image (window left top width height image function fill-style))

(gem-method :draw-line (window x1 y1 x2 y2 function line-style
			       &optional drawable))

(gem-method :draw-lines (window point-list function line-style fill-style))

(gem-method :draw-points (window point-list function line-style))

(gem-method :draw-rectangle (window x y width height function
				    line-style fill-style))

(gem-method :draw-roundtangle (window left top width height
				      corner-width corner-height function
				      line-style fill-style))

(gem-method :draw-text (window x y string font function
			       line-style &optional fill-background invert-p))

(gem-method :drawable-to-window (root-window drawable))

(gem-method :event-handler (root-window ignore-keys))

(gem-method :flush-output (window))

(gem-method :font-exists-p (root-window name))

(gem-method :font-max-min-width (root-window font min-too))

(gem-method :font-name-p (root-window arg))

(gem-method :font-to-internal (root-window opal-font))

(gem-method :get-cut-buffer (root-window))

(gem-method :image-bit (root-window image x y))

(gem-method :image-from-bits (root-window patterns))

(gem-method :image-hot-spot (root-window image))

;;; returns three values: width, height, depth
(gem-method :image-size (a-window image))

(gem-method :image-to-array (root-window image))

(gem-method :initialize-device (root-window))

(gem-method :initialize-window-borders (window drawable))

(gem-method :inject-event (window index))

(gem-method :make-font-name (root-window key))

(gem-method :map-and-wait (a-window drawable))

(gem-method :max-character-ascent (root-window font))

(gem-method :max-character-descent (root-window font))

(gem-method :mouse-grab (window grab-p want-enter-leave &optional owner-p))

(gem-method :raise-or-lower (window raise-p))

(gem-method :read-an-image (root-window pathname))

(gem-method :reparent (window new-parent drawable left top))

(gem-method :set-clip-mask (window clip-mask &optional lstyle-ogc fstyle-ogc))

(gem-method :set-cut-buffer (root-window string))

(gem-method :set-device-variables (root-window full-display-name))

(gem-method :set-draw-function-alist (root-window))

(gem-method :set-draw-functions (root-window))

(gem-method :set-drawable-to-window (window drawable))

(gem-method :set-interest-in-moved (window interestedp))

(gem-method :set-screen-color-attribute-variables (root-window))

(gem-method :set-window-property (window property value))

(gem-method :stippled-p (root-window))

(gem-method :text-extents (root-window opal-font string))

(gem-method :text-width (root-window opal-font string))

(gem-method :translate-character (window x y state code time))

(gem-method :translate-code (window scan-code shiftp))

(gem-method :translate-coordinates (root-window window x y &optional
                                                other-window))

(gem-method :translate-mouse-character (root-window button-code modifier-bits
                                        event-key))

(gem-method :window-debug-id (window))

(gem-method :window-depth (window))

(gem-method :window-from-drawable (root-window drawable))

(gem-method :window-has-grown (window width height))

(gem-method :window-to-image (window left top width height))

(gem-method :write-an-image (root-window pathname image))



@section Font Handling
@emph{<TODO>}

@chapter Interactors: Encapsulating Mouse and Keyboard Behaviors
@node Interactors Reference: Encapsulating Mouse and Keyboard Behaviors


@b{Brad A. Myers
James A. Landay
Andrew Mickish}
@value{DATE}

@section Abstract
@node Abstract

This document describes a set of objects which encapsulate mouse and
keyboard behaviors. The motivation is to separate the complexities of
input device handling from the other parts of the user interface. We have
tried to identify some common mouse and keyboard behaviors and implement them in a
separate place. There are only a small number of interactor types, but
they are parameterized in a way that will support a wide range of different
interaction techniques. These interactors form the basis for all
interaction in the Garnet system.




@section Introduction
@node Introduction

This document is the reference manual for the @emph{Interactors} system,
which is part of the Garnet User Interface Development System
@cite{GarnetCHI}.
The Interactors module is responsible for handling all of the input
from the user. Currently, this includes handling the mouse and
keyboard.

The design of the Interactors is based on the observation that there are
only a few kinds of behaviors that are typically used in graphical user
interfaces. Examples of these behaviors are selecting one of a set (as in a
menu), moving or growing with the mouse, accepting keyboard typing, etc.
Currently, in Garnet, there are only nine types of interactive behavior,
but these are all that is necessary for the interfaces that Garnet
supports. These behaviors are provided in Interactor objects. When the
programmer wants to make a graphical object (created using Opal; the
Garnet graphics package) respond to input, an
interactor object is created and attached to the graphical object. In
general, the graphics and behavior objects are created and maintained
separately, in order to make the code easier to create and maintain.

This technique of having objects respond to inputs is quite novel, and
different from the normal method in other graphical object systems. In
others, each type of object is responsible for accepting a stream of mouse
and keyboard events and managing the behavior. Here, the interactors
handle the events internally, and cause the graphical objects to behave in
the desired way.

The Interactors, like the rest of Garnet, are implemented in Common Lisp for
X11 and Macintosh QuickDraw. Interactors are set up to work with the Opal
graphics package and the KR object and constraint systems, which are all
part of Garnet.

The motivation and an overview of the Interactors system is described in
more detail in conference papers @cite{Interactors, InterTOIS}.

Often, interactors will be included in the definition of Aggregadgets. See
the Aggregadgets manual for a description of how this works.

@section Advantages of Interactors
@node Advantages of Interactors

The design for interactors makes creating graphical interfaces
easier. Other advantages of the interactors are that:
@itemize
They are entirely ``look'' independent; any graphics can be attached to a
particular ``feel.''

They allow the details of the behavior of objects to be separated from the
application and from the graphics, 
which has long been a goal of user interface software design.

They support multiple input devices operating in parallel.

They simulate multiple processing. Different applications can be running
in different windows, and the operations attached to objects in all the
windows will execute whenever the mouse is pressed over them. The
applications all exist in the same Common Lisp process, but the interactors
insure that the events go to the correct application and that the
correct procedures are called. If the application is written correctly
(e.g., without global variables), multiple instantiations of the @emph{same}
application can exist in the same process.

All of the complexities of X and QuickDraw graphics and event handling
are hidden by Opal and the Interactors package. This makes Garnet
much easier to use than X or QuickDraw, and allows applications written in
Garnet to be run on either Unix or Mac machines without modification.
@end itemize


@section Overview of Interactor Operation
@node Overview of Interactor Operation

@cindex{Inter Package}
The interactors sub-system resides in the @code{Inter} package. We
recommend that programmers explicitly reference names from the
@code{Inter} package, for example: @code{Inter:Menu-Interactor}, but you
can also get complete access to all exported symbols by doing a
@w[@code{(use-package :INTER)}]. All of the symbols referenced in this
document are exported.

In a typical mouse-based operation, the end user will press down on a mouse
button to start the operation, move the mouse around with the button
depressed, and then release to confirm the operation. For example, in a
menu, the user will press down over one menu item to start the operation,
move the mouse to the desired item, and then release.

Consequently, the interactors have two modes: waiting and running. An
interactor is waiting for its start event (like a mouse button down) and
after that, it is waiting for its stop event, after which it
stops running and goes back to waiting. 

In fact, interactors are somewhat more complicated because they can be
aborted at any time and because there are often active regions of the
screen outside of which the interactor does not operate. The full
description of the operation is presented in section @ref{operation}.

@cindex{box (slot)}
@cindex{Selected (slot)}
All the interactors operate by setting specific slots in the graphic
objects.@footnote{``Slots'' are the ``instance variables'' of the objects.}
For example, the menu interactor sets a slot called @code{:selected} to show
which menu item is selected, and the moving and growing interactor sets a
slot called @code{:box}. Typically, the objects will contain constraints
that tie appropriate graphical properties to these special slots. For
example, a movable rectangle would typically contain the following
constraints so it will follow the mouse:
@cindex{Moving-Rectangle}

@cindex{Examples}
@cindex{Moving-Rectangle}
@cindex{Examples}
@cindex{Box (slot)}
@example
(create-instance 'MOVING-RECTANGLE opal:rectangle
   (:box '(80 20 100 150))
   (:left (o-formula (first (gvl :box))))
   (:top (o-formula (second (gvl :box))))
   (:width (o-formula (third (gvl :box))))
   (:height (o-formula (fourth (gvl :box)))))
@end example
The initial size and position for the rectangle are in the @code{:box} slot.
When an interactor changed the box slot, the @code{:left, :top, :width,} and
@code{:height} slots would change automatically based on constraints. 

If the
constraints (formulas) were @emph{not} there, the interactor would still
change the @code{:box} slot, @emph{but nothing would change on the screen},
since the rectangle's display is controlled by @code{:left, :top, :width,} and
@code{:height}, not by @code{:box}.
The motivation for setting this extra slot, is to allow application-specific
filtering on the values. For example, if you do not want the object to
move vertically, you can simply eliminate the formula in the @code{:top} slot.

@section Simple Interactor Creation
@node Simple Interactor Creation

@cindex{create-instance}
@cindex{Interactor-window}
@cindex{window}
To use interactors, you need to create @emph{interactor-windows} for the
interactors to work in (windows are fully documented in the Opal Manual).
To create an interactor-window, you use the standard KR
@code{create-instance} function. For example:
@cindex{Examples}
@cindex{Window Creation}
@cindex{Examples}
@cindex{Creating Interactor Window}
@example
(create-instance 'MYWINDOW inter:interactor-window
   (:left 100)(:top 10)
   (:width 400)(:height 500)
   (:title "My Window"))
(opal:update MYWINDOW)
@end example

To create interactor objects, you also use the @code{create-instance}
function. Each interactor has a large number of optional parameters, which are
described in detail in the rest of this manual. It must be emphasized,
however, that normally it is not necessary to supply very many of these.
For example, the following code creates an interactor that causes the
MOVING-RECTANGLE (defined above) to move around inside MYWINDOW:
@cindex{Examples}
@cindex{Mover for Moving-Rectangle}
@example
(create-instance 'MYMOVER Inter:Move-Grow-Interactor
   (:start-where (list :in MOVING-RECTANGLE))
   (:window MYWINDOW))
@end example

This interactor will use the default start and stop events, which are the
left mouse button down and up respectively. All the other aspects of the
behavior also will use their default values (as described below).

Several implementations of lisp allow interactors to run automatically
(see section @ref{notcmulisp}). If you are @emph{not} running in CMU,
LispWorks, Allegro, Lucid, or MCL Commonlisp, then you need to execute the
following function to make the interactor run:
@example
(inter:main-event-loop)
@end example
This function does not exit, so you have to type ^C (or whatever your
operating system break character is) to the Lisp window when you are
finished (or hit the @code{F1} key (or whatever your Garnet break key
is, section @ref{Garnetbreakkey})).

As another example, here is a complete, minimal ``Goodbye World'' program, that
creates a window with a button that causes the window to go away (created
from scratch, without using any predefined gadgets).

@anchor{eventloopexample}
@cindex{Goodbye World}
@cindex{Example Program}
@cindex{Examples}
@cindex{Goodbye World}
@cindex{Examples}
@cindex{Complete Program}
@example
;;;@emph{using the KR package, but no others, is the "Garnet style"}
(use-package "KR")
;;;@emph{first create the graphics; see the Opal manual for explanations}
(create-instance 'MYWINDOW inter:interactor-window
   (:left 100)(:top 10)
   (:width 125)(:height 25)
   (:title "My Window"))
(s-value MYWINDOW :aggregate (create-instance 'MYAGG opal:aggregate))

(create-instance 'MYTEXT opal:text
   (:string "Goodbye World")
   (:left 2)(:top 5))
(opal:add-component MYAGG MYTEXT)
(opal:update MYWINDOW)

;;;@emph{now add the interactor}
(create-instance NIL Inter:Button-Interactor
   (:window MYWINDOW)
   (:start-where (list :in MYTEXT))
   (:continuous NIL) ;@emph{happen immediately on the downpress}
   (:final-function #'(lambda (inter final-obj-over)
                        (opal:destroy MYWINDOW)
                        ;; @emph{the next line is needed unless you are running CMU Lisp}
			;; @emph{or you are running the main-event-loop process in the}
                        ;; @emph{background in Allegro, Lucid, or LispWorks}
			#-or cmu allegro lucid lispworks) (inter:exit-main-event-loop)))
;;;@emph{If not CMU Lisp, or if not running the background main-event-loop process in}
;;;@emph{Allegro, LispWorks, or Lucid Lisp, then the following is needed to run the interactor:}
#-(or cmu allegro lucid lispworks) (inter:main-event-loop)
@end example



@section Overview of Manual
@node Overview of Manual

This manual is organized as follows. Section @ref{notcmulisp}
discusses the @code{main-event-loop}, which allows you to run interactors
while automatically updating the appearance of the windows.
Section @ref{detailsofOper}
describes how interactors work in detail. Section @ref{accelerators-sec}
describes the definition and operation of global accelerators. Section
@ref{interslots} lists all the slots that are common to all interactors.
Section @ref{specificinters} describes all the interactors that are provided.
Section @ref{transcripts-sec} describes how to make transcripts of events.
Finally, section @ref{advancedfeatures} describes some advanced features.

Normally, you will not need most of the information in this manual. To
make an object respond to the mouse, look in section @ref{specificinters}
to find the interactor you need, then check its introduction to see how to
set up the constraints in your graphical objects so that they will respond
to the interactor, and to see what parameters of the interactor you need to
set. You can usually ignore the advanced customization sections.


@section The Main Event Loop
@node The Main Event Loop

@cindex{Common Lisp}
@cindex{Lucid}
@cindex{CMU Common Lisp}
@cindex{lispworks}
@anchor{notcmulisp}

CMU Common Lisp @cite{CMUCommon Lisp} supports sending events to the
appropriate windows internally. Therefore, under CMU Common Lisp, the
interactors begin to run immediately when they are created, and run
continuously until they are terminated. While they are running, you can
still type commands to the Lisp listener (the read-eval-print loop).

To get the same effect on other Lisps, Garnet uses the multiple process
mechanism of Lucid, Allegro, LispWorks, and MCL Common Lisps. You
usually do not need to worry about the information in this section if you are
using CMU, Allegro, Lucid, or MCL Common Lisp, but you will probably need to go
through an initialization phase for multiprocessing in LispWorks (see the
section "LispWorks" in the Overview Manual).

Note: @code{Main-Event-Loop} also handles Opal window refreshing, so graphical
objects will not be redrawn automatically in other lisps unless this
function is executing.


@section Main-Event-Loop
@node Main-Event-Loop

@cindex{main-event-loop}
@cindex{exit-main-event-loop}
@cindex{Garnet-Break-Key}
@cindex{*Garnet-Break-Key*}
@cindex{F1}
@anchor{Garnetbreakkey}

Under other Common Lisps (like AKCL and CLISP), you need to explicitly
start and stop the main loop that listens for X events. It is always
OK to call the @code{main-event-loop} function, because it does nothing
if it is not needed. Therefore, after
all the objects and interactors have been created, and after the
@code{opal:update} call has been made, you must call the
@code{inter:main-event-loop} procedure. This loops waiting and handling X
events until explicitly stopped by typing @code{^C} (or whatever is your
operating system break character) to the Lisp listener window, or until you
hit the Garnet break key while the mouse is in a Garnet window. This
is defined by the global
variable @code{inter:*Garnet-Break-Key*}, and is bound to @code{:F1} by
default. You can simply setf @code{inter:*Garnet-Break-Key*} to some other
character if you want to use @code{:F1} for something else.

The other way for a program to exit @code{Main-Event-Loop} is for it to call
the procedure @code{inter:exit-main-event-loop}. Typically,
@code{inter:main-event-loop} will be called at the end of your set up
routine, and @code{inter:exit-main-event-loop} will be called from your quit
routine, as in the example of section @ref{eventloopexample}.

@example
inter:Main-Event-Loop &optional @emph{inter-window}@ref{function}

inter:Exit-Main-Event-Loop@ref{function}
@end example

The optional window to @code{Main-Event-Loop} is used to tell which display
to use. If not supplied, it uses the default Opal display. You only need
to supply a parameter if you have a single Lisp
process talking to multiple displays.


@section Main-Event-Loop Process
@node Main-Event-Loop Process
By default, Garnet spawns a background process in Allegro, Lucid, and
LispWorks, which will run the interactor's main-event-loop while simultaneously
allowing you to use the ordinary Lisp listener.
This means that you can use the Lisp
listener without having to hit the Garnet break key (usually @code{:F1}).

Some programs seem to have trouble with this process. If your system doesn't
work, try killing the main-event-loop process and executing
@code{(inter:main-event-loop)} explicitly. In MCL, the background
process is controlled by MCL itself, and cannot be killed. However,
you might be able to break out of an infinite loop (or otherwise get
MCL's attention) by executing the abort command (Control-comma) or the
reset command (Control-period).


@subsection Launching and Killing the Main-Event-Loop-Process
@node Launching and Killing the Main-Event-Loop-Process
@cindex{launch-main-event-loop-process}
@cindex{kill-main-event-loop-process}

@sp 1
@example
opal:Launch-Main-Event-Loop-Process @ref{function}

opal:Kill-Main-Event-Loop-Process @ref{function}
@end example

These are the top-level functions used for starting and stopping the
main-event-loop process.
You may need to call @code{launch-main-event-loop-process} if the
process is killed explicitly or if the process crashes due to a bug.
@sp 1

While the main-event-loop background process is running, calling
@code{(inter:main-event-loop)}, hitting the Garnet break key, and
calling @code{launch-main-event-loop-process} all have no effect.

You can kill the background main-event-loop process by executing
@code{kill-main-event-loop-process}, but normally you should not
have to, even if you encounter an error and are thrown in the debugger.
If you call it when the main-event-loop process is not running, there
is no effect.

@code{Launch-main-event-loop-process} and @code{kill-main-event-loop-process}
belong to the Opal package because @code{opal:reconnect-garnet} and
@code{opal:disconnect-garnet} need to call them.


@subsection Launch-Process-P
@node Launch-Process-P
@cindex{launch-process-p}
In the @code{garnet-loader}, there is a switch called @code{user::launch-process-p}
which tells whether or not Garnet should automatically call
@code{launch-main-event-loop-process} at load time. You can edit the
@code{garnet-loader} to change the default value of this variable, or you
can @code{setf} the variable before loading @code{garnet-loader}.


@subsection Main-Event-Loop-Process-Running-P
@node Main-Event-Loop-Process-Running-P
@cindex{main-event-loop-process-running-p}

@example
opal:Main-Event-Loop-Process-Running-P @ref{function}
@end example

This function tells you whether
the parallel main-event-loop process is running, and is not in the debugger.



@section Operation
@node Operation

@anchor{detailsofOper}

@section Creating and Destroying
@node Creating and Destroying
For interactors to be used, they must operate on objects that appear in
Garnet windows. The @code{inter:interactor-window} prototype is described
in the Opal Manual. To create an interactor window, use:

@example
(create-instance @emph{name} inter:interactor-window @emph{(slot value)(slot value)...})
@end example
@cindex{create-instance}
@cindex{Interactor-Window}
This creates an interactor window named @var{name} (which will usually be a
quoted symbol like @code{'MYWINDOW} or NIL). If @var{name} is NIL, then a
system-supplied name is used. This returns the new
window. The @code{:left}, @code{:top}, @code{:width}, and @code{:height} (and other
parameters) are given just as for all objects.
Note that the window is not visible (``mapped'') 
until an @code{opal:update} call is made on it: 
@example
(opal:update @emph{an-interactor-window})
@end example

To create an interactor, use:
@example
(create-instance @emph{name} Inter:@emph{InteractorType} @emph{(slot value) (slot value)...})
@end example
@cindex{create-instance}
This creates an interactor named @emph{name} (which can be NIL if
a system-supplied name is desired) that is an instance of @emph{InteractorType}
(which will be one of the specific types described in section
@ref{specificinters}, such as @code{button-interactor, menu-interactor,
etc.}  The slots and values are the other parameters to the new
interactor, as described in the rest of this manual. The create-instance
call returns the interactor.

@sp 1

@cindex{Destroy}
@example
opal:Destroy @emph{an-interactor} &optional (@emph{erase} T) @value{method}

opal:Destroy @emph{an-interactor-window} @value{method}
@end example
@sp 1

Invoking this method destroys an interactor or window. If @emph{erase} is T,
then the interactor is aborted and
deallocated. If @emph{erase} is NIL, it is just destroyed. Use NIL
when the window the interactor is in is going to be destroyed anyway.
Normally, it is not necessary to call this on interactors since they are
destroyed automatically when the window they are associated with is destroyed.

Invoking this method on a window destroys the window, all objects in it,
and all interactors associated with it.


@section Continuous
@node Continuous
@anchor{continuous}
@cindex{Continuous}
Interactors can either be @emph{continuous} or not. A continuous interactor
operates between a start and stop event. For example, a Move-Grow interactor
might start the object following the mouse when the left button goes down,
and continue to move the object until the button is released. When the
button is released, the interactor will stop, and the object will stay in
the final place. Similarly, a menu interactor can be continuous to show
the current selection while the mouse is moving, but only make the final
selection and do the associated action when the button is released. 

The programmer might want other interactors to operate only once at the time the
start-event happens.
For example, a non-continuous @code{Button-Interactor} can be used to
execute some action when the @code{delete} key is hit on the keyboard.

The @code{:continuous} slot of an interactor controls whether the interactor
is continuous or not. The default is T.

Many interactors will do reasonable things for both values of
@code{:continuous}. For example, a continuous @code{button-interactor} would
allow allow the user to press down on the graphical button, and then move
the mouse around. It would only execute the action if the mouse button is
released over the graphical button. This is the way Macintosh buttons
work. A non-continuous button would simply execute as soon as the
mouse-button was hit over the graphical button, and not wait for the release.

@section Feedback
@node Feedback
@cindex{Feedback}

When an interactor is continuous, there is usually some feedback to show
the user what is happening. For example, when an object is being moved
with the mouse, the object usually moves around following the mouse.
Sometimes, it is desirable that the actual object not move, but rather
that a special @emph{feedback object} follows the mouse, and then the real
object moves only when the interaction is complete. 

@cindex{Feedback-obj}

The interactors support this through the use of the @code{:feedback-obj}
slot. If a graphical object is supplied as the value of this slot, then
the interactor will modify this object while it is running, and only modify
the ``real'' object when the interaction is complete (section @ref{where}
discusses how the interactor finds the ``real'' object). If no value is
supplied in this slot (or if NIL is specified), then the interactor will
modify the actual object while it is running. In either case, the
operation can still be aborted, since the interactor saves enough state to
return the objects to their initial configuration if the user requests an
abort.

@cindex{box (slot)}
Typically, the feedback object will need the same kinds of constraints as
the real object, in order to follow the mouse. For example, a feedback
object for a @code{Move-Grow-Interactor} would need formulas to the @code{:box}
slot. The sections on the various specific interactors discuss the slots
that the interactors set in the feedback and real objects.

@section Events
@node Events
@anchor{eventspec}
@cindex{events}
@cindex{keyboard keys}
@cindex{mouse buttons}

An interactor will start running when its @emph{start event} occurs and
continue to run until a @emph{stop event} occurs. There may also be an
@emph{abort event} that will prematurely cause it to exit and restore the
status as if it had not started.

An ``event'' is usually a transition of a mouse button or keyboard key.
Interactors provide a lot of flexibility as to the kinds of events that
can be used for start, stop and abort. 


@subsection Keyboard and Mouse Events
@node Keyboard and Mouse Events
@cindex{leftdown}
@cindex{middledown}
@cindex{rightdown}
@cindex{#\ (character prefix)}
Events can be a mouse button down or up transition, or
any keyboard key. The names for the mouse buttons are @code{:leftdown},
@code{:middledown}, and @code{:rightdown} (simulating multiple mouse
buttons on the Mac is discussed in section @ref{mac-keys}). Keyboard
keys are named by their Common Lisp character, such as @code{#\g},
@code{#\a}, etc. Note that @code{#\g} is lower-case "g" and @code{#\G} is
upper case "G" (shift-g).

When specifying shift keys on keyboard events, it is important to be
careful about the "\". For example, @code{:control-g} is @emph{upper} case
"G" and @code{:control-\g} is @emph{lower} case "g" (note the extra "\").
You may also use the form @code{:|CONTROL-g|}, which is equivalent to
@code{:control-\g} (when using vertical bars, you must put the CONTROL
in upper-case). It is not legal to use the @code{shift} modifier with
keyboard keys.

@cindex{any-leftdown}
@cindex{any-middledown}
@cindex{any-rightdown}
@cindex{any-leftup}
@cindex{any-middleup}
@cindex{any-rightup}
@cindex{any-mousedown}
@cindex{any-mouseup}
@cindex{any-keyboard}
Events can also be specified in a more generic manner using
@code{:any-leftdown}, @code{:any-middledown}, @code{:any-rightdown},
@code{:any-leftup}, @code{:any-middleup}, @code{:any-rightup}, @code{:any-mousedown},
@code{:any-mouseup}, and @code{:any-keyboard}. For these, the event will be
accepted no matter what modifier keys are down.


@subsection "Middledown" and "Rightdown" on the Mac
@node "Middledown" and "Rightdown" on the Mac
@anchor{mac-keys}
@cindex{leftdown}
@cindex{middledown}
@cindex{rightdown}
@cindex{Mac mouse buttons}
To simulate the three-button mouse on the Macintosh, we use keyboard
keys in place of the buttons. By default, the keys are @code{F13},
@code{F14}, and @code{F15} for the left, middle, and right mouse buttons,
respectively. The real mouse button is also mapped to @code{:leftdown},
so you can specify mouse events as usual on the Mac (e.g., @code{:rightdown}).
The Overview section at the beginning of this manual provides
instructions for customizing the keys that simulate the mouse buttons,
and provides instructions for a small utility that changes the keys to
be used from function keys to arrow keys.


@subsection Modifiers (Shift, Control, Meta)
@node Modifiers (Shift, Control, Meta)
@cindex{control}
@cindex{meta}
@cindex{shift}
@cindex{command (Mac key)}
Various modifier keys can be specified for the event. The valid
prefixes are @code{shift}, @code{control}, and @code{meta}.
For example, @code{:control-meta-leftdown} will only be true
when the left mouse button goes down while both the Control and Meta
keys are held down. When using a conglomerate keyword like
@code{:shift-meta-middleup}, 
the order in which the prefixes are listed matters. The required order for
the prefixes is: @code{shift, control, meta}. For instance, 
@code{:shift-control-leftdown} is legal; @code{:control-shift-leftdown} is not.

As with MCL itself, the Option key is the "Meta" modifier on the Mac.
There is no way to access the Mac's Command key through Garnet.


@subsection Window Enter and Leave Events
@node Window Enter and Leave Events

@cindex{Window-Enter event}
@cindex{Window-Leave event}
Sometimes it is useful to know when the cursor is inside the window.
Garnet has the ability to generate events when the cursor enters and
leaves a window. To enable this, you must set the
@code{:want-enter-leave-events} slot of the window to T @emph{at window
creation time}. Changing the value of this slot after the window has
been created will not necessarily work. If the window has this value as
non-NIL, then when the cursor enters the window, a special event
called @code{:window-enter} will be generated, and when the cursor
exits, @code{:window-leave} will be generated. For example, the
following will change the color of the window to red whenever the
cursor is inside the window:

@example
(create-instance 'MY-WIN inter:interactor-window 
  (:want-enter-leave-events T)
  (:aggregate (create-instance NIL opal:aggregate)))
(opal:update MY-WIN)

(create-instance 'SHOW-ENTER-LEAVE inter:button-interactor
  (:start-event '(:window-enter :window-leave))
  (:window MY-WIN)
  (:continuous NIL)
  (:start-where T)
  (:final-function #'(lambda(inter obj)
		       (declare (ignore obj))
		       (s-value (gv inter :window)
				:background-color
                                @emph{; :start-char is described in section @ref{specialslots}}
				(if (eq :window-enter (gv inter :start-char))
				    opal:red
				    opal:white))))) 
@end example


@subsection Double-Clicking
@node Double-Clicking
@cindex{double clicking}
@cindex{double-click-time}
Garnet also supports double-clicking of the mouse buttons. When the
variable @code{inter:*Double-Click-Time*} has a non-NIL value, then it
is the time in milleseconds of how fast clicks must be to be
considered double-clicking. By default, double clicking is enabled
with a time of 250 milleseconds.
When the user double-clicks, Garnet first reports the first press and
release, and then a @code{:double-xxx} press and then a @emph{regular} release.
For example, the events that will be reported on a double-click of the
left button are: @code{:leftdown :leftup :double-leftdown :leftup}.
Note that the normal @code{-up} events are used. You can use the normal
@code{:shift, :control,} and @code{:meta} modifiers in the usual order,
before the @code{double-}. For example: @code{:shift-control-double-middledown}.
If you specify the start-event of a continuous interactor to use a
@code{:double-} form, then the correct stop event will be generated
automatically. If you have both single and double click interactors,
then you should be careful that it is OK for the single click one to
run before the double-click one.

@cindex{triple clicking}
If you want to handle triple-clicks, quadruple-clicks, etc., then you
have to count the clicks yourself. Garnet will continue to return
@code{:double-xxx} as long as the clicks are fast enough. When the user
pauses too long, there will be a regular @code{:xxxdown} in between.
Therefore, for triple click, the events will be: @code{:leftdown, :leftup,
:double-leftdown, :leftup, :double-leftdown, :leftup}
whereas for double-click-pause-click, the events will be:
@code{:leftdown, :leftup, :double-leftdown, :leftup, :leftdown, :leftup}.


@subsection Function Keys, Arrows Keys, and Others
@node Function Keys, Arrows Keys, and Others

The various special keys on the keyboard use special keywords.
For example, @code{:uparrow}, @code{:delete}, @code{:F9}, etc.
The prefixes are added in the same way as for mouse buttons (e.g.,
@code{:control-F3}). The arrow keys
are almost always named @code{:uparrow}, @code{:downarrow}, @code{:leftarrow}, and
@code{:rightarrow} (and so there are no bindings for @code{:R8} (uparrow),
@code{:R10} (leftarrow), @code{:R12} (rightarrow), and @code{:R14} (downarrow) on
the Sun keyboard). On the Mac, some users prefer to change their
arrow keys to generate mouse events (see section @ref{mac-keys}).
To see what the Lisp character is for an event, turn on event tracing using
@code{(Inter:Trace-Inter :event)} and then type the key in some interactor
window, as described in the Garnet Debugging Manual.
If you have keys on your keyboard that are not handled by Garnet, it is
easy to add them. See the section on ``Keyboard Keys'' in the Overview
Manual, and then please send the bindings to @code{garnet@@cs.cmu.edu}
so we can add them to future versions of Garnet.

@cindex{*ignore-undefined-keys*}
@cindex{ignore-undefined-keys}
You can control whether Garnet raises an error when an undefined keyboard
key is hit. The default for @code{inter::*ignore-undefined-keys*} is T,
which means that the keys are simply ignored. If you set this variable to
NIL, then an error will be raised if you hit a key with no definition.


@subsection Multiple Events
@node Multiple Events
@cindex{except}
The event specification can also be a set of events, with an
optional exception list.
In this case, the event descriptor is a list, rather than a single event.
If there are exceptions, these should be at the end of the list after the
keyword @code{:except}.
For example, the following lists are legal values when an event is called
for (as in the @code{:start-event} slot):
@cindex{Examples}
@cindex{Events}
@example
   (:any-leftdown :any-rightdown)
   (:any-mousedown #\RETURN)   ;;@emph{any mouse button down or the RETURN key}
   (:any-mousedown :except :leftdown :shift-leftdown)
   (:any-keyboard :any-rightdown :except #\b #\a #\r)
@end example


@subsection Special Values T and NIL
@node Special Values T and NIL

Finally, the event specification can be T or NIL. T matches any event and
NIL matches no event. Therefore, if NIL is used for the @code{:start-event},
then the interactor will never start by itself (which can be useful for
interactors that are explicitly started by a programmer). If T is used for
the @code{:start-event}, the interactor will start immediately when it is
created, rather than waiting for an event. Similarly, if
@code{stop-event} is NIL, the interactor will never stop by itself.


@section Values for the ``Where'' slots
@node Values for the ``Where'' slots
@anchor{where}
@anchor{startwhere}

@subsection Introduction
@node Introduction
@cindex{where}
@cindex{backquote}
@cindex{` (in a ``where'')}
@cindex{start-where}
In addition to specifying what events cause interactors to start and stop,
you must also specify @emph{where} the mouse should be when the interaction
starts using the slot @code{:start-where}.
The format for the ``where'' arguments is usually a list with a keyword at
the front, and an object afterwards. For example, @code{(:in myrect)}.
These lists can be conveniently created either using @code{list} or
back-quote:
@cindex{Examples}
@cindex{Start-Where}
@cindex{Examples}
@cindex{Where}
@example
(:start-where (list :in MYRECT))
(:start-where `(:in ,MYRECT))
@end example
For the backquote version, be sure to put a comma before the object names.

The ``where'' specification often serves two purposes: it specifies where
the interaction should start and what object the interaction should work
on.

Unlike some other systems, the Interactors in Garnet will work on any of a
set of objects. For example, a single menu interactor will handle all the
items of the menu, and a moving interactor will move any of a set of
objects. Typically, the object to be operated on is chosen by the user
when the start event happens. For example, the move interactor may move
the object that the mouse is pressed down over. This one object continues
to move until the mouse is released. 

Some of the interactors have an
optional parameter called @code{:obj-to-change}, where you can specify a
different object to operate on than the one returned by the
@code{:start-where} specification.

One thing to be careful about is that some slots of the @emph{graphical
objects themselves} affect how they are picked, in particular, the
@code{:hit-threshold}, @code{:select-outline-only}, and @code{:pretend-to-be-leaf}
slots. See section @ref{hitthreshold}.

@subsection Running-where
@node Running-where
@anchor{runningwhere}
@cindex{running-where}

There are actually two ``where'' arguments to each interactor. One is the
place where the mouse should be for the interaction to start
(@code{:start-where}). The other is
the active area for the interaction (@code{:running-where}). The default
value for the running-where slot is usually the same as the start-where
slot. As an example of when you might want them to be different, 
with an object that moves with the mouse,
you might want to start moving when the press was over the object itself
(so @code{:start-where} might be @code{(:in MY-OBJ)})
but continue moving while the mouse is anywhere over the background
(so @code{:running-where} might be @code{(:in MY-BACKGROUND-OBJ)}).

@subsection Kinds of ``where''
@node Kinds of ``where''

@cindex{element (in a ``where'')}
There are a few basic kinds of ``where'' values.

@table @b
@item @b{Single object}:
These operate on a single object and check if the mouse
is inside of it.

@item @b{Element of an aggregate}:
These check if the object is an element of an
aggregate. Aggregadgets and Aggrelists will also work since they are
subclasses of aggregate.

@item @b{Element of a list}:
The list is stored as the value of a slot of some
object.
@end table

@cindex{child vs. leaf}
@cindex{leaf vs. child}
@cindex{none}
The last two kinds have a number of varieties:

@table @b
@item @b{Immediate child vs. leaf}:
Sometimes it is convenient to ask if the
mouse is over a ``leaf'' object. This is one of the basic types
(rectangle, line, etc.). This is useful because aggregates often contain
extra white-space (the bounding box of an aggregate includes all of its
children, and all the space in between). Asking for the mouse to be over a
leaf insures that the mouse is actually over a visible object. 

@item @b{Return immediate child or leaf}:
If you want the user to have to press
on a leaf object, you may still want the interactor to operate on the top
level object. Suppose that the movable objects in your system are
aggregates containing a line with an arrowhead and a label.
The user must press on one of the objects directly (so you want leaf), but
the interactor should move the entire aggregate, not just the line. In
this case, you would use one of the forms that checks the leaf but returns
the element. 

@item @b{Or none}
Sometimes, you might want to know when the user presses over
no objects, for example to turn off selection. The ``or-none'' option
returns the object normally if you press on it, but if you press on no
object, then it returns the special value @code{:none}.
@end table

Finally, there is a @b{custom} method that allows you to specify your own
procedure to use.

@subsection Type Parameter
@node Type Parameter
@anchor{leaftype}
@cindex{Type}
After the specification of the object, an optional @code{:type} parameter
allows the objects to be further discriminated by type. For example, you
can look for only the @code{line}s in an aggregate using
@code{`(:element-of ,MYAGG :type ,opal:line)}. Note the comma in front of
@code{opal:line}. 

The type parameter can either be a single type, as shown above, or a list
of types. In this case, the object must be one of the types listed (the
``or'' of the types). For example
@example
`(:element-of ,MYAGG :type (,opal:circle ,opal:rectangle))
@end example
will match any element of @code{myagg} that is either a circle or a rectangle.

Normally, the @code{leaf} versions of the functions below only return
primitive (leaf) elements. However, if the @code{:type} parameter is given
and it matches an interior (aggregate) object, then that object is checked
and returned instead of a leaf. For example, if an object is defined as follows:
@cindex{Examples}
@cindex{Type in Where}
@example
(create-instance 'MYAGGTYPE opal:aggregate)

(create-instance 'TOP-AGG opal:aggregate)

(create-instance 'A1 MYAGGTYPE)
(create-instance 'A2 MYAGGTYPE)
(opal:add-components TOP-AGG A1 A2)

;;@emph{now add some things to A1 and A2}
@end example
Then, the description @code{(:leaf-element-of ,TOP-AGG :type ,MYAGGTYPE)}
will return @code{A1} or @code{A2} rather than the leaf elements of @code{A1} or
@code{A2}.

@cindex{pretend-to-be-Leaf}
@cindex{Leaf Objects}
Another way to prevent the search from going all the way to the actual leaf
objects is to set the @code{:pretend-to-be-leaf} slot of an intermediate
object. Note that the
@code{:pretend-to-be-leaf} slot is set in the Opal objects, not in the
interactor, and it is more fully explained in the Opal manual.

@subsection Custom
@node Custom
@cindex{custom}
@anchor{customwhere}
The @code{:custom} option for the @code{:start-where} field can be used to set up
your own search method. The format is:
@example
       (list :custom obj #'function-name arg1 arg2 ...)
@end example
There can be any number of arguments supplied, even zero. The function
specified is then called for each event that passes the event
test. The calling sequence for the function is:
@example
	(lambda (obj an-interactor event arg1 arg2 ...))
@end example

The arguments are the values in the @code{-where} list, along with the
interactor itself, and an event.
The @code{event} is a Garnet event structure, defined in section @ref{Events}.
This function should return NIL if the event does not pass (e.g., if it is
outside the object), or else the object that the interactor should start
over (which will usually be obj itself or some child of obj). The
implementor of this function should call @code{opal:point-to-leaf}, or
whatever other method is desired. The function is also required to check
whether the event occurred in the same window as the object.

For example, if the interactor is in an aggregadget, and we need a
custom checking function which takes the aggregadget and a special parameter
accessed from the aggregadget, the following could be used:
@cindex{Examples}
@cindex{Custom (Start-Where)}
@example

;;; First define the testing function
(defun Check-If-Mouse-In-Obj (obj inter event param) 
  (if (and (eq (gv obj :window)(inter:event-window event))   @emph{; have to check window}
	   (> (inter:event-x event) (gv obj :left))
	   .....)
      obj  ;@emph{then return object}
      NIL))  ;@emph{else return NIL}

(create-instance NIL opal:aggregadget
   ... ;@emph{various fields}
  (:parameter-val 34)
  (:parts `((....)))
  (:interactors
   `((:start-it ,Inter:Button-Interactor
	 ... ;@emph{all the usual fields}
	 (:start-where
	  ,(o-formula (list :custom (gvl :operates-on)
			    #'Check-If-Mouse-In-Obj
			    (gvl :operates-on :parameter-val))))))))
@end example


@subsection Full List of Options for Where
@node Full List of Options for Where
All of the options for the where fields are concatenated together to form
long keyword names as follows: 

@table @code
@item @code{T}
anywhere. This always succeeds. (The T is not in a list.)  T for
the @code{:start-where} means the interactor starts whenever the start-event
happens, and T for the @code{:running-where} means the interactor runs until
the stop event no matter where the mouse goes.

@item @code{NIL}
nowhere. This never passes the test. This is useful for
interactors that you want to start explicitly using @code{Start-Interactor}
(section @ref{startinteractor}).

@item @code{(:in <obj>)}
@cindex{in} - inside <obj>. Sends the @code{point-in-gob}
message to the object to ask if it contains the mouse position.

@item @code{(:in-box <obj>)}
@cindex{in-box} - inside the rectangle of <obj>. This
might be different from @code{:in} the object since
some objects have special tests for inside. For example, lines test for
the position to be near the line. @code{:In-box} may also be more
efficient than @code{:in}.


@item @code{(:full-object-in <obj>)}
@cindex{full-object-in} - makes sure the entire
object being moved is
inside the object specified here (if a circle is being moved with its
center connected on the mouse, this will make sure that all of the circle
is inside the <obj> specified here). @b[Not implemented yet.]


@item @code{(:in-but-not-on <agg>)}
@cindex{in-but-not-on} - checks if point is
inside the bounding rectangle of <agg>, but not over any of the
children of <agg>.

@item @code{(:element-of <agg> [:type <objtype>])}
@cindex{element-of} - over any
element of the 
aggregate <agg>. If the @code{:type} keyword is specified, then it searches
the components of <agg> for an element of the specified
type under the mouse.
This uses the Opal message @code{point-to-component} on the aggregate.

@item @code{(:leaf-element-of <agg> [:type <objtype>])}
@cindex{leaf-element-of} -
over any leaf object of the
aggregate <agg>. If the @code{:type} keyword is specified, then it searches
down the hierarchy from <agg> for an element of the specified
type under the mouse.
This uses the Opal message @code{point-to-leaf} on the aggregate.

@item @code{(:element-of-or-none <agg> [:type
<objtype>])}
@cindex{element-of-or-none} - This returns a non-NIL value whenever
the mouse is over @code{<agg>}. If there is an object at the mouse, then it is
returned (as with @code{:element-of}). If there is no object, then the special
value @code{:none} is returned. If the mouse is not over
the aggregate, then NIL is returned.
This uses the Opal message @code{point-to-component} on the aggregate.

@item @code{(:leaf-element-of-or-none <agg> [:type <objtype>])}
@cindex{leaf-element-of-or-none} - Like @code{:element-of-or-none}, except it
returns leaf children like @code{:leaf-element-of}.
If there is an object at the mouse, then it is
returned. If there is no object, then the special
value @code{:none} is returned. If the mouse is not over
the aggregate, then NIL is returned.
This uses the Opal message @code{point-to-leaf} on the aggregate.

@item @code{(:list-element-of <obj> <slot> [:type
<objtype>])}
@cindex{list-element-of} - the contents of the @code{<slot>} of
@code{<obj>} should be a list. Goes through the list to find the object
under the mouse. Uses @code{gv} to get the list, so the contents of the
slot can be a formula that computes the list. 
If the @code{:type} keyword is specified, then it searches
the list for an element of the specified type.
This uses the Opal message @code{point-in-gob} on each element of the list.

@item @code{(:list-leaf-element-of <obj> <slot> [:type
<objtype>])}
@cindex{list-leaf-element-of} - like @code{:list-element-of}, except if
one of the objects is an aggregate, then returns its leaf element.
The contents of the @code{<slot>} of @code{<obj>} should be a list. Goes
through the list to find the object under the mouse. 
Uses @code{point-in-gob} if the object is @emph{not} an aggregate, and uses
@code{point-to-leaf} if it is an aggregate.

@item @code{(:list-element-of-or-none <obj> <slot> [:type
<objtype>])}
@cindex{list-element-of-or-none} - like @code{:list-element-of},
except if the event isn't over an object, then returns the special value @code{:none}.
Note that this never returns NIL.

@item @code{(:list-leaf-element-of-or-none <obj> <slot> [:type
<objtype>])}
@cindex{list-leaf-element-of-or-none} - like @code{:list-leaf-element-of},
except if the event isn't over an object, then returns the special value @code{:none}.
Note that this never returns NIL.

@item @code{(:check-leaf-but-return-element <agg> [:type
<objtype>])}
@cindex{check-leaf-but-return-element} - 
This is like @code{:leaf-element-of} except when an object is found, the
immediate component of @code{<agg>} is returned instead of the leaf element.
If the @code{:type} keyword is specified, then it searches
the list for an element of the specified type. This choice is useful, for
example, when the top level aggregate contains aggregates (or aggregadgets)
that mostly contain lines, and the programmer wants the user to have to
select on the lines, but still have the interactor affect the aggregate.

@item @code{(:list-check-leaf-but-return-element <obj> <slot> [:type
<objtype>])}
@cindex{list-check-leaf-but-return-element} - like
@code{:list-leaf-element-of}, except that it returns the element from the list
itself if a leaf element is hit.

@item @code{(:check-leaf-but-return-element-or-none <agg> [:type
<objtype>])}
@cindex{check-leaf-but-return-element-or-none} - 
This is like @code{:check-leaf-but-return-element} except that if no child is
under the event, but the event is inside the aggregate, then @code{:none} is
returned.

@item @code{(:list-check-leaf-but-return-element-or-none <agg> [:type
<objtype>])}
@cindex{list-check-leaf-but-return-element-or...} - 
This is like @code{:list-check-leaf-but-return-element} except that if nothing is
found, @code{:none} is returned instead of NIL.

@item @code{(:custom <obj> 'function-name arg1 arg2 ....)}
@cindex{custom} - 
Use a programmer-defined method to search for the object. See section
@ref{customwhere}.

@end table

@subsection Same Object
@node Same Object
@cindex{* (in a ``where'')}
A special value for the object can be used when the specification is in the
@code{:running-where} slot. Using @code{*} means ``in the object
that the interactor started over.''  For example, if the start-where is
@code{(:element-of <agg>)}, a running-where of @code{'(:in *)} would refer to
whatever object of the @code{<agg>} the interactor started over. This @code{*}
form cannot be used for the @code{:start-where}.

@subsection Outside while running
@node Outside while running
@anchor{Outside}
@cindex{Outside}
@cindex{Last}
While the interactor is running, the mouse might be moved outside the area
specified by the @code{:running-where} slot. The value of the interactor
slot @code{:outside} determines what happens in this case. When
@code{:outside} is NIL, which is the default, the interaction is
temporarily turned off until the mouse moves back inside.
This typically will make the feedback be invisible. In this case, if the
user gives the stop event while outside, the interactor will be aborted.
For example, for a menu, the @code{:running-where} will usually be
@code{(:element-of MENU-AGG)} (same as the @code{:start-where}). If the user
moves outside of the menu while the mouse button is depressed, the feedback
will go off, and the mouse button is released outside, then no menu
operation is executed.
This is a convenient way to allow the user to abort an interaction once it
has started.

On the other hand, if you want the interactor to just save the last legal,
inside value, specify @code{:outside} as @code{:last}. In this case, if the user
stops while outside, the last legal value is used.

If you want there to be no area that is outside (so moving everywhere is
legal), then simply set @code{:running-where} to T, in which case the
@code{:outside} slot is ignored.

@subsection Thresholds, Outlines, and Leaves
@node Thresholds, Outlines, and Leaves
@anchor{hitthreshold}
@cindex{hit-threshold}
@cindex{select-outline-only}
@cindex{pretend-to-be-leaf}
Three slots of Opal objects are useful for controlling the ``where'' for
interactors. These are @code{:hit-threshold}, @code{:select-outline-only},
and @code{:pretend-to-be-leaf}. If you set the
@code{:select-outline-only} slot of an Opal object (note: @emph{not} in the
interactor) to T, then all the ``where'' forms (except @code{:in-box}) will
only notice the object when the mouse is directly over the outline. The
@code{:hit-threshold} slot of Opal objects determines how close to the
line or outline you must be (note that you usually have to set the
@code{:hit-threshold} slot of the aggregate as well as for the
individual objects.)  See the Opal manual for more information on these slots.

An important thing to note is that if you are using one of the @code{-leaf}
forms, you need to set the @code{:hit-threshold} slot of @emph{all the
aggregates} all the way down to the leaf from the aggregate you put in the
@code{-where} slot. This is needed if the object happens to be at the edge
of the aggregate (otherwise, the press will not be considered inside the
aggregate).

The @code{:pretend-to-be-leaf} slot is used when you want an interactor
to treat an aggregate as a leaf (without it, only the components of an
aggregate are candidates to be leaves). When you set the
@code{:pretend-to-be-leaf} slot of an aggregate to T (note: not in the
interactor), then the search
for a leaf will terminate when the aggregate is reached, and the
aggregate will be returned as the current object.


@section Details of the Operation
@node Details of the Operation
@cindex{Functions}
@cindex{States (of interactors)}
@anchor{operation}

Each interactor runs through a standard set of states as it is running.
First, it starts off @emph{waiting} for the start-event to happen over the
start-where. Once this occurs, the interactor is @emph{running} until the
stop-event or abort-event happens, when it goes back to waiting. While it
is running, the mouse might move @emph{outside} the active area (determined by
@code{:running-where}), and later move @emph{back inside}. Alternatively, the
stop or abort events might happen while the mouse is still outside.
These state changes are implemented as a simple state machine inside each
interactor.

At each state transition, as well as continuously while the interactor is
running, special interactor-specific routines are called to do the actual
work of the interactor. These routines are supplied with each interactor,
although the programmer is allowed to replace the routines to achieve
customizations that would otherwise not be possible. The specifics of what
the default routines do, and the parameters if the programmer wants to
override them are discussed in section @ref{specificinters}.

The following table and figure illustrate the working of the state machine
and when the various procedures are called.

@enumerate
If the interactor is not @emph{active}, then it waits until a program
explicitly sets the interactor to be active (see section @ref{active}).

If active, the interactor waits in the start state for the start-event to
happen while the mouse is over the specified start-where area.

When that event happens, if the interactor is @emph{not} ``continuous''
(defined in section @ref{continuous}), then it executes the Stop-action
and returns to waiting for the start-event. If the interactor is
continuous, then it does all of the following steps:
@enumerate
First, the interactor calls the Start-action and goes into the running state.

In the running state, it continually calls the running-action routine while
the mouse is in the running-where area. Typically, the running-action is
called for each incremental mouse movement (so the running-action routine
is not called when the mouse is not moving).

If the mouse goes @emph{outside} the
running-where area, then outside-action is called once.

If the mouse returns from outside running-where to be back inside, then the
back-inside-action is called once.

If the abort-event ever happens, then the abort-action is called and the
state changes back to the start state.

If the stop-event occurs while the mouse is inside running-where, then the
stop-action is called and the state returns to start.

If the stop-event occurs while the mouse is @emph{outside}, then if the
@code{:outside} field has the value @code{:last}, the the stop-action is called
with the last legal value. If @code{:outside} is NIL, then the
abort-action is called. In either case, the state returns to start.
Note: if @code{:outside = :last}, and there is no abort-event, then there is
no way to abort an interaction once it has started.
@end enumerate
@end enumerate

If a program changes the active state to NIL (not active) and the
interactor is running or outside, the interactor is immediately aborted (so
the abort-action is called), and the interactor waits for a program to make
it active again, at which point it is in the start state. (If the
interactor was in the start state when it became inactive, it simply waits
until it becomes active again.)  This transition is not shown in the
following figure. Section @ref{active} discusses making an interactor in-active. 

@float Figure, fig:ex7
@center @image{interstate, 5.5in}
@caption{Each Interactor runs the same state machine to control its operation.
The @code{start-event}, @code{stop-event} and @code{abort-event} can be
specified (see section @ref{events}), as can the various
@code{-action} procedures (section @ref{customroutines}). Where the mouse
should be for the Interactor to
start (@code{start-where}), and where it should run (@code{running-where}) can
also be supplied as parameters (sections @ref{startwhere} and
@ref{runningwhere}). The @code{outside-control} parameter
determines whether the interaction is aborted when the user moves outside,
or whether the last legal value is used (section @ref{runningwhere}).
There are default values for all parameters, so the programmer does not
have to specify them. In addition to the transitions shown, Interactors
can be aborted by the application at any time.}
@anchor{StateMachineFig}
@end float


@section Mouse and Keyboard Accelerators
@node Mouse and Keyboard Accelerators

@anchor{accelerators-sec}
@cindex{Accelerators}

The Interactors now have a new mechanism to attach functions to
specific keyboard keys as @emph{accelerators}. These are processed
either before or after interactors, and are either attached to a
particular window, or global to all windows. If they are @emph{after} the
interactors, then the accelerators are only used if no interactor
accepts the event. 

(Note: If you are using the @code{menubar} or @code{motif-menubar}, then
you can use the slot @code{:accelerator-windows} of those gadgets to
tell them which windows should have the keyboard accelerators defined
in them.)

By default, a number of @emph{global} accelerators are defined:
@example
    :SHIFT-F1 -  raise window
    :SHIFT-F2 -  lower window
    :SHIFT-F3 -  iconify window
    :SHIFT-F4 -  zoom window
    :SHIFT-F5 -  fullzoom window
    :SHIFT-F6 -  refresh window
    :SHIFT-F7 -  destroy window

    :HELP - INSPECTOR object
    :CONTROL-HELP - INSPECTOR next interactor to run
    :SHIFT-HELP - print out object under the mouse (also in inspector.lisp)
@end example

The last three are processed @emph{before} Interactors, and are defined
in the debugging file @code{inspector.lisp}.
To change these, see the Debugging Reference Manual.
The first 7 are processed @emph{after} the interactors. To change these
bindings, set the variable @code{*default-global-accelerators*}, which
is initially defined as:
@example
(defvar *default-global-accelerators* '(
    (:SHIFT-F1 . raise-acc)
    (:SHIFT-F2 . lower-acc)
    (:SHIFT-F3 . iconify-acc)
    (:SHIFT-F4 . zoom-acc)
    (:SHIFT-F5 . fullzoom-acc)
    (:SHIFT-F6 . refresh-acc)
    (:SHIFT-F7 . destroy-acc)))
@end example

Applications can also set and maintain their own accelerator keys,
using the following functions:
@cindex{add-global-accelerator}
@cindex{add-window-accelerator}
@example
inter:Add-Global-Accelerator @emph{key fn} &key @emph{replace-existing? first?} @ref{function}
inter:Add-Window-Accelerator @emph{win key fn} &key @emph{replace-existing? first?} @ref{function}
@end example

Will call the function @emph{fn} whenever @emph{key} is hit. If @emph{first?}
then the accelerator will be tested before all interactors, otherwise
it will be tested if no interactor uses @emph{key}.
@emph{Replace-existing}, if non-NIL, will remove any other assignments
for @emph{key}. By using the default NIL value, you can temporarily hide
an accelerator binding.

@sp 1
The function @emph{fn} is called as:
@example
(lambda (event))
@end example
where event is the interactor event structure that caused the
accelerator to happen.

@cindex{remove-global-accelerator}
@cindex{remove-window-accelerator}
@example
inter:Remove-Global-Accelerator @emph{key} &key @emph{remove-all? first?} @ref{function}
inter:Remove-Window-Accelerator @emph{win key} &key @emph{remove-all? first?} @ref{function}
@end example
Removes the specified accelerator. If @emph{remove-all?} then removes
all the accelerators bound to the @emph{key}, otherwise, just removes the
first one.

@cindex{clear-global-accelerators}
@cindex{clear-window-accelerators}
@cindex{default-global-accelerators}
@example
inter:Clear-Global-Accelerators @ref{function}
inter:Clear-Window-Accelerators @emph{win} @ref{function}

inter:Default-Global-Accelerators @emph{;; sets up the default accelerators} @ref{function}
@end example



@section Slots of All Interactors
@node Slots of All Interactors

@cindex{Slots (of interactors)}
@anchor{interslots}

This section lists all the slots common to all interactors. Most of these
have been explained in the previous sections. The slots a programmer is most
likely to want to change are listed first.
Some specific interactor types have additional slots, and these are
described in their sections.

The various @code{-action} procedures are used by the individual interactors
to determine their behavior. @emph{You will rarely need to set these slots.}
See section @ref{customroutines} for how to use the @code{-action} slots. 

The following field @emph{must} be supplied:

@table @code
@item @code{:start-where}
@cindex{start-where}
- where the mouse should be for this
interactor to start working. Valid values for @code{where} are described in
section @ref{where}.


The following fields are optional. If they are not supplied, then the
default value is used, as described below. Note that supplying NIL is
@emph{not} the same as not supplying a value (since not supplying a value
means to use the default, and NIL often means to not do something).

@item @code{:window}
@cindex{window}
- the window that the interactor should be connected to. Usually this is
supplied as a single window, but other options are possible for interactors
that operate on multiple windows. See section @ref{multiwindow}.

@item @code{:start-event}
@cindex{start-event}
- the event that causes the interactor to start
working. The default value is @code{:leftdown}. NIL means the interactor
never starts by itself (see @ref{startinteractor}).
Using @code{T} means no event, which
means that the interactor is operating whenever the mouse is over
@code{:start-where}. The full syntax for event
specification is described in section @ref{eventspec}.

@item @code{:continuous}
@cindex{continuous}
- if this is T, then the interactor operates continuously
from start-event until stop-event. If it is NIL, then the interactor
operates exactly once when start-event happens. The default value
is @code{T}. See section @ref{continuous} for more explanation.

@item @code{:stop-event}
@cindex{stop-event}
- This is not used if @code{:continuous} is NIL. If @code{:continuous} is T,
@code{:stop-event} is the
event that the interaction should stop on. If not supplied, and the
start-event is a mouse down event (such as @code{:leftdown}), then
the default @code{:stop-event} is the corresponding up event (e.g. @code{:leftup}).
If start-event is a keyboard key, the default stop event is @code{#\RETURN}. If
the @code{:start-event}
is a list or a special form like @code{:any-mousedown}, then the default
@code{:stop-event} is calculated based on the actual start event used.
You only need to define
stop-event if you want some other behavior (e.g. starting on @code{:leftdown}
and stopping on the next @code{:leftdown} so you must click twice). The form
for stop-events is the same as for start-events (see
section @ref{events}). @code{T} means no event, so the
interactor never stops (unless it is turned off using @code{ChangeActive}).

@item @code{:feedback-obj}
@cindex{feedback-obj}
- If supplied, then this is the object to be used to show the feedback while the
interaction is running. If NIL, then typically the object itself will be
modified. The default value is NIL. See the descriptions of the specific
interactors for more information.

@item @code{:running-where}
@cindex{running-where}
- Describes where the interaction should operate if it is continuous. The
default is usually to use the same value as start-where. Running-where
will sometimes
need to be different from start-where, however. For example, with an
object that moves with the mouse,
you might want to start moving when the press was over the object itself.
See section @ref{where} for a complete discussion of this field.

@item @code{:outside}
@cindex{outside}
- Determines what to do when the mouse goes outside of running-where.
Legal values are @code{:last}, which means to use the last value before the
mouse went outside, or NIL which
means to return to the original value (before the interaction
started). The default value is NIL.
See section @ref{outside} for more explanation.

@item @code{:abort-event}
@cindex{abort-event}
- This is an event that causes the interaction to terminate prematurely.
If abort-event is NIL, then there is no separate event to cause aborts.
The default value is NIL. The form for abort-events is the same as for
start-events (see section @ref{events}).

@item @code{:waiting-priority}
@cindex{waiting-priority}
- This determines the priority of the interactor while waiting for the
start event to happen. See section @ref{priorities} for a description of
priority levels.

@item @code{:running-priority}
@cindex{running-priority}
- This determines the priority of the interactor while it is running
(waiting for the stop event to happen). See section @ref{priorities} for a
description of priority levels.

@item @code{:final-function}
@cindex{final-function}
- This function is called after the interactor is complete. The programmer
might supply a function here to cause the application to notice the users
actions. The particular form for the parameters to this function is
specific to the particular type of the interactor.

@item @code{:stop-action}
@cindex{stop-action}
- This procedure is called once when the @code{:stop-event} happens,
or if the interactor is @emph{not} continuous, then this procedure is called once
when the @code{:start-event} happens. The form for the arguments is specific to the
particular interactor sub-class. Specifying NIL means do no action.
Normally, the @code{stop-action} procedure (as well as the @code{start-action,
running-action, etc. below} is @emph{not} provided by the programmer, but rather
inherited. These functions provide the default behavior, such as turning
on and off the feedback object. In particular the default stop-action
calls the final-function. See section @ref{customroutines}.

@item @code{:start-action}
@cindex{start-action}
- The action to take place when start-event happens when the mouse is over
start-where
@c{** Wrong
@c If @code{:contininuous} is NIL, then this is the only procedure
@c that is called. If @code{:contininuous} is T (the default), then
@c @code{:running-action}, @code{:stop-action}, etc. will be called afterwards.
@c **}
and continuous is T (if continuous is NIL, then @code{stop-action}
is called when the start-event happens).
The form for the arguments is specific to the
particular interactor sub-class. 
Specifying NIL means do no action. See section @ref{customroutines}.

@item @code{:running-action}
@cindex{running-action}
- A procedure to be called as the interaction is running. This is called
repeatedly (typically for each incremental mouse movement) while the mouse
is inside @code{:running-where} and between when @code{:start-event} and
@code{:stop-event} happen. The form for the arguments is specific to the
particular interactor sub-class. Specifying NIL means do no action.
See section @ref{customroutines}.

@item @code{:abort-action}
@cindex{abort-action}
- This procedure is called when the interaction is aborted, either by
@code{:abort-event} or @code{:stop-event} while outside. 
The form for the arguments is specific to the
particular interactor sub-class. Specifying NIL means do no action. 
See section @ref{customroutines}.

@item @code{:outside-action}
@cindex{outside-action}
- This procedure is called once each time the mouse goes from inside
@code{:running-where} to being outside. It is @emph{not} called repeatedly while
outside (so it is different from @code{:running-action}).
The form for the arguments is specific to the
particular interactor sub-class. Specifying NIL means do no action.
See section @ref{customroutines}.

@item @code{:back-inside-action}
@cindex{back-inside-action}
- This is called once each time the mouse goes from outside
@code{:running-where} to being inside. Note that
@code{:running-action} is @emph{not} usually called on this point.
The form for the arguments is specific to the
particular interactor sub-class. Specifying NIL means do no action.
See section @ref{customroutines}.

@item @code{:active}
@cindex{active}
- Normally, an interactor is active (willing to accept its start event)
from the time it is created until it is destroyed. However, it is
sometimes convenient to make an interactor inactive, so it does not look
for any events, for example, to have different modes in the interface.
This can be achieved by setting the active field of the
interactor. If the interactor is running, setting @code{:active} to NIL
causes it to abort, and if the interactor is
not running, then this just keeps it from starting.
This field can be set and changed at any time either using
@code{s-value} or by having a formula in this slot, but it is safest to use
the @code{Change-active} procedure, since this guarantees that the interactor
will be aborted immediately if it is running. Otherwise, if it is running
when the @code{active} field changes to NIL, then it will abort the next time
there is an event (e.g., when the mouse moves). See section @ref{active}
for more information.

@item @code{:self-deactivate}
@cindex{self-deactivate}
- Normally, interactors are always active. If this field is @code{T}
however, the interactor will become inactive after
it runs once (it will set its own @code{:active} slot to NIL).
The interactor will then not run again until the @code{:active}
field is explicitly set to @code{T}. If this field is used, it is probably a
bad idea to have a formula in the @code{:active} slot.

@verbatim
************************** NIY **********************************
@code{:exception-p}
@cindex{exception}
- a function to determine whether the current value is illegal. This
serves as a temporary way to change what is specified by the @code{-where}
parameters. Illegal
values add one extra state to the state machine of the figure; the
interactor goes into the exception state when the mouse goes over an
illegal item (as determined by this function), and leaves the exception
state when the mouse goes over a legal item or goes outside. @b{Note: Is
it sufficient to just use the actions for outside and back-inside for
exceptions, or do we need the following?}
There are two procedures added for exceptions: @code{:over-illegal-item} and
@code{:leave-illegal-item}, see below.
Parameters to the exception-p procedure
are @code{(an-interactor objUnderMouse)} and it should
return T or NIL. Returning @code{T} means that the value is an exception (is
illegal), and this is treated as if the mouse went outside. Returning NIL
means the value is OK. The default is for there to be no illegal values.
The default function for this parameter (use this by supplying T) checks the
slot @code{:illegal} in the object under the mouse.
@B{This is not implemented yet.}

@code{:over-illegal-item}
@cindex{over-illegal-item}
- Called when go over an illegal item with parameters @code{(an-interactor
illegal-obj)}. Default action is to call the @code{:outside-action} procedure.
@B{This is not implemented yet.}

@code{:leave-illegal-item}
@cindex{leave-illegal-item}
- Called when no longer over an illegal item with parameters @code{(an-interactor
illegal-obj)}. Default action is to do nothing.
Note that if the mouse moves from one illegal item to another,
the @code{:leave-} and @code{:over-} procedures will be called. Also unlike
back-inside, the @code{:running-action} procedure is called on the new object
the mouse goes over. @B{This is not implemented yet.}

@code{:pop-up}
@cindex{pop-up}
- If non-NIL, then this interactor controls something that should pop-up
(become visible) when the interactor starts, and become invisible when the
interactor completes.
If NIL, then object that the interactor refers to should be
visible. If non-NIL, then the value of pop-up should be a procedure to
cause the object to be displayed and erased. It is called with
@code{(an-interactor visible-or-erase)}, where @code{visible-or-erase} is T to
make it visible, and NIL to erase it.
The default procedure is to set
the object's @code{:visible} slot to T, and to NIL for
stop-action. If would be an error to have start-where be the object if it
was a pop-up, since it would not be visible to press on. The default value
for this parameter is NIL. @B{This is not implemented yet.}
************************** NIY **********************************
@end verbatim

@end table

@section Specific Interactors
@node  Specific Interactors
@anchor{specificinters}

This section describes the specific interactors that have been defined.
Below is a list of the interactors, and then the following sections
describe them in more detail. There are also several interactors defined for
the @code{multifont-text} object. These are described in the Opal manual.

@ftable @code
@item @code{Inter:Menu-Interactor}
@cindex{Menu-Interactor}
- to handle menu items, where the mouse can choose
among a set of items. Useful for menus, etc.

@item @code{inter:button-interactor}
@cindex{Button-Interactor}
- to choose a particular button. The difference
from menus is that when the mouse moves away, the item is deselected,
rather than having a different item selected. Useful for sets of buttons
like "radio buttons" and "check boxes", and also for single, stand-alone buttons.
This can also be used just to select an object by making
@code{:continuous} be NIL. 

@item @code{inter:move-grow-interactor}
@cindex{Move-Grow-Interactor}
- move or change the size of
an object or one of a set of objects using the mouse.
There may be feedback to show how the object moves or grows, or the
object itself may
change with the mouse. If defined over a set of objects, then the
interactor gets the
object to change from where the interaction starts. Useful for scroll
bars, horizontal and vertical gauges, and for moving and changing
the size of application objects in a graphics editor. It can change the
bounding box for the objects or the end points for a line.

@item @code{inter:two-point-interactor}
@cindex{Two-Point-Interactor}
- This is used when there is no original object to
modify, but one or two new points are desired.
A rubber-band feedback object (usually a
rubber-band line or rectangle) will typically be
drawn based on the points specified.

@item @code{inter:angle-interactor}
@cindex{Angle-Interactor}
- Useful for getting the angle the mouse moves from
around some point. This can be used for circular gauges or for "stirring
motions" for rotating.

@item @code{inter:text-interactor}
@cindex{Text-Interactor}
- Used to input a small edited string of text. The
text can be one line or multi-line.

@item @code{inter:gesture-interactor}
@cindex{Gesture-Interactor}
- Used to recognize single-path gestures drawn with the mouse.

@item @code{inter:animator-interactor}
@cindex{Animator-Interactor}
- This interactor causes a function to be executed at regular intervals,
allowing rapid updating of graphics for animation.

@end ftable


The following interactors are planned but not implemented yet.
@vtable @code
@item @code{Inter:Trace-Interactor}
@cindex{Trace-Interactor}
- This returns all of the points the mouse goes
through between @code{start-event} and @code{stop-event}. This is useful for
inking in a drawing program. Although this isn't implemented yet, it is
trivial to use a gesture interactor with a @code{:classifier} of NIL.

@item @code{inter:multi-point-interactor}
@cindex{Multi-Point-Interactor}
- This is used when there is no original object to
modify, but more than 2 new points are desired. This is separate from the
@code{two-point-interactor} because the way the points are stored is usually
different, and the stopping conditions are much more complicated for
multi-points. @b{Not implemented yet. However, there is a gadget in the
gadget set that will do most of this. See}
@code{garnet-gadgets:polyline-creator}.

@end vtable


@section Menu-Interactor
@node Menu-Interactor
@cindex{Menu-Interactor}
@anchor{MENUINTER}
@example
(create-instance 'inter:Menu-Interactor inter:interactor
  @emph{;; Slots common to all interactors (see section @ref{interslots})}
  (:start-where NIL)
  (:window NIL)
  (:start-event :leftdown)
  (:continuous T)
  (:stop-event NIL)
  (:running-where NIL)
  (:outside NIL)
  (:abort-event :control-\g)
  (:waiting-priority normal-priority-level)
  (:running-priority running-priority-level)
  (:active T)
  (:self-deactivate NIL)

  @emph{; Slots specific to the menu-interactor (discussed in this section)}
  (:final-function NIL)      @emph{; (lambda (inter final-obj-over))}
  (:how-set :set)            @emph{; How to select new items (toggle selection, etc.)}
  (:feedback-obj NIL)        @emph{; Optional interim feedback object. The inter will set this object's :obj-over slot.}
  (:final-feedback-obj NIL)  @emph{; The optional object to indicate the final selection}
  (:slots-to-set             @emph{; Names of slots to set in the objects}
   '(:interim-selected       @i[;   '(<interim-selected-slot-name-in-obj>]
     :selected               @emph{;     <selected-slot-name-in-obj>]
     :selected})             @emph{;     <selected-slot-name-in-aggregate>}]
  (:final-feed-inuse NIL)    @emph{; Read-only slot. A list of final feedback objects (section @ref{menufinalfeedbackobj})}

  @emph{; @b{Advanced feature:}  Read-only slots.}
  @emph{; See section @ref{specialslots} for details about these slots.}
  (:first-obj-over NIL)     @emph{; Read-only slot. The object returned from the start-where.}
  (:current-window NIL)     @emph{; Read-only slot. The window of the last (or current) event.}
  (:start-char NIL)         @emph{; Read-only slot. The character or keyword of the start event.}

  @emph{; @b{Advanced feature:} Customizable action routines.}
  @emph{; See sections @ref{interslots} and @ref{menucustomaction} for details about functions in these slots.}
  (:start-action ...)       @emph{; (lambda (inter first-obj-under-mouse))}
  (:running-action ...)     @emph{; (lambda (inter prev-obj-over new-obj-over))}
  (:stop-action ...)        @emph{; (lambda (inter final-obj-over))}
  (:abort-action ...)       @emph{; (lambda (inter last-obj-over))}
  (:outside-action ...)     @emph{; (lambda (inter outside-control prev-obj-over))}
  (:back-inside-action ...) @emph{; (lambda (inter outside-control prev-obj-over new-obj-over))}
...)
@end example

(Note: If you just want to use a pre-defined menu, it may be sufficient to use
one of the menu objects in the Garnet Gadget Set.)

The menu interactor is used (not surprisingly) mostly for menus. 
There is
typically some feedback to show where the mouse is while the interactor is
running. This is called the @emph{interim feedback}. A separate kind of
feedback might be used to show the final object selected. This is called
the @emph{final feedback}. 

Unlike button interactors (see section @ref{buttoninter}), Menu-interactors
allow the user to move from one item to another while the interactor is
running. For example, the user can press over one menu item, move the
mouse to another menu item, and release, and the second item is the one
that is selected.

There are a number of examples of the use of menu interactors below. Other
examples can be found in the @code{menu} gadget in the Garnet
Gadget Set, and in the file @code{demo-menu.lisp}.

@subsection Default Operation
@node Default Operation

This section describes how the menu interactor works
if the programmer does not remove or override any of the standard
@code{-action} procedures. To supply custom action procedures, see section
@ref{Menucustomaction}.

The menu interactor provides many different ways to control how the
feedback graphics are controlled. In all of these, the interactor sets
special slots in objects, and the graphics must have formulas that depend
on these slots.

@subsection Interim Feedback
@node Interim Feedback
@cindex{Interim Feedback (for menus)}
@anchor{menuinterimfeedback}
@cindex{Obj-Over (slot)}
@cindex{Interim-Selected (slot)}

To signify the object that the mouse is over as @emph{interim feedback} (while
the interactor is running), menu-interactors set two different slots. If
there is a feedback object supplied in the @code{:feedback-obj} slot of the
interactor, then the @code{:obj-over} slot of the feedback object is set to
the current menu item
object. Also, the @code{:interim-selected} slot of the current menu item is
set to T, and the  @code{:interim-selected} slots of all other items are set
to NIL. Note: there is always at most one interim-selected object,
independent of the value of the @code{:how-set} slot.

This supports two different ways to handle interim feedback:

@b{A single feedback object.}

@cindex{feedback-obj}
@cindex{Obj-Over (slot)}
@cindex{Visible (slot)}
This object should be supplied in the
@code{:feedback-obj} slot of the interactor. The @code{:obj-over} slot of this
object is set to the menu item that the feedback should appear over, or NIL
if there is no object. The following is an example of a typical reverse-video black
rectangle as a feedback object:
@cindex{feedback-rect}
@cindex{Examples}
@cindex{Feedback Rectangle}
@cindex{Examples}
@cindex{Obj-Over (slot)}
@example
(create-instance 'FEEDBACK-RECT opal:rectangle
   (:obj-over NIL) ;@i{set by the interactor}
   (:visible (o-formula (gvl :obj-over))) ;@i{this rectangle is visible}
                                          ;@i{only if over something}
   (:left (o-formula (gvl :obj-over :left)))
   (:top (o-formula (gvl :obj-over :top)))
   (:width (o-formula (gvl :obj-over :width)))
   (:height (o-formula (gvl :obj-over :height)))
   (:fast-redraw-p T)
   (:draw-function :xor)
   (:filling-style opal:black-fill)
   (:line-style NIL))
@end example

The interactor to use it would be something like:
@cindex{Examples}
@cindex{Menu Interactor}
@example
(create-instance 'SELECT-INTER Inter:Menu-Interactor
   (:start-where `(:element-of ,ITEMSAGG))
   (:feedback-obj FEEDBACK-RECT)
   (:window MYWINDOW))
@end example
The items that can be chosen are elements of an aggregate named ITEMSAGG.

@b{Multiple feedback objects.}

@cindex{interim-selected}
@cindex{Interim-Selected (slot)}
In this case, each item of the menu might have its own feedback object, or
else some property of that menu item object might change as the mouse moves
over it. Here, you would have formulas that depended on the
@code{:interim-selected} slot of the menu item. 

@sp 1
If there are separate objects associated with each menu item that will be
the interim feedback, then their visibility slot can simply be tied to the
@code{:interim-selected} slot. An example using an Aggregadget which is
the item-prototype for an AggreList (see the Aggregadgets manual) with an
embedded interactor is:
@cindex{Aggregadget}
@cindex{Aggrelist}
@cindex{Examples}
@cindex{Aggregadget}
@cindex{Examples}
@cindex{Aggrelist}
@cindex{Examples}
@cindex{Menu}
@example
(create-instance 'MYMENU opal:aggrelist
   (:items '("One" "Two" "Three"))
   (:item-prototype
    `(opal:aggregadget
      (:width ,(o-formula (gvl :str :width)))
      (:height ,(o-formula (gvl :str :height)))
      (:my-item ,(o-formula (nth (gvl :rank) (gvl :parent :items))))
      (:parts 
       `((:str ,opal:text
               (:string ,(o-formula (gvl :parent :my-item)))
               (:left ,(o-formula (gvl :parent :left)))
               (:top ,(o-formula (gvl :parent :top))))
         (:interim-feed ,opal:rectangle
          ;;@emph{The next slot causes the feedback to go on at the right time}
                        (:visible ,(o-formula (gvl :parent :interim-selected)))
                        (:left ,(o-formula (gvl :parent :left)))
                        (:top ,(o-formula (gvl :parent :top)))
                        (:width ,(o-formula (gvl :parent :width)))
                        (:height ,(o-formula (gvl :parent :height)))
                        (:fast-redraw-p T)
                        (:draw-function :xor)
                        (:filling-style ,opal:black-fill)
                        (:line-style NIL))))))
   (:interactors
    `((:inter ,Inter:Menu-Interactor
              (:start-where ,(o-formula (list :element-of (gvl :operates-on))))
              (:window ,MYWINDOW)))))
@end example

@subsection Final Feedback
@node Final Feedback
@cindex{Final Feedback (for menus)}
@anchor{menufinalfeedback}

@cindex{selected}
For some menus, the application just wants to know which item was selected,
and there is no graphics to show the final selection. In other cases,
there should be @emph{final feedback} graphics to show the object the mouse
ends up on. 

@cindex{Selected (slot)}
The Menu-Interactor supplies three ways to have graphics (or applications)
depend on the final selection. Both the @code{:selected} slot of the
individual item and the @code{:selected} slot of the aggregate
the items are in are set. The item's @code{:selected} slot is set with T or NIL, as
appropriate, and the aggregate's @code{:selected} slot is set with the
particular item(s) selected. The number of items that are
allowed to be selected is controlled by the @code{:how-set} slot of the
interactor, as described in section @ref{menuhowset}. 

Note that the aggregate's @code{:selected} slot often contains a list of
object names, but the @code{:selected} slot in the individual items will
always contain T or NIL.
The programmer is responsible for setting up constraints so that the
appropriate final feedback is shown based on the @code{:selected} field.

If there is no aggregate (because @code{:start-where} is
something like @code{(:in xxx)} rather than something
like @code{(:element-of xxx)}), then the slot of the object is set with T or
NIL. If the the @code{:start-where} is one of the ``list'' styles (e.g.
@code{(:list-element-of obj slot)}, then the
@code{:selected} slot of the object the list is stored in (here, @code{obj}) is
set as if that was the aggregate.

The third way to show the final feedback is to use the
@code{:final-feedback-obj} slot, which is described in the next section.

@subsection Final Feedback Objects
@node Final Feedback Objects
@cindex{final-feedback-obj}
@anchor{menufinalfeedbackobj}

The @code{:feedback-obj} slot can be used for the object to show the
interim-feedback, and the @code{:final-feedback-obj} slot can be used to hold
the object to show the final feedback. Garnet will set the @code{:obj-over} slot
of this object to the object that the interactor finishes on. If the
@code{:how-set} field of the interactor is one of the @code{:list-*} options,
then there might be @emph{multiple} final feedback objects needed to show all
the objects selected. In this case, the interactor creates instances of
object in the @code{:final-feedback-obj} slot. Therefore, this object should
@emph{not} be an @emph{aggregate}; it must be an @emph{aggregadget} instead (or
it can be a
single Opal object, such as a rectangle, circle, polyline, etc.).
Furthermore, the
final-feedback object itself should not be a @code{:part} of an aggregadget,
since you are not allowed to add new objects to an aggregadget with parts.

The @code{:final-feedback-obj} slot may contain a formula, which might compute
the appropriate feedback
object based on the object selected. The interactor will
automatically duplicate the appropriate feedback object if more than
one is needed (e.g., if @code{:how-set} is @code{:list-toggle}). One use
of this is to have different kinds of feedback for different kinds of
objects, and another would be to have different feedback objects in
different windows, for an interactor that works across multiple windows.
@cindex{current-obj-over}
@cindex{current-window}
To aid in this computation, the @code{:current-obj-over} slot of the
interactor is set with the object the mouse was last over, and the
@code{:current-window} slot of the interactor is maintained with the
window of the current event.

If the start-where is one of the @code{...-or-none} forms, then whenever the
user presses in the background, the final feedback objects are all turned off.

For examples of the use of final-feedback-objects, see MENU1 (the month menu)
or MENU2 (the day-of-the-week menu) in @code{demo-menu.lisp}.

@b{Useful Functions}

In order to help with final feedback objects, there are a number of
additional, useful functions. To get the final-feedback objects currently
being displayed by an interactor, you can use:

@cindex{Return-Final-Selection-Objs}
@example
inter:Return-Final-Selection-Objs @emph{inter}@ref{function}
@end example


If you want to reference the current final feedback objects in a
@emph{formula}, however,
then you should access the @code{:final-feed-inuse} slot of the menu
interactor. This slot contains
a list of the final feedback objects that are in use. @emph{Do not set
this slot}. 
This might be useful if you wanted to use the final feedback objects as the
start objects for another interactor (e.g, one to move the object selected
by a final-feedback object):
@cindex{final-feed-inuse}
@cindex{Examples}
@cindex{Final Feedback Objs}
@example
(create-instance NIL Inter:Move-Grow-Interactor
   ;; @emph{start when press on a final-feedback object of SELECT-INTER}
   (:start-where (formula `(list :list-element-of
                                 `,SELECT-INTER :final-feed-inuse)))
   ;;@emph{actually move the object which the feedback objects are over.}
   (:obj-to-change (o-formula (gvl :first-obj-over :obj-over)))
   ..... ; @emph{all the other slots}
   )
@end example

@cindex{SelectObj}
If a program wants to make an object be selected, it can call:
@example
inter:SelectObj @emph{inter obj}@ref{function}
@end example
which will cause the object to become selected. This uses the
@code{:how-set} slot of the interactor to decide whether to deselect the
other objects (whether single or multiple objects can be selected). The
@code{:selected} slots of the object and the aggregate are set, and the
final-feedback objects are handled appropriately. To de-select an object, use:
@cindex{DeSelectObj}
@example
inter:DeSelectObj @emph{inter obj}@ref{function}
@end example


@subsection Items Selected
@node Items Selected
@anchor{menuhowset}
@cindex{Single selection}
@cindex{Multiple selection}

The menu interactor will automatically handle control over the @emph{number}
of items selected. A slot of the interactor (@code{:how-set}) determines
whether a single item can be selected or multiple items. In addition, this
slot also determines how this interactor will affect the selected items.
For example, if multiple items can be selected, the most common option is
for the interactor to ``toggle'' the selection (so if the item under the
mouse was selected, it becomes de-selected, and if it was not selected,
then it becomes selected). Another design might use two interactors: one
to select items when the left button is pressed, and another to de-select items
when the right button is pressed. The @code{:how-set} slot provides for all
these options. 

@cindex{How-set}
In particular, the legal values for the @code{:how-set} slot are:

@vtable @code
@item @code{:set}
@cindex{set}
@cindex{Selected (slot)}
- Select the final item. One item is selectable at a time.
The aggregate's @code{:selected} slot is set with
this object. The item's @code{:selected} slot is set with T.

@item @code{:clear}
@cindex{clear}
- De-select the final item. At most one item is selectable at a time.
The aggregate's @code{:selected} slot is set to NIL.
(If some item other than the final item used to be selected, then that
other item becomes de-selected. I.e., using @code{:clear} always causes
there to be no selected items.)
The item's @code{:selected} slot is set to NIL. (This choice for how-set is
mainly useful when the menu item contains a single item that can be turned
on and off by different
interactors, e.g., left button turns it on and right button turns it
off. With a set of menu items, @code{:set} is usually more appropriate.)

@item @code{:toggle}
@cindex{toggle}
- Select if not selected, clear if selected. At most one item
is selectable at a time. This means that if there are a set of objects and
you select the object that used to be selected, then there becomes no
objects selected. (This is mainly useful when
there is a single button that can be turned on and off by one
interactor, each press changes the state. With a set of menu items,
@code{:list-toggle} or @code{:set} is usually more appropriate. However, this
option could be used
with a set of items if you wanted to allow the user to make there be
@emph{no} selection.)

@item @code{:list-add}
@cindex{list-add}
- If not in list of selected items, then add it. Multiple
items are selectable at a time. The item is added to the aggregate's
@code{:selected} slot using @code{pushnew}.
The item's @code{:selected} slot is set with T.

@item @code{:list-remove}
@cindex{list-remove}
- If in list of selected items, then remove it. Multiple
items selectable at a time. The item is removed from the aggregate's
@code{:selected} slot. The item's @code{:selected} slot is set with NIL.

@item @code{:list-toggle}
@cindex{list-toggle}
- If in list of selected items, then remove it, otherwise
add it. Multiple items are selectable at a time. The item is removed or
added to the aggregate's @code{:selected} slot. The
item's @code{selected} slot is set with T or NIL.

<a number> @cindex{numbers (used in :how-set slot)}
- Increment the @code{:selected} slot of the item by that amount
(which can be negative). The aggregate's @code{:selected} slot is set to
this object. The value of the item's selected slot should be a number.

<a list of two numbers>: @code{(inc mod)} - Increment the
@code{:selected} slot of the item by the @code{car} of the list, modulus the
@code{cadr} of the list. The aggregate's @code{:selected} slot is set to
this object. The value of the item's selected slot should be a number.
@end vtable

The default value for @code{:how-set} for menus is @code{:set}, so one item is
selected at a time.

@subsection Application Notification
@node Application Notification
@anchor{menufinalfunc}
@cindex{Selected (slot)}
To have an application notice the effect of the menu-interactor, you can
simply have some slot of some object in the application contain a formula
that depends on the aggregate's @code{:selected} slot. 

Alternatively, the programmer can provide a function to be called when the
interactor is complete by putting the function in the @code{:final-function}
slot. This function is called with the following arguments:
@cindex{final-function}
@cindex{Menu-Interactor}
@example
(lambda (an-interactor final-obj-over))
@end example

@subsection Normal Operation
@node Normal Operation
@cindex{Selected (slot)}

If the value of @code{:continuous} is T,
then when the start event happens, the interim feedback is turned on, as
described in section @ref{menuinterimfeedback}. If the mouse moves to a
different menu item, the interim feedback is changed to that item. If the
mouse moves outside, the interim feedback is turned off, unless @code{:outside} is
@code{:last} (see section @ref{outside}). If the interactor
aborts, the interim feedback is turned off. When the stop event happens, the
interim feedback is turned off, and the final @code{:selected} slots are set
as described in section @ref{menufinalfeedback} based on the value of the
@code{:how-set} parameter (section @ref{menuhowset}), then the @code{:obj-over}
field of the final-feedback-obj is set to the final selection (possibly
after creating a new final feedback object, if necessary), as described in
section @ref{menufinalfeedbackobj}. Then the final-function
(if any) is called (section @ref{menufinalfunc}).

If the interactor is @emph{not} continuous, when the start event happens, the
@code{:selected} slots are set based on the value of the @code{:how-set} parameter,
the @code{:obj-over} slot of the final-feedback-obj is set, and then the
final-function is called.


@subsection Slots-To-Set
@node Slots-To-Set
@anchor{slots-to-set}
@cindex{slots-to-set}
The button and menu interactors by default set the @code{:selected}
and @code{:interim-selected} slots of objects. This sometimes results
in a conflict when two interactors are attached to the same object.
Therefore, the @code{:slots-to-set} slot has been provided in which you
may specify what slot names should be used. Note: it is very
important that once an interactor is started, the slot names for it
should never change.

The @code{:slots-to-set} slot takes a list of three values:
@example
 (<interim-selected-slot-name-in-obj>
  <selected-slot-name-in-obj>
  <selected-slot-name-in-aggregate> )
@end example
The default value is @code{(:interim-selected :selected :selected)}. If
NIL is supplied for any slot name, then that slot isn't set by the
interactor.

The slots in the object are
set with T or NIL, and the slot in the aggregate is set with the
selected object or a list of the selected objects.


@section Button-Interactor
@node Button-Interactor
@cindex{Button-Interactor}
@anchor{buttoninter}

@example
(create-instance 'inter:Button-Interactor inter:interactor
  @emph{;; Slots common to all interactors (see section @ref{interslots})}
  (:start-where NIL)
  (:window NIL)
  (:start-event :leftdown)
  (:continuous T)
  (:stop-event NIL)
  (:running-where '(:in *))
  (:outside NIL)
  (:abort-event :control-\g)
  (:waiting-priority normal-priority-level)
  (:running-priority running-priority-level)
  (:active T)
  (:self-deactivate NIL)

  @emph{; Slots common to the menu-interactor and the button-interactor (see section @ref{menuinter})}
  (:final-function NIL)      @emph{; (lambda (inter final-obj-over))}
  (:how-set :list-toggle)    @emph{; How to select new items (toggle selection, etc.)}
  (:feedback-obj NIL)        @emph{; Optional interim feedback object. The inter will set this object's :obj-over slot.}
  (:final-feedback-obj NIL)  @emph{; The optional object to indicate the final selection}
  (:slots-to-set             @emph{; Names of slots to set in the objects}
   '(:interim-selected       @i[;   '(<interim-selected-slot-name-in-obj>]
     :selected               @emph{;     <selected-slot-name-in-obj>]
     :selected})             @emph{;     <selected-slot-name-in-aggregate>}]
  (:final-feed-inuse NIL)    @emph{; Read-only slot. A list of final feedback objects (section @ref{menufinalfeedbackobj})}

  @emph{; Slots specific to the button-interactor (discussed in this section)}
  (:timer-repeat-p NIL)        @emph{; when T, then does timer}
  (:timer-initial-wait 0.75)   @emph{; time in seconds}
  (:timer-repeat-wait 0.05)    @emph{; time in seconds}

  @emph{; @b{Advanced feature:}  Read-only slots.}
  @emph{; See section @ref{specialslots} for details about these slots.}
  (:first-obj-over NIL)     @emph{; Read-only slot. The object returned from the start-where.}
  (:current-window NIL)     @emph{; Read-only slot. The window of the last (or current) event.}
  (:start-char NIL)         @emph{; Read-only slot. The character or keyword of the start event.}

  @emph{; @b{Advanced feature:} Customizable action routines.}
  @emph{; See sections @ref{interslots} and @ref{buttoncustomaction} for details about functions in these slots.}
  (:start-action ...)       @emph{; (lambda (inter obj-under-mouse))}
  (:stop-action ...)        @emph{; (lambda (inter final-obj-over))}
  (:abort-action ...)       @emph{; (lambda (inter last-obj-over))}
  (:outside-action ...)     @emph{; (lambda (inter last-obj-over))}
  (:back-inside-action ...) @emph{; (lambda (inter new-obj-over))}
...)
@end example

@sp 1
(Note: If you
just want to use a pre-defined set of buttons, it may be sufficient to use
the radio buttons or x-button objects from the Garnet Gadget Set.

The button interactor is used (not surprisingly) mostly for buttons. There is
typically some feedback to show where the mouse is while the interactor is
running. This is called the @emph{interim feedback}. A separate kind of
feedback might be used to show the final object selected. This is called
the @emph{final feedback}. 

Unlike menu interactors (see section @ref{menuinter}), Button-interactors
do not allow the user to move from one item to another while the interactor is
running. For example, if there are a group of buttons, and the user
presses over one button, moving to a different button in the set does
@emph{not} cause the other button to become selected. Only the first button
that the user presses over can be selected. This is similar to the way
radio buttons and check boxes work on the Macintosh.

There are a number of examples of the use of button interactors below. Other
examples can be found in the demos for the @code{radio-button} and @code{x-button}
gadgets in the Garnet Gadget Set, and in the file @code{demo-grow.lisp}.

@subsection Default Operation
@node Default Operation

The button interactor works very similar to the menu interactor (section
@ref{menuinter}).
This section describes how the button interactor works
if the programmer does not remove or override any of the standard
@code{-action} procedures. To supply custom action procedures, see section
@ref{buttoncustomaction}.

The button interactor provides the same ways to control the feedback as the
menu interactor.

@verbatim
*******************************************************************
@end verbatim

@subsection Interim Feedback
@node Interim Feedback
@cindex{Interim Feedback (for buttons)}
@anchor{buttoninterimfeedback}

@cindex{Obj-Over (slot)}
@cindex{Interim-Selected (slot)}
As with menus, button-interactors set both the @code{:obj-over} slot of
the object in the @code{:feedback-obj} slot, and the @code{:interim-selected}
slot of the current button item. The @code{:obj-over} slot is set with the
object that is under the mouse or NIL if none, and the
@code{:interim-selected} slot is set with T or NIL. See section
@ref{menuinterimfeedback} for more information.

@subsection Final Feedback
@node Final Feedback
@anchor{buttonfinalfeedback}
@cindex{Final Feedback (for buttons)}
@cindex{Selected (slot)}

@cindex{selected}
The final feedback for buttons works the same way as for menus: 
Both the @code{:selected} slot of the
individual item and the @code{:selected} slot of the aggregate
the items are in are set, and the @code{:obj-over} slot of the object in the
@code{:final-feedback-obj} slot (if any) is set.
The item's @code{:selected} slot is set with T or NIL, as
appropriate, and the aggregate's @code{:selected} slot is set with the
name(s) of the particular item(s) selected.

For more information, see sections @ref{menufinalfeedback} and
@ref{menufinalfeedbackobj}.

@subsection Items Selected
@node Items Selected
@anchor{buttonhowset}

As with Menus, the button interactor will automatically handle control over
the @emph{number}
of items selected. A slot of the interactor (@code{:how-set}) determines
whether a single item can be selected or multiple items. In addition, this
slot also determines how this interactor will affect the selected items.

The legal values for @code{:how-set} are exactly the same as for menu (see
section @ref{menuhowset}:
@code{:set}, @code{:clear}, @code{:toggle}, @code{:list-add}, @code{:list-remove},
@code{:list-toggle}, a number, or a list of two numbers).

The default for buttons is @code{:list-toggle}, however.


@subsection Application Notification
@node Application Notification
@anchor{buttonfinalfunc}

@cindex{Selected (slot)}
As with menus, to have an application notice the effect of the
button-interactor, you can
simply have some slot of some object in the application contain a formula
that depends on the aggregate's @code{:selected} slot. 

Alternatively, the programmer can provide a function to be called when the
interactor is complete by putting the function in the @code{:final-function}
slot. This function is called with the following arguments:
@cindex{final-function}
@cindex{Button-Interactor}
@example
(lambda (an-interactor final-obj-over))
@end example

@subsection Normal Operation
@node Normal Operation

@verbatim
*******************************************************************
@end verbatim

@cindex{Selected (slot)}
If the value of @code{:continuous} is T,
then when the start event happens, the interim feedback is turned on, as
described in section @ref{buttoninterimfeedback}. If the mouse moves away
from the item it starts on, the interim feedback goes off. If the mouse
moves back, the interim feedback goes back on. If the interactor
aborts, the interim feedback is turned off. When the stop event happens,
the interim feedback is turned off.
If the mouse is over the item that the interactor started on, the
final @code{:selected} slots are set
as described in section @ref{buttonfinalfeedback} based on the value of the
@code{:how-set} parameter (section @ref{buttonhowset}), then the @code{:obj-over}
field of the final-feedback-obj is set to the final selection (possibly
after creating a new final feedback object, if necessary), as described in
section @ref{menufinalfeedbackobj}. Then the final-function
(if any) is called (section @ref{buttonfinalfunc}). Otherwise, when the
stop event happens, the interactor aborts.

The @code{:last} parameter is ignored by button interactors.

If the interactor is @emph{not} continuous, when the start event happens, the
@code{:selected} slots are set based on the value of the @code{:how-set} parameter,
the @code{:obj-over} slot of the final-feedback-obj is set, and then the
final-function is called.

The @code{:slots-to-set} slot can be used to change the name of the slots
that are set, as described in section @ref{slots-to-set}.



@subsection Auto-Repeat for Buttons
@node Auto-Repeat for Buttons
@cindex{Auto-Repeat}

The @code{button-interactor} can auto-repeat the @code{:final-function}.
@emph{Note: This only works for Allegro, LispWorks, and Lucid lisps
(including Sun and HP CL); @emph{not} for CMU CL, AKCL, etc.}

@cindex{timer-repeat-p}
@cindex{timer-initial-wait}
If @code{:timer-repeat-p} is non-NIL, then after the interactor starts,
if the mouse button is held down more than @code{:timer-initial-wait}
seconds, then every @code{:timer-repeat-wait} seconds, the
@code{:final-function} is called and the appropriate slot (usually
@code{:selected}) is set into the object the interactor is operating
over (this might be useful, for example, if the @code{:how-set} was an integer to
cause the value of the @code{:selected} slot to increment each time).

The various scroll bar and slider gadgets use this feature to cause the
arrows to auto repeat.



@subsection Examples
@node Examples
@subsection Single button
@node Single button
@cindex{Incrementing Button}
@cindex{Examples}
@cindex{Incrementing Button}
@cindex{Examples}
@cindex{Button}
The button in this example is not continuous, and does not have a final
feedback; it just causes a value to be incremented.
@example
(create-instance 'ARROW-INC opal:aggregadget
   (:parts
    `((:arrow ,opal:polyline
              (:selected 10)
              (:point-list (20 40 20 30 10 30 25 15 40 30 30 30 30 40 20 40)))
      (:label ,opal:text
              (:left 17)(:top 50)
              (:string ,(o-formula (prin1-to-string
				    (gvl :parent :arrow :selected)))))))
   (:interactors
    `((:incrementor ,Inter:Button-Interactor
                    (:continuous NIL)
                    (:start-where ,(o-formula (list :in (gvl :operates-on :arrow))))
                    (:window ,MYWINDOW)
                    (:how-set 3)))))  ; increment by 3
@end example

@subsection Single button with a changing label
@node Single button with a changing label
@cindex{Changing Label Button}
@cindex{Examples}
@cindex{Changing Label Button}
@cindex{Examples}
@cindex{Button}
Here we have an object whose label changes every time the mouse is pressed
over it. It cycles through a set of labels.
This interactor is not continuous, so the action happens immediately on the
down-press and there is no feedback object.

@example
(create-instance 'CYCLE-STRING opal:aggregadget
  (:parts
   `((:label ,opal:text
             (:left 10)(:top 80)
             (:selected 0)
             (:choices ("USA" "Japan" "Mexico" "Canada"))
             (:string ,(o-formula (nth (gvl :selected) (gvl :choices)))))))
  (:interactors
   `((:incrementor ,Inter:Button-Interactor
	           (:continuous NIL)
		   (:start-where
		     ,(o-formula (list :in (gvl :operates-on :label))))
		   (:window ,MYWINDOW)
		   ;; @i{use a list of 2 numbers and interactor will do MOD}
		   (:how-set
                     ,(o-formula (list 1 (length (gvl :operates-on
                                                      :label :choices)))))))))
@end example



@section Move-Grow-Interactor
@node Move-Grow-Interactor
@cindex{Move-Grow-Interactor}
@anchor{MOVEGROWINTER}

@example
(create-instance 'inter:Move-Grow-Interactor inter:interactor
  @emph{;; Slots common to all interactors (see section @ref{interslots})}
  (:start-where NIL)
  (:window NIL)
  (:start-event :leftdown)
  (:continuous T)
  (:stop-event NIL)
  (:running-where NIL)
  (:outside NIL)
  (:abort-event :control-\g)
  (:waiting-priority normal-priority-level)
  (:running-priority running-priority-level)
  (:active T)
  (:self-deactivate NIL)

  @emph{; Slots specific to the move-grow-interactor (discussed in this section)}
  (:final-function NIL)      @emph{; (lambda (inter obj-being-changed final-points))}
  (:line-p NIL)              @emph{; If NIL, set :box slot of object. If T, set :points slot}
  (:grow-p NIL)              @emph{; If T, grow the object instead of move it}
  (:obj-to-change NIL)       @i[; The object to move or grow (usually this is automatically set to be the object]
                             @emph{; returned from the start-where)}
  (:attach-point :where-hit) @emph{; Where the mouse will attach to the object}
  (:min-width 0)             @emph{; Minimum width for any object being grown}
  (:mih-height 0)            @emph{; Minimum height for any object being grown}
  (:min-length NIL)          @emph{; Minimum length of any line being grown}
  (:feedback-obj NIL)        @emph{; Optional interim feedback object. The inter will set this object's :obj-over slot}
                             @emph{; and either its :box or :points slot.}
  (:slots-to-set :box)       @emph{; Names of slots to set in the objects. @b{Note:} :box = :points because of :line-p slot.}
  (:input-filter NIL)        @emph{; Used for gridding}

  @emph{; @b{Advanced feature:}  Read-only slots.}
  @emph{; See section @ref{specialslots} for details about these slots.}
  (:first-obj-over NIL)     @emph{; Read-only slot. The object returned from the start-where.}
  (:current-window NIL)     @emph{; Read-only slot. The window of the last (or current) event.}
  (:start-char NIL)         @emph{; Read-only slot. The character or keyword of the start event.}

  @emph{; @b{Advanced feature:} Customizable action routines.}
  @emph{; See sections @ref{interslots} and @ref{movegrowcustomaction} for details about functions in these slots.}
  (:start-action ...)       @emph{; (lambda (inter obj-being-changed first-points))}
  (:running-action ...)     @emph{; (lambda (inter obj-being-changed new-points))}
  (:stop-action ...)        @emph{; (lambda (inter obj-being-changed final-points))}
  (:abort-action ...)       @emph{; (lambda (inter obj-being-changed))}
  (:outside-action ...)     @emph{; (lambda (inter outside-control obj-being-changed))}
  (:back-inside-action ...) @emph{; (lambda (inter outside-control obj-being-changed new-inside-points))}
...)
@end example

This is used to move or change the size of an object or one of a set
of objects with the mouse. This is quite a flexible interactor and
will handle many different behaviors including: moving the indicator
in a slider, changing the size of a bar in a thermometer, changing the
size of a rectangle in a graphics editor, changing the position of a
circle, and changing an end-point of a line.

The interactor can either be permanently tied to a particular graphics
object, or it will get the object from where the mouse is when the
interaction starts. There may be a feedback object to show where the
object will be moved or changed to, or the object itself may change with
the mouse.

There are a number of examples of the use of move-grow-interactors
below. Other 
examples can be found in sections @ref{movegrowexample1},
@ref{movegrowexample2}, and @ref{movegrowexample3}, in
the @code{graphics-selection} gadget in
the Garnet Gadget Set, and in the files @code{demo-grow.lisp},
@code{demo-moveline.lisp}, @code{demo-scrollbar.lisp} and @code{demo-manyobjs.lisp}.

@subsection Default Operation
@node Default Operation

This section describes how the @code{move-grow-interactor} works
if the programmer does not remove or override any of the standard
@code{-action} procedures. To supply custom action procedures, see section
@ref{movegrowcustomaction}.

@cindex{box (slot)}
The feedback object (if any) @emph{and}
the object being edited are modified indirectly, by setting slots called
@code{:box} or @code{:points}. The programmer must provide constraints between
these slots and the @code{:left}, @code{:top}, @code{:width}, and
@code{:height} slots or the @code{:x1, :y1, :x2,} and @code{:y2} slots (as
appropriate). For example, a rectangle that can be moved and changed
size with the mouse might have the following definition:
@anchor{howobjsdefined}
@cindex{Moving-Rectangle}
@cindex{Examples}
@cindex{Moving-Rectangle}
@cindex{Examples}
@cindex{Box (slot)}
@example
(create-instance 'MOVING-RECTANGLE opal:rectangle
   (:box (list 0 0 10 10))  ;@i{some initial values (x, y, width, height)}
   (:left (o-formula (first (gvl :box))))
   (:top (o-formula (second (gvl :box))))
   (:width (o-formula (third (gvl :box))))
   (:height (o-formula (fourth (gvl :box)))))
@end example
A movable line could be defined as:
@cindex{Moving-Line}
@cindex{Points (slot)}
@cindex{Box (slot)}
@cindex{Examples}
@cindex{Moving-Line}
@example
(create-instance 'MOVING-LINE opal:line
   (:points (list 0 0 10 10))  ;@i{some initial values (x1 y1 x2 y2)}
   (:x1 (o-formula (first (gvl :points))))
   (:y1 (o-formula (second (gvl :points))))
   (:x2 (o-formula (third (gvl :points))))
   (:y2 (o-formula (fourth (gvl :points)))))
@end example

The slot @code{:line-p} tells the interactor whether to change the @code{:box}
slot or the @code{:points} slot.
If @code{:line-p} is NIL (the default), then the interactor changes the
object by setting its
@code{:box} slot to a list containing the new values for (left, top, width,
height). If T, then the interactor changes the object by setting its
@code{:points} slot to a list containing the new values for (x1, y1, x2, y2).
(These are the same slots as used for
@code{two-point-interactor}, section @ref{twopoint}).

This allows the object to perform any desired filtering on the values
before they are used in the real @code{:left :top :width :height} or
@code{:x1 :y1 :x2 :y2} slots. For example, a scroll bar might be defined as
follows:
@cindex{Scroll Bar}
@cindex{Examples}
@cindex{Scroll Bar}
@example
(create-instance 'MYSCROLLER opal:aggregadget
   (:parts
    `((:outline ,opal:rectangle
		(:left 100)(:top 10)(:width 20)(:height 200))
      (:indicator ,opal:rectangle
		  (:box (52 12 16 16)) ;;@i{only the second value is used}
		  (:left ,(o-formula (+ 2 (gvl :parent :outline :left))))
		  ;;@i{Clip-And-Map clips the first parameter to keep it}
		  ;;@i{ between the other two parameters, see section @ref{clipandmap}}
		  (:top ,(o-formula
			  (Clip-And-Map (second (gvl :box))
			    12  ;@i{Top of outline + 2}
			    192 ;@i{Bottom of outline - indicator height - 2}
			    )))
		  (:width 16)(:height 16)
		  (:filling-style ,opal:gray-fill)
		  (:line-style NIL)
		  (:fast-redraw-p T)
		  (:draw-function :xor))))
   (:interactors
    `((:move-indicator ,Inter:Move-Grow-Interactor
		       (:start-where
		        ,(o-formula (list :in (gvl :operates-on :indicator))))
		       (:window ,(o-formula (gvl :operates-on :window)))))))
@end example
		
This interactor will either change the position of the object (if
@code{:grow-p} is NIL) or the size. For lines, (if @code{:line-p} is T),
``growing'' means changing a single end point to follow the mouse while the
other stays fixed, and moving means changing both end points to follow the
mouse so that the line keeps the same length and slope.

Since an object's size can change from the left and
top, in addition to from the right and bottom, and since objects are
defined to by their left, top, width and height, this interactor may have
to change any of the left, top, width and height fields when changing an
object's size. For example, to
change the size of an object from the left (so that the left moves and the
right side stays fixed), both the @code{:left} and @code{:width} fields must be
set. Therefore, by default, this interactor sets a @code{:box} field
containing 4 values. When the interactor is used for moving an object, the
last two values of the @code{:box} slot are set with the original width and
height of the object. Similarly, when setting the @code{:points} slot, all
of the values are set, even though only two of them will change.

When the interaction is running, either the object itself or a separate
@emph{feedback} object can follow the mouse. If a feedback object is used, it
should be specified in the @code{:feedback-obj} slot of the interactor, and
it will need the same kinds of formulas on @code{:box} or @code{:points} as the
actual object. If
the object itself should change, then @code{:feedback-obj} should be NIL.
If there is a feedback object, the interactor also sets its
@code{:obj-over} field to the actual object that is being moved.
This can be used, for example,
to control the visibility of the feedback object or its size.

The object being changed is
either gotten from the @code{:obj-to-change} slot of the interactor, or if
that is NIL, then from the object returned from @code{:start-where}.
If the interactor is to work over
multiple objects, then @code{:obj-to-change} should be NIL, and @code{:start-where}
will be one of the forms that returns one of a set of objects (e.g., 
@code{:element-of}).

@subsection Attach-Point
@node Attach-Point
@anchor{attachpoint} 
@cindex{attach-point}
The @code{:attach-point} slot of interactors controls where the mouse will
attach to the object. The legal choices
depend on @code{:line-p}.

If @code{:line-p} is T (so the end-point of the line
is changing), and the object is being grown, then legal choices are:

@table @code
@item @code{1}: Change the first endpoint of the line (x1, y1).

@item @code{2}: Change the second endpoint of the line (x2, y2).

@item @code{:where-hit}: Change which-ever end point is nearest the
initial press.
@end table

If @code{:line-p} is T and the object is being moved, then legal choices are:

@table @code
@item @code{1}: Attach mouse to the first endpoint.

@item @code{2}: Attach mouse to the second endpoint.

@item @code{:center}: Attach mouse to the center of the line.

@item @code{:where-hit}: Attach mouse where pressed on the line.
@end table

If @code{:line-p} is NIL (so the bounding box is changing, either moving or
growing) the choices are:

@table @code 
@item @code{:N} - Top

@item @code{:S} - Bottom

@item @code{:E} - Right

@item @code{:W} - Left

@item @code{:NE} - Top, right

@item @code{:NW} - Top, left

@item @code{:SE} - Bottom, right

@item @code{:SW} - Bottom, left

@item @code{:center} - Center

@item @code{:where-hit} - The mouse attaches to the object
wherever the mouse was first pressed inside the object.
@end table

The default value is @code{:where-hit} since this works for both @code{:line-p}
T and NIL.

If growing and @code{:attach-point} is @code{:where-hit}, the object
grows from the nearest side or corner (the object is implicitly divided into 9
regions). If the press is in the center, the object grows from the
@code{:NW} corner.

@c In the future, we might
@c support growing from the center like X10/uwm, where it uses the first
@c direction you move in to decide which side or corner of the object to
@c change size from.

The value set into the @code{:box} slot by this interactor is always the correct value
for the top, left corner, no matter what the value of attach-point (the
interactor does the conversion for you). Note that the conversion is done
based on the @code{:left, :top, :width} and @code{:height} of the actual object being changed; not based on the feedback object.
Therefore, if there is a separate feedback object, either
the feedback object should be the same size as the object being changed, or
@code{:attach-point} should be @code{:NW}.
@b{Possible future enhancement:
allow a list of points, and pick the closest one to the mouse.}

@subsection Running where
@node Running where
Normally, the default value for @code{:running-where}
is the same as @code{:start-where}, but for the move-grow-interactor, the
default @code{:running-where} is T, to allow the mouse to go anywhere.

@subsection Extra Parameters
@node Extra Parameters

The extra parameters are:
@vtable @code 

@item @code{:line-p}
@cindex{line-p}
- This slot determines whether the object's bounding box or line end points
are set. If @code{:line-p} is NIL, then the @code{:box} slot is set to a list
containing (left top width height) and if @code{:line-p} is T, then the
@code{:points} slot is set with a list containing (x1 y1 x2 y2).
The default is NIL.

@item @code{:grow-p}
@cindex{grow-p}
- This slot determines whether the
object moves or changes size. The
default is NIL, which means to move. Non-NIL means to change size.

@item @code{:obj-to-change}
@cindex{obj-to-change}
- If an object is supplied as this parameter, then the interactor changes
that object. Otherwise, the interactor changes the object returned from
@code{:start-where}. If the interactor should
change one of a set of objects, then @code{:obj-to-change} should be NIL and
@code{:start-where} should be be a form that will return the object to change.
The reason that there may need to be a separate object passed
as the @code{:obj-to-change}
is that sometimes the interactor cannot get the object to be changed
from the :where fields. For example, the programmer may want to have a
scroll bar indicator changed whenever the user presses over the background.
The object in the @code{:obj-to-change} field may be 
different from the one in the @code{:feedback-obj} since the object in the
@code{:feedback-obj} field is used as the interim feedback.

@item @code{:attach-point}
@cindex{attach-point}
- This tells where the mouse will attach to the object. Values are
@code{1, 2, :center} or @code{:where-hit} if @code{:line-p} is T, or @code{:N, :S, :E, :W,
:NW, :NE, :SW, :SE, :center,} or @code{:where-hit} if @code{:line-p} is NIL.
The default value is @code{:where-hit}.
See section @ref{attachpoint} for a full explanation.

@item @code{:min-width}
@cindex{min-width}
- The @code{:min-width} and @code{:min-height} fields determine the minimum
legal width and height of the object if @code{:line-p} is NIL and
@code{:grow-p} is T.
Default is 0. If @code{:min-width} or @code{:min-height} is NIL, then there is no
minimum width or height. In this case, the width and height of the object
may become negative values which causes an error (so this is not recommended).
Unlike the @code{two-point-interactor} (section @ref{twopoint}),
there are no @code{:flip-if-change-side} or @code{:abort-if-too-small} slots for
the @code{move-grow-interactor}.

@item @code{:min-height}
@cindex{min-height}
- See @code{:min-width}.

@item @code{:min-length}
@cindex{min-length}
- If @code{:line-p} is T, this specifies the minimum length for lines. The
default is NIL, for no minimum. This slot is ignored if @code{:line-p} is NIL.

@item @code{:input-filter}
@cindex{input-filter}
- Used to support gridding. See section @ref{gridding}
@end vtable


@subsection Application Notification
@node Application Notification

Often, it is not necessary to have the application notified of the result
of a move-grow-interactor, if you only want the object to move around.
Otherwise, you can have constraints in the application to the various slots
of the object being changed.

Alternatively, the programmer can provide a function to be called when the
interactor is complete by putting the function in the @code{:final-function}
slot. This function is called with the following arguments:
@cindex{final-function}
@cindex{Move-Grow-Interactor}
@example
(lambda (an-interactor object-being-changed final-points))
@end example
@code{Final-points} is a list of four values, either the left, top, width and
height if @code{:line-p} is NIL, or x1, y1, x2, and y2 if @code{:line-p} is T.

@subsection Normal Operation
@node Normal Operation

@cindex{Obj-Over (slot)}
If the value of @code{:continuous} is T,
then when the start event happens, the interactor determines the object to
be changed as
either the value of the @code{:obj-to-change} slot, or if that is NIL, then
the object returned from the @code{:start-where}.
The @code{:obj-over} slot of the object in
the @code{:feedback-obj} slot of the interactor is set to the object being changed.
Then, for every mouse movement until the stop event happens, the interactor sets
either the @code{:box} slot or the @code{:points} slot (depending on the value
of @code{:line-p}) based on a calculation that depends on the values in the
minimum slots and @code{:attach-point}. The object that is modified while
running is either the feedback object if it exists or the object being changed
if there is no feedback object.

@cindex{visible (slot)}
If the mouse goes outside of @code{:running-where}, then if @code{:outside} is
@code{:last}, nothing happens until the mouse comes back inside or the stop
or abort events happen (the object stays at its last legal inside value).
If @code{:outside} is NIL, then the feedback
object's @code{:obj-over} slot is set to NIL (so there should be a formula in
the feedback object's @code{:visible} slot that depends on @code{:obj-over}).
If there is no feedback object and the mouse goes outside, then the object
being changed is returned to its original size and position (before the
interactor started).

If the abort event happens, then the feedback
object's @code{:obj-over} slot is set to NIL, or if there is no feedback
object, then the object being changed is returned to its original size and
position (before the interactor started).

When the stop event happens, the feedback object's @code{:obj-over} slot is
set to NIL, and the @code{:box} or @code{:points} slot of the actual object are
set with the last value, and the final-function
(if any) is called.

If the interactor is @emph{not} continuous, when the start event happens, the
@code{:box} or @code{:points} slot of the actual object are
set with the initial value, and the final-function
(if any) is called. This is probably not very useful.

@subsection Gridding
@node Gridding
@anchor{gridding}
@cindex{gridding}
@cindex{gravity}
The @code{move-grow-interactor} supports arbitrary gridding of the
values. The slot @code{:input-filter} can take any of the following
values:

@itemize
@item @code{NIL} -  for no filtering. This is the default.

@item a number - grid by that amount in both X and Y with the origin at the
upper left corner of the window.

@item a list of four numbers: @code{(xmod xorigin ymod yorigin)} to allow
non-uniform gridding with a specific origin.

@item a function of the form @code{(lambda(inter x y) ...)} which returns
@code{(values gridx gridy)}. This allows arbitrary filtering of the
values, including application-specific gravity to interesting
points of other objects, snap-dragging, etc.
@end itemize

@subsection Setting Slots
@node Setting Slots

@cindex{slots-to-set}
@cindex{box}
@cindex{points}
The @code{move-grow-interactor} by default sets either the @code{:box} or
@code{:points} slots of objects (depending on whether it was a rectangle
or line-type object). We discovered that there were a large number of
formulas that simply copied the values out of these lists. Therefore,
in the current version, you can ask the @code{move-grow-interactor} to
directly set the slots of objects, if you don't need any filtering
on the values. If you want to use @code{Clip-and-Map} or other
filtering, you should still use the @code{:box} slot. The slot
@code{:slots-to-set} can be supplied to determine which slots to set.
The values can be:

@table @code
@item @code{:box}
if line-p object, then sets
the @code{:points} slot, otherwise sets the @code{:box} slot.

@item @code{:points}
same as @code{:box}. Note that the interactor ignores the
actual value put in @code{:slots-to-set} and decides which to use based
on the value of the @code{:line-p} slot of the object.

@item a list of four T's and NILs (representing @code{(:left :top :width :height)}
or @code{(:x1 :y1 :x2 :y2)})
In this case,
the interactor sets the slots of the 
object that have T's and doesn't set the slots that are NIL. For
example, if @code{:slots-to-set} is @code{(T T NIL NIL)}, then the
interactor will set the @code{:x1} and @code{:y1} slots of objects that
are @code{:line-p}, and the @code{:left} and @code{:top} slots of all other
objects.

@item a list of four slot names or NILs
In this case, the values are set
into the specified slots of the object. Any NILs mean that slot isn't
set. The specified slots are used whether the object is @code{:line-p} or
not. This can be used to map the four values into new slots.
@end table



@subsection Useful Function: Clip-And-Map
@node Useful Function: Clip-And-Map
@cindex{Clip-And-Map}
@anchor{clipandmap}
It is often useful to take the value returned by the mouse and clip it
within a range. The function @code{Clip-And-Map} is provided by the
interactors package to help with this:
@example
inter:Clip-And-Map @emph{val  val-1  val-2} &optional @emph{target-val-1  target-val-2}@ref{function}
@end example

If @emph{target-val-1} or @emph{target-val-2} is NIL or not supplied, then this
function just clips @emph{val} to be between @emph{val-1} and @emph{val-2} (inclusive).

If @emph{target-val-1} and @emph{target-val-2} are supplied, then this function 
clips @emph{val} to be in the range @emph{val-1} to @emph{val-2}, and then
then scales and translates the value (using linear-interpolation) to be between
@emph{target-val-1} and @emph{target-val-2}. 

@emph{Target-val-1} and @emph{target-val-2} should be integers, but @emph{val},
@emph{val-1} and @emph{val-2} can be any kind of numbers. @emph{Val-1} can
either be less or greater than @emph{val-2} and @emph{target-val-1} can be less
or greater than @emph{target-val-2}.

Examples:
@cindex{Examples}
@cindex{Clip-And-Map}
@example
(clip-and-map 5 0 10) => 5
(clip-and-map 5 10 0) => 5
(clip-and-map -5 0 10) => 0
(clip-and-map 40 0 10) => 10
(clip-and-map 5 0 10 100 200) => 150
(clip-and-map -5 0 10 100 200) => 100
(clip-and-map 0.3 0.0 1.0 0 100) => 30
(clip-and-map 5 20 0 100 200) => 175

@emph{;; Formula to put in the :percent slot of a moving scroll bar indicator.
;; Clip the moving indicator position to be between the top and bottom of
;; the slider-shell (minus the height of the indicator to keep it inside),
;; and then map the value to be between 0 and 100.}
(formula `(Clip-and-Map (second (gvl :box))
			(gv ',SLIDER-SHELL :top)
			(- (gv-bottom ',SLIDER-SHELL) (gvl :height) 2)
			0 100))
@end example


@section Two-Point-Interactor
@node Two-Point-Interactor
@cindex{Two-Point-Interactor}
@anchor{twopoint}

@example
(create-instance 'inter:Two-Point-Interactor inter:interactor
  @emph{;; Slots common to all interactors (see section @ref{interslots})}
  (:start-where NIL)
  (:window NIL)
  (:start-event :leftdown)
  (:continuous T)
  (:stop-event NIL)
  (:running-where NIL)
  (:outside NIL)
  (:abort-event :control-\g)
  (:waiting-priority normal-priority-level)
  (:running-priority running-priority-level)
  (:active T)
  (:self-deactivate NIL)

  @emph{; Slots specific to the two-point-interactor (discussed in this section)}
  (:final-function NIL)      @emph{; (lambda (inter final-point-list))}
  (:line-p NIL)              @emph{; Whether to set the :box or :points slot of the feedback-obj}
  (:min-width 0)             @emph{; Minimum width for new rectangular region}
  (:mih-height 0)            @emph{; Minimum height for new rectangular region}
  (:min-length NIL)          @emph{; Minimum length for new line}
  (:abort-if-too-small NIL)  @emph{; Whether to draw feedback and execute final function when the selected region}
                             @emph{; is smaller than the minimum}
  (:feedback-obj NIL)        @emph{; Optional interim feedback object. The inter will set this object's :visible slot}
                             @emph{and its :points or :box slot.}
  (:flip-if-change-side T)   @emph{; Whether to flip origin of rectangle when appropriate}
  (:input-filter NIL)        @emph{; Used for gridding (see section @ref{gridding})}

  @emph{; @b{Advanced feature:}  Read-only slots.}
  @emph{; See section @ref{specialslots} for details about these slots.}
  (:first-obj-over NIL)     @emph{; Read-only slot. The object returned from the start-where.}
  (:current-window NIL)     @emph{; Read-only slot. The window of the last (or current) event.}
  (:start-char NIL)         @emph{; Read-only slot. The character or keyword of the start event.}

  @emph{; @b{Advanced feature:} Customizable action routines.}
  @emph{; See sections @ref{interslots} and @ref{twopcustomaction} for details about functions in these slots.}
  (:start-action ...)       @emph{; (lambda (inter first-points))}
  (:running-action ...)     @emph{; (lambda (inter new-points))}
  (:stop-action ...)        @emph{; (lambda (inter final-points))}
  (:abort-action ...)       @emph{; (lambda (inter))}
  (:outside-action ...)     @emph{; (lambda (inter outside-control))}
  (:back-inside-action ...) @emph{; (lambda (inter outside-control new-inside-points))}
...)
@end example

The Two-Point-interactor is used to enter one or two new points, when there
is no existing object to change. For example, this interactor might be
used when creating a new rectangle or line. If the new object needs to be
defined by more than two points (for example for polygons), then you would
probably use the @code{multi-point-interactor} instead, except that
it is not implemented yet.

Since lines and rectangles are defined differently, there are two modes for
this interactor, determined by the @code{:line-p} slot. If @code{:line-p} is NIL, then
rectangle mode is used, so the new object is defined by its left, top, width,
and height. If @code{:line-p} is T, then the object is defined by two
points: x1, y1, and x2, y2. Both of these are stored as a list of four values.

As a convenience, this interactor will handle clipping of the values. A
minimum size can be supplied, and the object will not be smaller than this.

While the interactor is running, a feedback object, supplied in the
@code{:feedback-obj} slot is usually modified to show where the new object
will be. When the interaction is complete, however,
there is no existing object to modify, so this interactor cannot just
set an object field with the final value, like most other interactors.
Therefore, the @code{final-function} (section @ref{twopapplnotif}) will
usually need to be used for this interactor.

There are a number of examples of the use of two-point-interactors below,
and another in section @ref{twopselectexample}. Other
examples can be found in the file @code{demo-twop.lisp}.

@subsection Default Operation
@node Default Operation

This section describes how the two-point interactor works
if the programmer does not remove or override any of the standard
@code{-action} procedures. To supply custom action procedures, see section
@ref{twopcustomaction}.

Just as for move-grow-interactors (section @ref{movegrowinter}),
the feedback object (if any) is modified indirectly, by setting slots called
@code{:box} or @code{:points}. The programmer must provide constraints between
the @code{:left, :top, :width,} and @code{:height} slots or the @code{:x1, :y1,
:x2,} and @code{:y2} slots (as appropriate). The examples in section
@ref{movegrowinter} show how to define constraints for the feedback object.

The slot @code{:line-p} tells the interactor whether to change the @code{:box}
slot or the @code{:points} slot in the feedback object.
If @code{:line-p} is NIL (the default), then the interactor changes the
object by setting its
@code{:box} slot to a list containing the new values for (left, top, width,
height). If T, then the interactor changes the object by setting its
@code{:points} slot to a list containing the new values for (x1, y1, x2, y2).
(These are the same slots as used for @code{move-grow-interactor}).


@subsection Minimum sizes
@node Minimum sizes
@anchor{Minimumsizes}
The two-point interactor will automatically keep objects the same or bigger than a
specified size. There are two different mechanisms: one if @code{:line-p} is
NIL (so the object is defined by its @code{:box}), and another if
@code{:line-p} is T. 

In both modes, the slot @code{:abort-if-too-small} determines what happens if
the size is smaller than the defined minimum. The default is NIL, which
means to create the object with the minimum size. If
@code{:abort-if-too-small} is T, however, then the feedback object will
disappear if the size is too small, and if the mouse is released, the
final-function will be called with an error value (NIL) so the application will
know not to create the object.

If @code{:line-p} is NIL, the slots @code{:min-width} and @code{:min-height}
define the minimum size of the object. If both of these are not set, zero is used
as the minimum size (the two-point-interactor will not let the width or
height get to be less than zero). If the user moves the mouse to the left
or above of the original point, the parameter @code{:flip-if-change-side}
determines what happens. If @code{:flip-if-change-side} is T (the default),
then the box will still be drawn from the initial point to the current
mouse position, and the box will be flipped. The values put into the
@code{:box} slot will always be the correct left, top, width and height. 
If @code{:flip-if-change-side} is NIL, then the box will peg at its minimum
value.

If @code{:line-p} is T, the slot @code{:min-length} determines the minimum
length. This length is the actual distance along the line, and the line
will extend from its start point through the current mouse position for the
minimum length. If not
supplied, then the minimum will be zero. The @code{:min-width},
@code{:min-height} and @code{:flip-if-change-side} slots are ignored for lines.

@subsection Extra Parameters
@node Extra Parameters

The extra parameters are:

@table @code
@item @code{:line-p}
@cindex{line-p}
- If T, the @code{:points} slot of the feedback object is set with the list
@code{(x1 y1 x2 y2)}. If NIL, the @code{:box} slot of the feedback object is
set with the list @code{(left top width height)}. The values in the list passed to the
final-function is also determined by @code{:line-p}.
The default is NIL (rectangle mode).

@item @code{:min-width}
@cindex{min-width}
- The @code{:min-width} and @code{:min-height} fields determine the minimum
legal width and height of the rectangle or other object if @code{:line-p} is NIL.
Default is NIL, which means use 0. Both
@code{min-width} and @code{min-height}
must be non-NIL for this to take effect. @code{:min-width} and
@code{:min-height} are ignored if @code{:line-p} is non-@code{NIL} (see @code{:min-length}).

@item @code{:min-height}
@cindex{min-height}
- See @code{:min-width}.

@item @code{:min-length}
@cindex{min-length}
- If @code{:line-p} is non-@code{NIL}, then @code{:min-width} and
@code{:min-height} are ignored, and the @code{:min-length} slot is used
instead. This slot determines the minimum allowable length for a line (in
pixels). If NIL (the default), then there is no minimum length.

@item @code{:abort-if-too-small}
@cindex{abort-if-too-small}
- If this is NIL (the default), then if the size is smaller than the
minimum, then the size is made bigger to be the minimum (this works for
both @code{:line-p} T and NIL). If
@code{:abort-if-too-small} is T, then instead, no object is created and no
feedback is shown if the size is smaller than @code{:min-width} and
@code{:min-height} or @code{:min-length}.

@item @code{:flip-if-change-side}
@cindex{flip-if-change-side}
- This only applies if @code{:line-p} is NIL (rectangle mode).
If @code{:flip-if-change-side} is T (the default), then if the user moves to
the top or left of the original point, the rectangle will be ``flipped'' so
its top or left is the new point and the width and height is based on the
original point. If @code{:flip-if-change-side} is NIL, then the original
point is always the top-left, and if the mouse goes above or to the left of
that, then the minimum legal width or height is used.

@item @code{:input-filter}
@cindex{input-filter}
- Used to support gridding. See section @ref{gridding}.
@end table

@subsection Application Notification
@node Application Notification
@anchor{twopapplnotif}

Unlike with other interactors, it is usually necessary to have an
application function called with the result of the two-point-interactor.
The function is put into the @code{:final-function} slot of the interactor,
and is called with the following arguments:
@cindex{final-function}
@cindex{Two-Point-Interactor}
@example
(lambda (an-interactor final-point-list))
@end example
The @code{final-point-list} will either be a list of the
left top width, and height or the x and y of two points, depending on the
setting of the @code{:line-p} slot. If the @code{:abort-if-too-small} slot is
set (section @ref{Minimumsizes}), then the @code{final-point-list} will be NIL
if the user tries to create an object that is too small.

Therefore, the function
should check to see if @code{final-point-list} is NIL, and if so, not create
the object. If you want to access the points anyway, the original point is
available as the @code{:first-x} and @code{:first-y} slots of the interactor,
and the final point is available in the @code{*Current-Event*} as described
in section @ref{twopselectexample}.

@b{IMPORTANT NOTE: When creating an object using @code{final-point-list}, the elements
of the list should be accessed individually (e.g, @code{(first
final-point-list) (second
final-point-list) etc.}) or else the list should be
copied @code{(copy-list final-point-list)} before they are used in any object
slots, since to avoid consing, the interactor reuses the same list. Examples:}
@example
(defun Create-New-Object1 (an-interactor points-list)
  (when points-list
    (create-instance NIL opal:rectangle
       (:left (first points-list)) ;@i{access the values in}
       (:top (second points-list)) ; @i{the list individually}
       (:width (third points-list))
       (:height (fourth points-list)))))
@b{OR}
(defun Create-New-Object2 (an-interactor points-list)
  (when points-list
    (create-instance NIL opal:rectangle
       (:box (copy-list points-list)) ;@i{copy the list}
       (:left (first box))
       (:top (second box))
       (:width (third box))
       (:height (fourth box)))))
@end example


@subsection Normal Operation
@node Normal Operation
@cindex{box (slot)}
@cindex{points (slot)}
@cindex{visible (slot)}
If the value of @code{:continuous} is T,
then when the start event happens, 
if @code{:abort-if-too-small} is non-NIL, then nothing happens until the
mouse moves so that the size is big enough. Otherwise,
if @code{:line-p} is NIL, then the @code{:visible} slot of the
@code{:feedback-obj} is set to T, and its @code{:box} or @code{:points} slot is
set with the correct values for the minimum size rectangle or line. As the
mouse moves, the @code{:box} or @code{:points} slot is set with the current
size (or minimum size). If the size gets to be less than the minimum and 
@code{:abort-if-too-small} is non-NIL, then the @code{:visible} field of the
feedback object is set to NIL, and it is set to T again when the size gets
equal or bigger than the minimum.

If the mouse goes outside of @code{:running-where}, then if @code{:outside} is
@code{:last}, nothing happens until the mouse comes back inside or the stop
or abort events happen (the object stays at its last legal inside value).
If @code{:outside} is NIL, then the feedback
object's @code{:visible} slot is set to NIL.

If the abort event happens, then the feedback
object's @code{:visible} slot is set to NIL.

When the stop event happens, the feedback
object's @code{:visible} slot is set to NIL and the final-function is called.

If the value of @code{:continuous} is NIL, then the final-function is
called immediately on the start event with the @code{final-point-list}
parameter as NIL if @code{:abort-if-too-small} is non-NIL, or else a list
calculated based on the minimum size.


@subsection Examples
@node Examples

@subsection Creating New Objects
@node Creating New Objects
Create a rectangle when the middle button is pressed down, and a line when
the right button is pressed.
@cindex{Creating new objects}
@cindex{Examples}
@cindex{Creating new objects}
@cindex{Examples}
@cindex{Two-point-interactor}
@example
(defun Create-New-Object (an-interactor points-list)
  (when points-list
    (let (obj)
      (if (gv an-interactor :line-p)
	  ;;@i{then create a line}
	  (setq obj (create-instance NIL opal:line
                       (:x1 (first points-list))
                       (:y1 (second points-list))
                       (:x2 (third points-list))
                       (:y2 (fourth points-list))))
	  ;;@i{else create a rectangle}
	  (setq obj (create-instance NIL opal:rectangle
                       (:left (first points-list))
                       (:top (second points-list))
                       (:width (third points-list))
                       (:height (fourth points-list)))))
      (opal:add-components MYAGG obj)
      obj)))

(create-instance 'CREATERECT Inter:Two-Point-Interactor
   (:window MYWINDOW)
   (:start-event :middledown)
   (:start-where T)
   (:final-function #'Create-New-Object)
   (:feedback-obj MOVING-RECTANGLE) ;@i{section @ref{howobjsdefined}} 
   (:min-width 20)
   (:min-height 20))
(create-instance 'CREATELINE Inter:Two-Point-Interactor
   (:window MYWINDOW)
   (:start-event :rightdown)
   (:start-where T)
   (:final-function #'Create-New-Object)
   (:feedback-obj MOVING-LINE) ;@i{section @ref{howobjsdefined}} 
   (:line-p T)
   (:min-length 20))
@end example


@section Angle-Interactor
@node Angle-Interactor
@cindex{Angle-Interactor}

@example
(create-instance 'inter:Angle-Interactor inter:interactor
  @emph{;; Slots common to all interactors (see section @ref{interslots})}
  (:start-where NIL)
  (:window NIL)
  (:start-event :leftdown)
  (:continuous T)
  (:stop-event NIL)
  (:running-where NIL)
  (:outside NIL)
  (:abort-event :control-\g)
  (:waiting-priority normal-priority-level)
  (:running-priority running-priority-level)
  (:active T)
  (:self-deactivate NIL)

  @emph{; Slots specific to the move-grow-interactor (discussed in this section)}
  (:final-function NIL)      @emph{; (lambda (inter obj-being-rotated final-angle))}
  (:obj-to-change NIL)       @i[; The object to change the :angle slot of (if NIL, then the interactor will change]
                             @emph{; the object returned from the start-where)}
  (:feedback-obj NIL)        @emph{; Optional interim feedback object. The inter will set this object's :obj-over slot}
                             @emph{; and its :angle slot during interim selection}
  (:center-of-rotation NIL)  @emph{; A list (x y) indicating a coordinate around which the objects will be rotated.}
                             @emph{; If NIL, the center of the object is used}

  @emph{; @b{Advanced feature:}  Read-only slots.}
  @emph{; See section @ref{specialslots} for details about these slots.}
  (:first-obj-over NIL)     @emph{; Read-only slot. The object returned from the start-where.}
  (:current-window NIL)     @emph{; Read-only slot. The window of the last (or current) event.}
  (:start-char NIL)         @emph{; Read-only slot. The character or keyword of the start event.}

  @emph{; @b{Advanced feature:} Customizable action routines.}
  @emph{; See sections @ref{interslots} and @ref{anglecustomaction} for details about functions in these slots.}
  (:start-action ...)       @emph{; (lambda (inter obj-being-rotated first-angle))}
  (:running-action ...)     @emph{; (lambda (inter obj-being-rotated new-angle angle-delta))}
  (:stop-action ...)        @emph{; (lambda (inter obj-being-rotated final-angle angle-delta))}
  (:abort-action ...)       @emph{; (lambda (inter obj-being-rotated))}
  (:outside-action ...)     @emph{; (lambda (inter outside-control obj-being-rotated))}
  (:back-inside-action ...) @emph{; (lambda (inter outside-control obj-being-rotated new-angle))}
...)
@end example

This is used to measure the angle the mouse moves around a point. It can
be used for circular gauges, for rotating objects, or for ``stirring
motions'' for objects. @c @cite{StirringMotions} 

It operates very much like the @code{move-grow-interactor} and has
interim and final feedback that work much the same way.

The interactor can either be permanently tied to a particular graphics
object, or it will get the object from where the mouse is when the
interaction starts. There may be a feedback object to show where the
object will be moved or changed to, or the object itself may change with
the mouse.

There is an example of the use of the angle-interactor below. Other
examples can be found in
the @code{Gauge} gadget in
the Garnet Gadget Set, and in the files @code{demo-angle.lisp} and
@code{demo-clock.lisp}.

@subsection Default Operation
@node Default Operation

This section describes how the angle interactor works
if the programmer does not remove or override any of the standard
@code{-action} procedures. To supply custom action procedures, see section
@ref{anglecustomaction}.

@cindex{angle (slot)}
The feedback object (if any) @emph{and}
the object being edited are modified indirectly, by setting a slot called
@code{:angle}. The programmer must provide constraints to this slot.
If there is a feedback object, the interactor also sets its
@code{:obj-over} field to the actual object that is being moved.
This can be used, for example,
to control the visibility of the feedback object or its size.

The angle slot is set with a value in radians measured counter-clockwise
from the far right. Therefore, straight up is @code{(/ PI 2.0)}, straight left
is @code{PI}, and straight down is @code{(* PI 1.5)}.

The object being changed is
either gotten from the @code{:obj-to-change} slot of the interactor, or if
that is NIL, then from the object returned from @code{:start-where}.

The interactor needs to be told where the center of rotation should be.
The slot @code{:center-of-rotation} can contain a point as a list of
@code{(x y)}. If  @code{:center-of-rotation} is NIL (the default), then the
center of the object being rotated is used.

For example, a line that can be rotated around an endpoint might have 
the following definition:
@cindex{Rotating Line}
@cindex{Examples}
@cindex{Rotating Line}
@example
(create-instance 'ROTATING-LINE opal:line
   (:angle (/ PI 4))  ;@i{initial value = 45 degrees up}
   (:line-length 50)
   (:x1 70)
   (:y1 170)
   (:x2 (o-formula (+ (gvl :x1)
                      (round (* (gvl :line-length)
				(cos (gvl :angle)))))))
   (:y2 (o-formula (- (gvl :y1)
		      (round (* (gvl :line-length)
				(sin (gvl :angle))))))))

(create-instance 'MYROTATOR Inter:Angle-Interactor
   (:start-where T)
   (:obj-to-change ROTATING-LINE)
   (:center-of-rotation (o-formula (list (gvl :obj-to-change :x1)
					 (gvl :obj-to-change :y1))))
   (:window MYWINDOW))
@end example



@subsection Extra Parameters
@node Extra Parameters

The extra parameters are:

@table @code
@item @code{:obj-to-change}
@cindex{obj-to-change}
- If an object is supplied here, then the interactor modifies the
@code{:angle} slot of that object. If @code{:obj-to-change} is NIL, then the
interactor operates on whatever is returned from @code{:start-where}.
The default value is NIL.

@item @code{:center-of-rotation}
@cindex{center-of-rotation}
- This is the center of rotation for the interaction. It should be a list
of @code{(x y)}. If NIL, then the center of the real object being rotated
(note: @emph{not} the feedback object) is used. The default value is NIL.
@end table

@subsection Application Notification
@node Application Notification

@cindex{angle (slot)}
Often, it is not necessary to have the application notified of the result
of a angle-interactor, if you only want the object to rotate around.
Otherwise, you can have constraints in the application to the @code{:angle} slot.

Alternatively, the programmer can provide a function to be called when the
interactor is complete by putting the function in the @code{:final-function}
slot. This function is called with the following arguments:
@cindex{final-function}
@cindex{Angle-Interactor}
@example
(lambda (an-interactor object-being-rotated final-angle))
@end example

@subsection Normal Operation
@node Normal Operation

@cindex{Obj-Over (slot)}
@cindex{angle (slot)}
If the value of @code{:continuous} is T,
then when the start event happens, the interactor determines the object to
be changed as
either the value of the @code{:obj-to-change} slot, or if that is NIL, then
the object returned from the @code{:start-where}.
The @code{:obj-over} slot of the object in
the @code{:feedback-obj} slot of the interactor is set to the object being changed.
Then, for every mouse movement until the stop event happens, the interactor sets
the @code{:angle} slot. The object that is modified while
running is either the feedback object if it exists or the object being changed
if there is no feedback object.

If the mouse goes outside of @code{:running-where}, then if @code{:outside} is
@code{:last}, nothing happens until the mouse comes back inside or the stop
or abort events happen (the object stays at its last legal inside value).
If @code{:outside} is NIL, then the feedback
object's @code{:obj-over} slot is set to NIL.
If there is no feedback object and the mouse goes outside, then the object
being changed is returned to its original angle (before the
interactor started).

If the abort event happens, then the feedback
object's @code{:obj-over} slot is set to NIL, or if there is no feedback
object, then the object being rotated is returned to its original angle
(before the interactor started).

When the stop event happens, the feedback object's @code{:obj-over} slot is
set to NIL, and the @code{:angle} slot of the actual object is
set with the last value, and the final-function
(if any) is called.

If the interactor is @emph{not} continuous, when the start event happens, the
@code{:angle} slot of the actual object is
set with the initial value, and the final-function
(if any) is called.

@section Text-interactor
@node Text-interactor
@cindex{Text-interactor}

@example
(create-instance 'inter:Text-Interactor inter:interactor
  @emph{;; Slots common to all interactors (see section @ref{interslots})}
  (:start-where NIL)
  (:window NIL)
  (:start-event :leftdown)
  (:continuous T)
  (:stop-event NIL)
  (:running-where T)
  (:outside NIL)
  (:abort-event '(:control-\g :control-g))
  (:waiting-priority normal-priority-level)
  (:running-priority running-priority-level)
  (:active T)
  (:self-deactivate NIL)

  @emph{; Slots specific to the text-interactor (discussed in this section)}
  (:final-function NIL)      @emph{; (lambda (inter obj-being-edited final-event final-string x y))}
  (:obj-to-change NIL)       @i[; The object to change the :string slot of (if NIL, then the interactor will change]
                             @emph{; the object returned from the start-where)}

  (:feedback-obj NIL)        @emph{; Optional interim feedback object. The inter will set this object's :string, :cursor-index,}
                             @emph{; :obj-over, and :box slots}
  (:cursor-where-press T)    @emph{; Whether to position the cursor under the mouse or at the end of the string}
  (:input-filter NIL)        @emph{; Used for gridding (see section @ref{gridding})}
  (:button-outside-stop? T)  @emph{; Whether a click outside the string should stop editing (see section @ref{extra-text-parameters})}

  @emph{; @b{Advanced feature:}  Read-only slots.}
  @emph{; See section @ref{specialslots} for details about these slots.}
  (:first-obj-over NIL)     @emph{; Read-only slot. The object returned from the start-where.}
  (:current-window NIL)     @emph{; Read-only slot. The window of the last (or current) event.}
  (:start-char NIL)         @emph{; Read-only slot. The character or keyword of the start event.}

  @emph{; @b{Advanced feature:} Customizable action routines.}
  @emph{; See sections @ref{interslots} and @ref{textcustomaction} for details about functions in these slots.}
  (:start-action ...)       @emph{; (lambda (inter new-obj-over start-event))}
  (:running-action ...)     @emph{; (lambda (inter obj-over event))}
  (:stop-action ...)        @emph{; (lambda (inter obj-over stop-event))}
  (:abort-action ...)       @emph{; (lambda (inter obj-over abort-event))}
  (:outside-action ...)     @emph{; (lambda (inter obj-over))}
  (:back-inside-action ...) @emph{; (lambda (inter obj-over event))}
...)
@end example


If you want to use multi-font, multi-line text objects, you will probably
want to use the special interactors defined for them, which are described
in the Opal manual.

The @code{text-interactor} will input a one-line or multi-line string of text,
while allowing editing on the string. A fairly complete set of editing
operations is supported, and the programmer or user can add new ones or
change the bindings of the default operations.
The intention is that this be used for string entry in text forms, for file
names, object names, numbers, labels for pictures, etc. The strings can be
in any font, but the entire string must be in the same font. More complex editing
capabilities are clearly possible, but not implemented here.

@cindex{Text}
Text-interactors work on @code{opal:text} objects. 
The interactor can either be permanently tied to a particular text
object, or it will get the object from where the mouse is when the
interaction starts. There may be a feedback object to show the edits, with
the final object changed only when the editing is complete, or else the
object itself can be edited. (Feedback objects are actually not very
useful for text-interactors.)
Both the feedback and the main object should be an @code{opal:text} object.

There is an example of the use of the text-interactor below. Other
examples can be found in
the top type-in area in the @code{v-slider} gadget in
the Garnet Gadget Set, and in the file @code{demo-text.lisp}.

@subsection Default Editing Commands
@node Default Editing Commands
@anchor{defaulteditingcommands}
@cindex{Text Editing Commands}
@cindex{Editing Commands}
There is a default set of editing commands provided with text interactors.
These are based on the EMACS command set. The programmer change this and
can create his own mappings and functions (see section @ref{keytranslations}).
In the following, keys like "@code{insert}" and "@code{home}" are the
specially labeled keys on the IBM/RT or Sun keyboard. If your keyboard has
some keys you would like to work as editing commands, see section @ref{eventspec}.

@table @code

@item @code{^h, delete, backspace}
delete previous character.

@item @code{^w, ^backspace, ^delete}
delete previous word.

@item @code{^d}
delete next character.

@item @code{^u}
delete entire string.

@item @code{^k}
delete to end of line.

@item @code{^b, left-arrow}
go back one character.

@item @code{^f, right-arrow}
go forward one character.

@item @code{^n, down-arrow}
go vertically down one line (for multi-line strings).

@item @code{^p, up-arrow}
go vertically up one line (for multi-line strings).

@item @code{^<, ^comma, home}
go to the beginning of the string.

@item @code{^>, ^period, end}
go to the end of the string.

@item @code{^a}
go to beginning of the current line (different from @code{^<} for
multi-line strings).

@item @code{^e}
go to end of the current line (different from @code{^>} for
multi-line strings).

@item @code{^y, insert}
insert the contents of the cut buffer into the string at the
current point.

@item @code{^c}
copy the current string to the cut buffer.

@item @code{enter, return, ^j, ^J}
Add a new line.

@item @code{^o}
Insert a new line after the cursor.

@item @code{any mouse button down inside the string}
move the cursor to the
specified point. This only works if the @code{:cursor-where-press} slot of
the interactor is non-NIL.

@end table

In addition, the numeric keypad is mapped to normal numbers and symbols.

Note: if you manage to get an illegal character into the string, the string
will only be displayed up to the first illegal character. The rest will be
invisible (but still in the @code{:string} slot).

The interactor's @code{:stop-event} and @code{:abort-event} override the above
operations. For example, if the @code{:stop-event} is @code{:any-mousedown},
then when you press in the string, editing will stop rather than causing
the cursor to move. Similarly, if @code{#\RETURN} is the
@code{:stop-event}, then it 
cannot be inserted into the string for a multi-line string, and if
@code{:control-\c} is the @code{:abort-event}, it cannot be used to copy to the
X cut buffer. Therefore, you need to pick the @code{:stop-event} and
@code{:abort-event} appropriately, or change the bindings (see section
@ref{keytranslations})

@subsection Default Operation
@node Default Operation

This section describes how the text interactor works
if the programmer does not remove or override any of the standard
@code{-action} procedures. To supply custom action procedures, see section
@ref{textcustomaction}.

@cindex{string (slot)}
@cindex{cursor-index (slot)}
Unlike other interactors, the feedback object (if any) and
the object being edited are modified directly, by setting the @code{:string}
and @code{:cursor-index} fields (that control the value displayed and the
position of the cursor in the string). If there is a feedback object, the
interactor also sets the first two values of its @code{:box} field to be the
position where the start event happened. This might be used to put the
feedback object at the mouse position when the user presses to start a new string.

In general, feedback objects are mainly useful when you want to create new
strings as a result of the event.

The object being changed is
either gotten from the @code{:obj-to-change} slot of the interactor, or if
that is NIL, then from the object returned from @code{:start-where}.

@subsection Multi-line text strings
@node Multi-line text strings
The default stop event for text interactors is @code{#\RETURN}, which is fine
for one-line strings, but does not work for multi-line strings. For those,
you probably want to specify a stop event as something like
@code{:any-mousedown} so 
that @code{#\RETURN}s can be typed into the string (actually, the character
in the string that makes it go to the next line is #\NEWLINE; the
interactor maps the return key to #\NEWLINE). Also @code{:any-mousedown}
would be a bad choice for the stop event if you wanted to allow the mouse
to be used for changing the text insert cursor position.

Note that the stop event is @emph{not} edited into the string.

The @code{:outside} slot is ignored.

The default @code{:running-where}
is T for text-interactors.

@subsection Extra Parameters
@node Extra Parameters
@anchor{extra-text-parameters}

The extra parameters are:

@table @code 
@item @code{:obj-to-change}
@cindex{obj-to-change}
If an object is supplied here, then the interactor modifies the

@item @code{:string} and @code{:cursor-index}
slots of that object. If
@code{:obj-to-change} is NIL, then the
interactor operates on whatever is returned from @code{:start-where}. The
default value is NIL.

@item @code{:cursor-where-press}
@cindex{cursor-where-press}
If this slot is non-NIL, then the initial position of the
text editing cursor is underneath the mouse cursor (i.e, the user begins
editing the string on the character under where the mouse was pressed).
This is the default. If @code{:cursor-where-press} is specified as NIL,
however, the cursor always starts at the end of the string.
This slot also controls whether the mouse is allowed to move the cursor
while the string is being edited. If @code{:cursor-where-press} is NIL, then
mouse presses are ignored while editing (unless they are the @code{:stop-} or
@code{:abort-} events), otherwise, presses can be used to move the cursor.

@item @code{:input-filter}
Used to support gridding. See section @ref{gridding}.

@item @code{:button-outside-stop?}
@cindex{button-outside-stop?}
@cindex{outside stop}
Whether a mouse click @emph{outside} the string should stop editing,
but still do the action it would have
done if text wasn't being edited. This means, for example, that you
typically won't have to type RETURN before hitting the OK
button, since the down press will stop editing @b{and} still operate the
OK button. By default this feature is enabled, but you can turn
it off by setting the @code{:button-outside-stop?} parameter to NIL.


@end table


@subsection Application Notification
@node Application Notification

Often, it is not necessary to have the application notified of the result
of a text-interactor, if you only want the string object to be changed, it
will happen automatically.

Alternatively, the programmer can provide a function to be called when the
interactor is complete by putting the function in the @code{:final-function}
slot. This function is called with the following arguments:
@cindex{final-function}
@cindex{Text-Interactor}
@example
(lambda (an-interactor obj-being-edited final-event final-string x y))
@end example
The definition of the type for @code{final-event} is in section @ref{Events}.
(It is a Lisp structure containing the particular key hit.)
The @code{final-string} is the final value for the entire string. @i{It is
important that you copy the string (with @code{copy-seq}) before using it,
since it will be shared with the feedback object.}
The @code{x} and @code{y} parameters are the @emph{initial} positions put into the
feedback object's @code{:box} slot (which might be used as the position of the
new object). The values of @code{x} and @code{y} are @emph{filtered} values computed
via the @code{:input-filter} given to the interactor (see section
@ref{gridding}).


@subsection Normal Operation
@node Normal Operation
@cindex{box (slot)}
@cindex{cursor-index (slot)}
@cindex{visible (slot)}
If the value of @code{:continuous} is T,
then when the start event happens, if there is a feedback object, then its
@code{:box} slot is set to the position of the start-event, and its
@code{:obj-over} slot is set to @code{:obj-to-change} or the result of the
@code{:start-where}. Its @code{:cursor-index} is set to the
position of the start-event (if @code{:cursor-where-press} is T) or to the
end of the string (so the cursor becomes visible). If there is no
@code{:feedback-obj}, then the @code{:obj-to-change} or if that is NIL, then
the object returned from @code{:start-where} has its cursor turned on at the
appropriate place. If the start event was a keyboard character, it is then
edited into the string. Therefore, you can have a text interactor start on
@code{:any-keyboard} and have the first character typed entered into the string.

Then, for every subsequent keyboard down-press, the key is either entered
into the string, or if it is an editing command, then it is performed.

If the mouse goes outside of @code{:running-where}, then the cursor is turned
off, and it is turned back on when the mouse goes back inside. Events
other than the stop event and the abort event are ignored until the mouse
goes back inside. Note: this
is usually not used because @code{:running-where} is usually T for
text-interactors. If
it is desirable to only edit while the mouse is
over the object, then @code{:running-where} can be specified as @code{'(:in *)}
which means that the interactor will work only when the mouse is over the
object it started over.

@cindex{string (slot)}
@cindex{visible (slot)}
@cindex{cursor-index (slot)}
If the abort event happens, then the feedback object's @code{:string} is set with
its initial value, its @code{:cursor-index} is set to NIL, and its
@code{:obj-over} is set to NIL. If there is no feedback object, then the main
object's @code{:string} is set to its original value and its
@code{:cursor-index} is set to NIL.

When the stop event happens, if there is a feedback object, then its
@code{:visible} slot is set with NIL, the main object is set with
feedback object's @code{:string}, and the @code{:cursor-index} is set to NIL.
If there is no feedback object, then the @code{:cursor-index} of the main
object is set to NIL. Note that the stop event is @emph{not} edited into the
string. Finally, the final-function (if any) is called.

If the interactor is @emph{not} continuous, when the start event happens, the
actions described above for the stop event are done.


@subsection Useful Functions
@node Useful Functions

@cindex{Insert-Text-Into-String}
@example
inter:Insert-Text-Into-String @emph{text-obj} @emph{new-string} &optional @emph{(move-back-cursor 0)}@ref{function}
@end example
The function @code{Insert-Text-Into-String} inserts a string @emph{new-string} into
an @code{opal:text} object @emph{text-obj} at the current cursor point. This can
be used even while the text-interactor is
running. For example, an on-screen button might insert some text into a
string. After the text is inserted, the cursor is moved to the end of the
new text, minus the optional offset @emph{move-back-cursor} (which should be
a non-negative integer). For example, to insert the string @code{"(+ foo
5)"} and leave the cursor between the @code{"5"} and the @code{"}"], you could call:
@example
(Insert-Text-Into-String MYTEXT "(+ foo 5)" 1)
@end example


@subsection Examples
@node Examples

@subsection Editing a particular string
@node Editing a particular string
@cindex{String}
@cindex{Editable String}
@cindex{Examples}
@cindex{Aggregadget}
@cindex{Examples}
@cindex{Editable String}
This creates an aggregadget containing a single-line text object and an
interactor to edit it when the right mouse button is pressed.
@example
(create-instance 'EDITABLE-STRING opal:aggregadget
   (:left 10)
   (:top 200)
   (:parts
    `((:txt ,opal:text
	    (:left ,(o-formula (gvl :parent :left)))
	    (:top ,(o-formula (gvl :parent :top)))
	    (:string "Hello World")))) ;@i{default initial value}
   (:interactors
    `((:editor ,Inter:Text-Interactor
	       (:start-where ,(o-formula (list :in (gvl :operates-on :txt))))
	       (:window ,(o-formula (gvl :operates-on :window)))
	       (:stop-event (:any-mousedown #\RETURN)) ;@i{either}
	       (:start-event :rightdown)))))
@end example

@subsection Editing an existing or new string
@node Editing an existing or new string
@anchor{editstringexample}
Here, the right button will create a new multi-line string object when the
user presses on
the background, and it will edit an existing object if the user presses on
top of it, as in Macintosh MacDraw.

Note: This uses a formula in the @code{:feedback-obj} slot that depends on
the @code{:first-obj-over} slot of the interactor. This slot, which holds the
object the interactor starts over, is explained in section @ref{specialslots}.
@cindex{Examples}
@cindex{Feedback}
@cindex{Examples}
@cindex{Text}
@cindex{Examples}
@cindex{Create or edit string}
@example
(create-instance 'THE-FEEDBACK-OBJ opal:text
   (:string "")
   (:visible NIL)
   (:left (formula '(first (gvl :box))))
   (:top (formula '(second (gvl :box)))))

;;;@i{Assume there is a top level aggregate in the window called} top-agg.
;;;@i{Create an aggregate to hold all the strings. This aggregate must have a fixed}
;;;@i{   size so user can press inside even when it does not contain any objects.}
(create-instance 'OBJECT-AGG opal:aggregate
   (:left 0)(:top 0)
   (:width (o-formula (gvl :window :width)))
   (:height (o-formula (gvl :window :height))))

(opal:add-components TOP-AGG THE-FEEDBACK-OBJ OBJECT-AGG)
(opal:update MYWINDOW)

(create-instance 'CREATE-OR-EDIT Inter:Text-Interactor
    (:feedback-obj (o-formula
		    (if (eq :none (gvl :first-obj-over))
			;@i{then create a new object, so use feedback-obj}
			THE-FEEDBACK-OBJ
			;@i{else use object returned by mouse}
			NIL)))
    (:start-where `(:element-of-or-none ,OBJECT-AGG))
    (:window MYWINDOW)
    (:start-event :any-rightdown)
    (:stop-event '(:any-mousedown :control-\j)) ;@i{either one stops}
    (:final-function
     #'(lambda (an-interactor obj-being-edited stop-event final-string x y)
	 (declare (ignore an-interactor stop-event))
	 (when (eq :none obj-being-edited)
	   ;;@i{then create a new string and add to aggregate.}
	   ;;@i{Note that it is important to copy the string.}
	   (let ((new-str (create-instance NIL opal:text
			     (:string (copy-seq final-string))
			     (:left x)(:top y))))
	     (opal:add-component OBJECT-AGG new-str)
	     (s-value THE-FEEDBACK-OBJ :string "") ;@i{so starts empty next time}
	     )))))
@end example

@subsection Key Translation Tables
@node Key Translation Tables
@cindex{Key Translation Tables}
@cindex{Key Bindings}
@anchor{keytranslations}

The programmer can change the bindings of keyboard keys to editing
operations, and even add new editing operations in a straightforward
manner.

Each text interactor can have its own @emph{key translation table}. The default
table is stored in the top-level @code{Text-Interactor} object, and so
text-interactor instances will inherit it automatically. If you want to
change the bindings, you need to use @code{Bind-key}, @code{Unbind-key},
@code{Unbind-All-Keys}, or @code{Set-Default-Key-Translations} (these functions
are defined below).

If you want to change the binding for all of your text interactors, you can
edit the bindings of the top-level @code{Text-Interactor} object. If you
want a binding to be different for a particular interactor instance, just
modify the table for that instance. What happens in this case is that the
inherited table is copied first, and then modified. That way, other
interactors that also inherit from the default table will not be affected.
This copy is performed automatically by the first call to one of these
functions.

Bindings can be changed while the interactor is running, and they will take
effect immediately.

@cindex{Bind-Key}
@example
inter:Bind-Key @emph{key} @emph{val} @emph{an-interactor}@ref{function}
@end example
@code{Bind-Key} sets the binding for @emph{key} to be @emph{val} for
@emph{an-interactor}. The @emph{key} can either be a Lisp character (like
@code{:control-\t}) or a special keyword
that is returned when a key is hit (like @code{:uparrow}). If the key used
to have some other binding, the old binding is removed. It is fine to bind
multiple keys to the same value, however (e.g., both @code{^p} and
@code{:uparrow} are bound to @code{:upline}).

The second parameter (@emph{val}) can be any one of the following four
forms:
@enumerate
A character to map into. This allows special keys to map to regular keys.
So, for example, you can have @code{:super-4} map to @code{#\4}.

A string. This allows the key to act like an abbreviation and expand into a
string. For example, @code{(inter:bind-key :F2 "long string" MYINTER)} will
insert "long string" whenever F2 is hit.
Unfortunately, the string must be constant and cannot, for example, be
computed by a formula.

One of the built-in editing operations which are keywords. These are
implemented internally to the text interactor, but the user can decide which
key(s) causes them to happen. The keywords that are available are:
@itemize
@code{:prev-char} - move cursor to previous character.

@code{:next-char} - move cursor to next character.

@code{:up-line} - move cursor up one line.

@code{:down-line} - move cursor down one line.

@code{:delete-prev-char} - delete character to left of cursor.
		
@code{:delete-prev-word} - delete word to left of cursor.
		
@code{:delete-next-char} - delete character to right of cursor.

@code{:kill-line} - delete to end of line.

@code{:insert-lf-after} - add new line after cursor.
		
@code{:delete-string} - delete entire string.

@code{:beginning-of-string} - move cursor to beginning of string.

@code{:beginning-of-line} - move cursor to beginning of line.
		
@code{:end-of-string} - move cursor to end of string.

@code{:end-of-line} - move cursor to end of line.

@code{:copy-to-X-cut-buffer} - copy entire string to cut buffer.

@code{:copy-from-X-cut-buffer} - insert cut buffer at current cursor.
@end itemize
For example, @code{(inter:bind-key :F4 :upline MYINTER)} will make the F4 key
move the cursor up one line.

A function that performs an edit. The function should be of the following
form: 
@example
(lambda (an-interactor text-obj event))
@end example
The interactor will be the text-interactor, the text object is the one
being edited, and the event is an Interactor event structure (see section
@ref{events}). Note: @emph{not} a lisp character; the character is a field in
the event. This function can do arbitrary manipulations of the @code{:string} slot
and the @code{:cursor-index} slot of the @code{text-obj}. For example,
the following code could be used to implement the ``swap previous two
character'' operation from EMACS:
@cindex{Examples}
@cindex{Binding Keys}
@example
;;@i{first define the function}
(defun flip (inter str event) ;@i{swap the two characters to the left of the cursor}
  (let ((index (gv str :cursor-index)) ;@i{get the old values}
	(s (gv str :string)))
    (when (> index 1)  ;@i{make sure there are 2 chars to the left of the cursor}
      (let ((oldsecondchar (elt s (1- index)))) ;@i{do the swap in place in the str}
	(setf (elt s (1- index)) (elt s (- index 2)))
	(setf (elt s (- index 2)) oldsecondchar)
	(mark-as-changed str :string ))))) ;@i{since we modified the string value} 
				; @i{of the object in place, we have to let KR know}
				; @i{it has been modified.}
;;@i{now bind it to ^t for a particular text-interactor called} my-text-inter.
(inter:bind-key :control-\t #'flip MY-TEXT-INTER) ; lower case t
@end example
@end enumerate




@cindex{Unbind-Key}
The function @code{Unbind-Key} removes the binding of @emph{key} for
@emph{an-interactor}. All keys that
are not bound to something either insert themselves into the string (if
they are printable characters), or else cause the interactor to beep when typed.

@cindex{Unbind-All-Keys}
@example
inter:Unbind-Key @emph{key} @emph{an-interactor}@ref{function}

inter:Unbind-All-Keys @emph{an-interactor}@ref{function}
@end example
@code{Unbind-All-Keys} unbinds all keys for @emph{an-interactor}. This
would usually be followed by binding some of the keys in a different way.

@cindex{Set-Default-Key-Translations}
@example
inter:Set-Default-Key-Translations @emph{an-interactor}@ref{function}
@end example
This sets up @emph{an-interactor} with the default key bindings presented in
section @ref{defaulteditingcommands}. This might be useful to restore an
interactor after the other functions above were used to change the bindings.

@subsection Editing Function
@node Editing Function
@cindex{Edit-Func}

If you need even more flexibility than changing the key translations
offers, then you can override the entire editing function, which is
implemented as a method. Simply set the @code{:edit-func} slot of the text
interactor with a function as follows:
@example
lambda (an-interactor string-object event)
@end example
It is expected to perform the modifications of the string-object based on
the @code{event}, which is a Garnet event structure (section @ref{events}).


@section Gesture-Interactor
@node Gesture-Interactor
@cindex{gesture-interactor}
@anchor{gesture}

@example
(create-instance 'inter:Gesture-Interactor inter:interactor
  @emph{;; Slots common to all interactors (see section @ref{interslots})}
  (:start-where NIL)
  (:window NIL)
  (:start-event :leftdown)
  (:continuous T)                @emph{; Must be T for gesture-interactor}
  (:stop-event NIL)
  (:running-where T)
  (:outside NIL)
  (:abort-event '(:control-\g :control-g))
  (:waiting-priority normal-priority-level)
  (:running-priority running-priority-level)
  (:active T)
  (:self-deactivate NIL)

  @emph{; Slots specific to the gesture-interactor (discussed in this section)}
  (:final-function NIL)          @emph{; (lambda (inter first-obj-over gesture-name attribs points-array nap dist))}
  (:classifier NIL)              @emph{; classifier to use}
  (:show-trace T)                @emph{; show trace of gesture?}
  (:min-non-ambig-prob nil)      @emph{; non-ambiguity probability}
  (:max-dist-to-mean nil)        @emph{; distance to class mean}
  (:went-outside NIL)            @emph{; Read-only slot. Set in outside action function}

  @emph{; @b{Advanced feature:}  Read-only slots.}
  @emph{; See section @ref{specialslots} for details about these slots.}
  (:first-obj-over NIL)     @emph{; Read-only slot. The object returned from the start-where.}
  (:current-window NIL)     @emph{; Read-only slot. The window of the last (or current) event.}
  (:start-char NIL)         @emph{; Read-only slot. The character or keyword of the start event.}

  @emph{; @b{Advanced feature:} Customizable action routines.}
  @emph{; See sections @ref{interslots} and @ref{gestcustomaction} for details about functions in these slots.}
  (:start-action ...)       @emph{; (lambda (inter obj-under-mouse point))}
  (:running-action ...)     @emph{; (lambda (inter new-obj-over point))}
  (:stop-action ...)        @emph{; (lambda (inter final-obj-over point))}
  (:abort-action ...)       @emph{; (lambda (inter))}
  (:outside-action ...)     @emph{; (lambda (inter prev-obj-over))}
  (:back-inside-action ...) @emph{; (lambda (inter new-obj-over))}
...)
@end example


The Gesture-interactor is used to recognize single-path gestures that are
drawn with the mouse. For example, this interactor might be used to allow
the user to create circles and rectangles by drawing an ellipse for a
circle and an ``L'' shape for a rectangle with the mouse. A
@emph{classifier} will be created for these two gestures. A
``classifier'' is a data structure that holds the information the
gesture interactor needs to differentiate the gestures. Classifiers
are created by using a special training program to give several
examples of each kind of gesture that will be recognized. For
instance, you might use Agate (section @ref{agate}), the Garnet
gesture trainer, to give 15 examples of the ellipses and 15 of the ``L''
shape.
Each gesture is named with a keyword (here, @code{:circle} and @code{:rectangle}
might be used).
Then, the classifier will be written to a file. The gesture
interactor will then read this file and know how to recognize the
specified gestures.

The classification algorithm is based on Rubine's gesture
recognition algorithm @cite{rubine, rubinesiggraph}. It uses a
statistical technique.

There is one example of the gesture-interactor below. Other
examples can be found in the files @code{demo-arith.lisp} and
@code{demo-gesture.lisp}.

Unlike other interactors, Gestures are not automatically loaded when
you load Garnet. To load gestures, use:
@example
(load Garnet-Gesture-Loader)
@end example


@subsection Default Operation
@node Default Operation

This section describes how the gesture-interactor works
if the programmer does not remove or override any of the standard
@code{-action} procedures. To supply custom action procedures, see section
@ref{gestcustomaction}.

The interactor is used by specifying a classifier to use and a
@code{final-function} (@ref{gestapplnotif}) to call with the result of the
classification.

The @code{:classifier} slot should be set to the value of a gesture
classifier. Classifiers trained and saved by Agate can be read with
@code{inter:gest-classifier-read}. The @code{:final-function}
slot should be set to a function to call with the result of the gesture
classification.

Since the programmer may or not want the trace of the gesture to be
shown, there are two drawing modes for the interactor, determined by the
@code{:show-trace} slot. If @code{:show-trace} is non-NIL (the default), then the
points making up the gesture will be displayed as the gesture is drawn
and erased when it is finished.

@subsection Rejecting Gestures
@node Rejecting Gestures
@anchor{rejecting-gestures}
If the gesture-interactor is unable to classify the gesture, it will
call the @code{final-function} with a value of NIL for the classified
gesture name. Often,
the gesture will be ambiguous, in that it is similar to more than one
known gesture. By setting the @code{:min-non-ambig-prob} slot, the
programmer can specify the minimum non-ambiguous probability below which
gestures will be rejected. Empirically, a value of .95 has been found to
be a reasonable value for a number of gesture sets @cite{rubine}.

Also, the gesture may be an outlier, different from any of the expected
gestures. An approximation of the Mahalanobis distance from the features
of the given gesture to the features of the gesture it was classified as
gives a good indication of this. By setting the @code{:max-dist-to-mean}
slot, the programmer can specify the maximum distance above which
gestures will be rejected. Rubine shows that a value of 60 (for our
feature set) is a good compromise between accepting obvious outliers and
rejecting reasonable gestures.

NIL for either parameter means that that kind of checking is not performed.

@subsection Extra Parameters
@node Extra Parameters

The extra parameters are:

@table @code
@item @code{:classifier}
@cindex{classifier}
 - This field determines which classifier to use when recognizing
gestures. If NIL (the default), the gesture-interactor will call the
@code{final-function} with a result of NIL.

@item @code{:show-trace}
@cindex{show-trace}
 - If non-NIL (the default), the points making up the gesture are displayed in
the supplied interactor window as the gesture is drawn. If NIL, no points
are displayed.

@item @code{:min-non-ambig-prob}
@cindex{min-non-ambig-prob}
 - This field determines the minimum non-ambiguous probability below which
gestures will be rejected. The default value of NIL causes the
interactor to not make this calculation and pass NIL as the @code{nap}
parameter to @code{final-function}.

@item @code{:max-dist-to-mean}
@cindex{max-dist-to-mean}
 - This field determines the maximum distance to the classified
gesture from the given gesture. Any gesture with a distance above
this value will be rejected.
The default value of NIL causes the interactor to not make this
calculation and pass NIL as the @code{dist} parameter to @code{final-function}.
@end table

@subsection Application Notification
@node Application Notification
@anchor{gestapplnotif}

Like the two-point-interactor, it is always necessary to have an
application function called with the result of the gesture-interactor.
The function is put into the @code{:final-function} slot of the interactor,
and is called with the following arguments:
@cindex{final-function}
@cindex{Gesture-Interactor}
@example
(lambda (an-interactor first-obj-over gesture-name attribs points-array nap dist))
@end example

The @code{gesture-name} will be set to the name the drawn gesture was
recognized as. These names are stored in the classifier as keyword
parameters (e.g., @code{:circle}). If the gesture could not be recognized
this will be set to NIL.

The @code{attribs} will be set to a structure of gesture attributes that may
be useful to the application. For example, the bounding box of the gesture
is one of these attributes. The following function calls can be used to
access these attributes:
@cindex{gest-attributes-startx}
@cindex{gest-attributes-starty}
@cindex{gest-attributes-initial-sin}
@cindex{gest-attributes-initial-cos}
@cindex{gest-attributes-dx2}
@cindex{gest-attributes-dy2}
@cindex{gest-attributes-magsq2}
@cindex{gest-attributes-endx}
@cindex{gest-attributes-endy}
@cindex{gest-attributes-minx}
@cindex{gest-attributes-maxx}
@cindex{gest-attributes-miny}
@cindex{gest-attributes-maxy}
@cindex{gest-attributes-path-r}
@cindex{gest-attributes-path-th}
@cindex{gest-attributes-abs-th}
@cindex{gest-attributes-sharpness}
@example
(gest-attributes-startx attribs)        ;@i{first point}
(gest-attributes-starty attribs)

(gest-attributes-initial-sin attribs)   ;@i{initial angle to the x axis}
(gest-attributes-initial-cos attribs)

(gest-attributes-dx2 attribs)           ;@i{differences: endx - prevx}
(gest-attributes-dy2 attribs)           ;@i{                   endy - prevy}
(gest-attributes-magsq2 attribs)        ;@i{(dx2 * dx2) + (dy2 * dy2)}

(gest-attributes-endx attribs)          ;@i{last point}
(gest-attributes-endy attribs)

(gest-attributes-minx attribs)          ;@i{bounding box}
(gest-attributes-maxx attribs)
(gest-attributes-miny attribs)
(gest-attributes-maxy attribs)

(gest-attributes-path-r attribs)        ;@i{total path length (in rads)}
(gest-attributes-path-th attribs)       ;@i{total rotation (in rads)}
(gest-attributes-abs-th attribs)        ;@i{sum of absolute values of path angles}
(gest-attributes-sharpness attribs)     ;@i{sum of non-linear function of absolute values}
                                        ;@i{of path angles counting acute angles heavier}
@end example

The @code{points-array} will be set to an array (of the form
[x1 y1 x2 y2...]) containing the points in the gesture. This array can
be used along with a NIL classifier to use the gesture-interactor as a
trace-interactor. A trace-interactor returns all the points the
mouse goes through between the @code{start-event} and the @code{stop-event}.
This is useful for inking in a drawing program.

@b{IMPORTANT NOTE:} The elements of the @code{attribs} structure and the
@code{points-array} should be accessed individually
(e.g., @code{(gest-attributes-minx attribs) (aref points-array 0) etc.})
or else they should be copied
(e.g., @code{(copy-gest-attributes attribs) (copy-seq points-array)})
before they are used in any object slots. This is necessary because
the interactor reuses the @code{attribs} structure and the @code{points-array}
in order to avoid extra memory allocation.

If @code{:min-non-ambig-prob} is not NIL, the @code{nap} parameter will be
set to the calculated non-ambiguous probability of the entered gesture.

If @code{:max-dist-to-mean} is not NIL, the @code{dist} parameter will be
set to the calculated distance of the entered gesture from the
classification.

@subsection Normal Operation
@node Normal Operation
@cindex{show-trace}
@cindex{classifier (slot)}
When the start event happens, if @code{:show-trace} is non-NIL, a trace
following the mouse pointer will be displayed. If @code{:show-trace}
is NIL, no trace will be seen.

If the mouse goes outside of @code{:running-where}, then the system will
beep and if @code{:show-trace} is non-NIL, the trace will be erased.

If the abort event happens and if @code{:show-trace} is non-NIL, the trace
will be erased.

When the stop event happens, if @code{:show-trace} is non-NIL, the trace
will be erased. Then, the final-function is called with the result of
classifying the given gesture with the classifier supplied in the
@code{:classifier} slot.

An error will be generated if the @code{:continuous} slot is anything
other than T, the default.

@subsection Example - Creating new Objects
@node Example - Creating new Objects
Create a rectangle when an ``L'' shape is drawn and create a circle when
a circle is drawn.
@sp 1
@cindex{creating new objects}
@cindex{examples}
@cindex{creating new objects}
@cindex{examples}
@cindex{Gesture-Interactor}
@example
; @i{load the gesture interactor, unless already loaded (Garnet does NOT load the gesture-interactor by default)}
(defvar DEMO-GESTURE-INIT
    (load Garnet-Gesture-Loader))

; @i{handle-gesture is called by the gesture interactor after it classifies a gesture}
(defun Handle-Gesture (inter first-obj-over gesture-name attribs
                       points-array nap dist)
    (declare (ignore inter first-obj-over points-array nap dist))
    (case gesture-name
        (:CIRCLE
            ; @i{create a circle with the same "radius" as the gesture and with the same upper left of the gesture}
            (opal:add-components SHAPE-AGG
                (create-instance NIL opal:circle
                   (:left (inter:gest-attributes-minx attribs))
                   (:top (inter:gest-attributes-miny attribs))
                   (:width (- (inter:gest-attributes-maxx attribs)
                              (inter:gest-attributes-minx attribs)))
                   (:height (- (inter:gest-attributes-maxx attribs)
                               (inter:gest-attributes-minx attribs)))))
        )
        (:RECTANGLE
            ; @i{create a rectangle with the same height and width as the gesture and with the same upper left of the gesture}
            (opal:add-components SHAPE-AGG
                (create-instance NIL opal:rectangle
                   (:left (inter:gest-attributes-minx attribs))
                   (:top (inter:gest-attributes-miny attribs))
                   (:width (- (inter:gest-attributes-maxx attribs)
                              (inter:gest-attributes-minx attribs)))
                   (:height (- (inter:gest-attributes-maxy attribs)
                               (inter:gest-attributes-miny attribs)))))
        )
        (otherwise
            (format T "Can not handle this gesture ...~%~%")
        )
    )
    (opal:update TOP-WIN)
)

; @i{create top-level window}
(create-instance 'TOP-WIN inter:interactor-window
   (:left 750) (:top 80) (:width 520) (:height 400)
)

; @i{create the top level aggregate in the window}
(s-value TOP-WIN :aggregate (create-instance 'TOP-AGG opal:aggregate))

; @i{create an aggregate to hold the shapes we will create}
(create-instance 'SHAPE-AGG opal:aggregate)
(opal:add-components TOP-AGG SHAPE-AGG)
(opal:update TOP-WIN)

; @i{create a gesture interactor that will allow us to create circles and rectangles}
(create-instance 'GESTURE-INTER inter:gesture-interactor
   (:window TOP-WIN)
   (:start-where (list :in TOP-WIN))
   (:running-where (list :in TOP-WIN))
   (:start-event :any-mousedown)
   (:classifier (inter:gest-classifier-read
                    (merge-pathnames "demo-gesture.classifier"
                        #+cmu "gesture-data:"
                        #-cmu user::Garnet-Gesture-Data-Pathname)))
   (:final-function #'Handle-Gesture)
   (:min-non-ambig-prob .95)
   (:max-dist-to-mean 60)
)
@end example

@subsection Agate
@node Agate
@anchor{agate}
@cindex{agate}
@cindex{training gestures}
@cindex{gestures}
@cindex{training new gestures}

Agate is a Garnet application that is used to train gestures for use
with the gesture interactor. Agate stands for @b{A}
@b{G}esture-recognizer @b{A}nd @b{T}rainer by @b{E}xample.
Agate is in the @code{gesture} subdirectory, and can be loaded using
@code{(garnet-load "gestures:agate")}. Then type @code{(agate:do-go)} to begin.

@float Figure, fig:ex8
@center @image{agate-pix, 5.5in}
@caption{An example session with the Agate gesture trainer}
@anchor{agate-pix}
@end float

@subsection End-User Interface
@node End-User Interface

To train a gesture classifier, the user first types a gesture name into
the @code{Gesture Class Name} field and then demonstrates approximately
15 examples of the gesture by drawing on the @code{Canvas} window with
one of the mouse buttons pressed. To train another gesture class the
user can press on the @code{New Class} button, type in the new gesture
name, and give some examples of the gesture. This is done repeatedly for
each of the gestures that the user would like the classifier to
recognize.
@sp 1

At any point, the user can try out the gestures trained so far by
switching to @code{Recognize} mode by clicking on the @code{Recognize}
toggle button. After demonstrating a gesture in @code{Recognize} mode,
Agate will print the name of the gesture in the @code{Gesture Class
Name} field, along with numbers that represent the non-ambiguity
probability and distance of the example from the mean (see section
@ref{rejecting-gestures}).

When the gesture classifier performs as desired, it can be saved to a
file by clicking on the @code{Save Classifier} button. Existing
classifiers can be modified by first loading them into Agate by
clicking on the @code{Load Classifier} button. Then the user can add
more examples to existing gestures or add entirely new gestures to the
classifier.

A gesture example can be deleted by first selecting the example (a
full-sized version of the gesture will be displayed on the Canvas) and
then clicking on the @code{Delete Example} button. Similarly, an entire
class can be deleted by selecting the class (all of the examples
will be displayed in the @code{Examples} window) and then clicking on
the @code{Delete Class} button. A gesture class can be renamed by
selecting the class and then editing the name in the @code{Gesture Class
Name} field.

The current gesture classifier can be cleared out by clicking on
the @code{New Classifier}. The user will be prompted to save the
classifier if it has not been previously saved.

@subsection Programming Interface
@node Programming Interface

Agate V2.0 is a self-contained interface tool that can be integrated within
another Garnet application. A designer can call @code{agate:do-go} with
parameters for an initial classifier, an initial name to be
displayed in the @code{Gesture Class Name} field, and a final function
to call when the user quits Agate.

@example
agate:Do-Go &key @emph{dont-enter-main-event-loop  double-buffered-p}@ref{function}
                 @emph{initial-classifier  initial-examples  initial-gesture-name final-function}
@end example

@code{Do-go} creates the necessary windows and Garnet objects, and 
then starts the application. The parameters to @code{do-go} are as follows:

@ftable @code

@item @emph{dont-enter-main-event-loop}
if T, don't enter the main event loop

@item @emph{double-buffered-p}
if T, use double buffered windows

@item @emph{initial-classifier}
initial classifier to use

@item @emph{initial-examples}
initial examples to display

@item @emph{initial-gesture-name}
name to fill in gesture class name field

@item @emph{final-function}
function to call on quit
@end ftable

The final function takes five parameters:

@vtable @var

@item @emph{last-saved-filename}
the last filename saved to

@item @emph{cur-classifier}
the current classifier (as of last training)

@item @emph{cur-examples}
the current examples (if untrained, will not 
necessarily correspond to the cur-classifier)

@item @emph{saved-p}
has the current classifier been saved?

@item @emph{trained-p}
has the current classifier been trained?
@end vtable


@subsection Gesture Demos
@node Gesture Demos

There are two demos that show how gestures can be used in an application.
Demo-gesture allows you to draw rough approximations of circles and
rectangles, which become perfect shapes in the window. Demo-unidraw is
a gesture-based text editor which uses a gesture shorthand for entering
characters. Both of these demos are discussed in the Demos section of
this manual, starting on page @ref{demos-first-page}.


@section Animator-Interactor
@node Animator-Interactor
@cindex{animator-interactor}
@anchor{animation}

@example
(create-instance 'inter:Animator-Interactor inter:interactor
  @emph{;; Slots common to all interactors (see section @ref{interslots})}
  (:window NIL)
  (:active T)

  @emph{; Slots specific to the button-interactor (discussed in this section)}
  (:timer-handler NIL)         @emph{; (lambda (inter))  ;; function to execute}
  (:timer-repeat-wait 0.2)     @emph{; time in seconds}
...)
@end example


The @code{animator-interactor} has been implemented using the
multiple process mechanism of Allegro, LispWorks, Lucid (also Sun and
HP) Common Lisp. @emph{It does not
work under CMU Common Lisp, AKCL, CLISP, etc.; sorry.}

The @code{animator-interactor} works quite differently from other
interactors. In particular, it is more procedural. 
You provide a function to be called at a fixed rate in the @code{:timer-handler}
slot, and a time interval in the slot @code{:timer-repeat-wait} at which this
function will be executed.
@cindex{timer-handler slot (animation)}
The @code{:timer-handler} function takes as a parameter the animation
interactor and should update the appropriate graphics.

Unlike other interactors, the animation interactor does @emph{not} start
immediately when created. You must explicitly start it operating with 
@code{inter:Start-Animator} and stop it with @code{inter:Stop-Animator}:
@cindex{Start-Animator}
@cindex{Stop-Animator}
@example
inter:Start-Animator @emph{animator-inter}@ref{function}

inter:Stop-Animator @emph{animator-inter}@ref{function}
@end example
After starting, the interactor will call the @code{:timer-handler} every
@code{:timer-repeat-wait} seconds until you explicitly stop the
interactor. It is OK for the @code{:timer-handler} itself to call
@code{stop-animator}.

Two special-purpose animator interactors have been supplied that have
built-in timer functions (so you don't have to supply the
@code{:timer-handler} for these):
@cindex{animator-bounce}
@cindex{animator-wrap}
@cindex{timer functions}
@example
(create-instance 'inter:Animator-Bounce inter:animator-interactor
  (:x-inc 2)
  (:y-inc 2)
  (:timer-repeat-wait 0.2)  @emph{; seconds}
  (:obj-to-change NIL)      @emph{; fill this in}
  ...)

(create-instance 'inter:Animator-Wrap inter:animator-interactor
  (:x-inc 2)
  (:y-inc 2)
  (:timer-repeat-wait 0.2) @emph{; seconds}
  (:obj-to-change NIL)     @emph{; fill this in}
  ...)
@end example

@code{Animator-bounce} will move the object supplied in the
@code{:obj-to-change} by @code{:x-inc} pixels in the x direction and
@code{:y-inc} pixels in the y direction every @code{:timer-repeat-wait}
seconds. The object is modified by directly setting its @code{:left}
and @code{:top}. (Note: @emph{not} its @code{:box} slot.)
When the object comes to the edge of its window, it will
bounce and change direction.

@code{Animator-wrap} moves an object the same way except that when it
gets to an edge, it re-appears at the opposite edge of the window.

See the demo @code{demo-animator} for examples.






@verbatim
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          All the interactors that are not yet implemented
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@section Button-Trill-Interactor
@node Button-Trill-Interactor
@emph{Performs the action once when the interactor starts, then after a
specified delay, does the action repeatedly at a particular rate until
stop-event}.

@emph{This section not yet written or implemented.}

@section Trace-Interactor
@node Trace-Interactor
@emph{This section not yet written or implemented.}

@section Multi-Point-Interactor
@node Multi-Point-Interactor

Stopping conditions: One of a set of other interactors wants to run, or two
points in the same place, or last point same as first point, or some other
special event, or event while outside.

@emph{This section not yet written or implemented.}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
@end verbatim




@section Transcripts
@node Transcripts

@anchor{transcripts-sec}
@cindex{Transcripts}
@cindex{Recording}
@cindex{Playback}

Garnet will create a transcript of all mouse and keyboard events in a file, and
allow the file to be replayed later as if the user had executed
all events again. This can be used for demonstrations, human factors testing,
and/or debugging. Using the transcript mechanism is very easy. The
procedure to start saving events is:
@cindex{Transcript-Events-To-File}
@example
inter:Transcript-Events-To-File @emph{filename  window-list}@ref{function}
				&key (@emph{motion} T) (@emph{if-exists} :supersede)
                                     (@emph{wait-elapsed-time} T) (@emph{verbose} T)
@end example
Events are then written to file @emph{filename}. The @emph{window-list} is a
list of windows that events should be saved for. It is also allowed to be
a single window. (Note: subwindows of windows on the window list are also
handled automatically, and do @emph{not} have to be specified.)
If the @code{:motion} parameter is specified as NIL, then
mouse movement events are not saved to the file, which can significantly
decrease the file size. The @code{:if-exists} parameter is used in the Lisp
@code{open} command when opening a file, and takes the same values (see
the Common Lisp book). If specified as @code{:append}, then the new events
are appended to the end of an existing file. The transcript is a textual
file, where each event has its own line. 

When you are finished making the transcript, call
@cindex{Close-Transcript}
@example
inter:Close-Transcript@ref{function}
@end example

To replay a transcript, use:
@cindex{Transcript-Events-From-File}
@example
inter:Transcript-Events-From-File @emph{filename window-list} &key (@emph{wait-elapsed-time} T)@ref{function}
@end example
The @emph{filename} is the file to read from. @emph{Wait-elapsed-time}
determines if the replay should wait for the correct time so the replay
goes about the same speed as the original user went, or else (if NIL)
whether the replay should just go as fast as possible. (Each event in the
transcript has a timestamp in it.)

It is important that the @emph{window-list} passed to
@code{Transcript-Events-From-File} be windows that are the same type
and in the same order as the windows passed to the
@code{Transcript-Events-To-File} call that made
the transcript. Garnet maps each event from the transcript into the
corresponding window in the specified window-list. The windows do not have
to be in the same places (all events are window-relative), however.

A typical example would be to create a bunch of windows, call 
@code{Transcript-Events-To-File}, do some operations, call
@code{Close-Transcript}, then sometime later, create new windows the
same way, then call @code{Transcript-Events-From-File}.

@cindex{Garnet-Break-Key}
@cindex{*Garnet-Break-Key*}
During playback, all mouse and keyboard events are ignored, except
@code{inter:*Garnet-Break-Key*}, which is normally bound to @code{:F1}.
This aborts
the transcript playback. Window refresh events are handled while
replaying, however.


@section Advanced Features
@node Advanced Features

@anchor{advancedfeatures}

This chapter describes a number of special features that will help
experienced Interactor users achieve some necessary effects. The features
described in this chapter are:

@table @emph

@item @emph{Priorities}
Interactors can be put at different priority levels, to help
control which ones start and stop with events.

@item @emph{Modes}
The priority levels and the @code{:active} slots can be used for
local or global modes.

@item @emph{Events}
The @code{event} structure that describes the user's event
can be useful.

@item @emph{Start-interactor} and @emph{Abort-Interactor}
These functions can be used
to explicitly start and stop an
interactor without waiting for its events.

@item @emph{Special slots of interactors}
There are a number of slots of
interactors that are maintained by the system that can be used by
programmers in formulas or custom action routines.

@item @emph{Multiple windows}
Interactors can be made to work over multiple
windows.

@item @emph{Waiting for interaction to complete}
To support synchronous interfaces.

@item @emph{Custom Action Routines}
Some advice about how to write your own action
routines, when necessary.
@end table

@section Priority Levels
@node Priority Levels
@cindex{Priorities}
@anchor{priorities}
Normally, when events arrive from the user, they are processed by @emph{all}
the interactors that are waiting for events. This means that if two
interactors are waiting for the same event (e.g. @code{:leftdown}) they may
both start if the mouse location passes both of their @code{:start-where}s.

The interactors do not know about object covering, so that even if an
object is covered by some other object, the mouse can still be in that
object. For example, you might have an interactor that starts when you
press over the indicator of a scroll bar, and a different interactor that
starts when you press on the background of the scroll bar. However, if
these interactors both start with the same event, they will both start when
the user presses on the indicator, because it is also inside the
background. Priority levels can be used to solve this problem.
The higher-priority interactors get to process events and run first, and if
they accept the event, then lower-priority interactors can be set up so
they do not run. Garnet normally uses three priority levels, but you can
but you can add more priority levels for your interactors as you need them
(see below).

By default, interactors wait at ``normal'' priority for their
start event to happen, and then are elevated to a higher priority while
they are running. This means that the stop event for the running
interactor will not be seen by other interactors. The programmer has full
control over the priorities of interactors, however. There are two slots of
interactors that control this:

@vtable @code
@item @code{:waiting-priority}
@cindex{waiting-priority}
- the priority of the interactor while waiting for its start event.
The default value is @code{inter:normal-priority-level}.

@item @code{:running-priority}
@cindex{running-priority}
- the priority of the interactor while running (waiting for the stop
event).
The default value is @code{inter:running-priority-level}.
@end vtable

There are a list of priority levels, each of which contains a list of
interactors. The events from the user are first processed by all the
interactors in the highest priority level. All the interactors at this level
are given the event. After they are finished, then lower level priorities
may be given the event (controlled by the @code{:stop-when} slot of the
priority level that has just finished running, see below).
Thus, all the interactors at the same priority level get to process the
events that any of them get.

@cindex{priority-level-list}
@cindex{priority-level}
There is a list of priorities stored in the variable
@code{inter:priority-level-list}. The first element of this list has the
highest priority, and the second element has the second priority, etc.
This list is exported so programs can use the standard list manipulation
routines to modify it.

The elements of this list must be
instances of @code{inter:priority-level}, which is a KR schema with the
following slots:

@vtable @code
@item :interactors
@cindex{interactors (slot of priority-level)}
- List of interactors at this priority level. This slot is maintained
automatically based on the values in the interactor's
@code{:waiting-priority} and @code{:running-priority} slots. @b{Do not set
or modify this slot directly.}

@item :active
@cindex{active (slot of priority-level)}
- Determines whether this priority level and all the interactors in it are
active. The default value is T.
For an interactor to be usable, both the interactor's @code{:active}
slot and the priority-level's @code{:active} slot must be non-NIL.
If this slot is NIL, then this level is totally ignored, including its
@code{:stop-when} field (see below). The value of the @code{:active} slot can
be a formula, but
if it changes to be NIL, the interactors will not be automatically aborted. Use
the @code{change-active} function to get the priority level and all its
interactors to be aborted immediately (see section @ref{active}).
Note: It is a really bad idea to make
the @code{:active} slot of any @emph{running}-priority levels be NIL, since
interactors will start but never complete.

@item :stop-when
@cindex{stop-when (slot of priority-level)}
- This slot controls what happens after the event has been processed by the
interactors at this priority level. This slot can take one of three
values:

@vtable @code
@item :always
@cindex{always}
- Always stop after handling this level. This means that the event is
never seen by interactors at lower levels. Pushing a new priority level
with @code{:stop-when} as @code{:always} on the front of @code{:priority-level-list}
is a convenient way to set up a special mode where the interactors in the
new priority level are processed and all other ones are ignored. The
priority level can be popped or de-activated (by setting its @code{:active}
slot to NIL) to turn this mode off.

@item :if-any
@cindex{if-any}
- If any of the interactors at this level accept the event, then do not
pass the event down to lower levels. If no interactors at this level want
the event, then @emph{do} pass it through to lower levels. This is used, for
example, for the @code{:stop-when} of the default
@code{running-priority-level} to keep the stop-event of a running interactor
from starting a different interactor.

@item nil
- If @code{:stop-when} is NIL, then the events are always passed through.
This might be useful if you want to control the order of interactors
running, or if you want to set the @code{:active} slots of the priority
levels independently.
@end vtable

@item :sorted-interactors
- See section @ref{sorted-sec}.
@end vtable

Three priority levels are supplied by default. These are:

@vtable @code
@item inter:running-priority-level
@cindex{running-priority-level}
- The highest default priority is for interactors that are running. It is
defined with @code{:stop-when} as @code{:if-any}.

@item inter:high-priority-level
@cindex{high-priority-level}
- A high-priority level for use by programs. It is
defined with @code{:stop-when} as @code{:if-any}.
 
@item inter:normal-priority-level
@cindex{normal-priority-level}
- The normal priority for use by interactors that are waiting to run.
@code{:Stop-when} is NIL.
@end vtable

The initial value of @code{priority-level-list} is:
@example
(list running-priority-level high-priority-level normal-priority-level)
@end example

The programmer can create new priority levels (using
@code{(create-instance NIL inter:priority-level ...)} and add them to this
list (using the standard Common Lisp list manipulation routines).
The new priorities can be at any level. Priorities can also be removed at
any time, but @emph{do not remove the three default priority levels}. 
There is nothing special about the pre-defined priorities. They are just
used as the defaults for interactors that do not define a waiting and
running priority. For example, it is acceptable to use the pre-defined
@code{inter:running-priority-level} as the @code{:waiting-priority} for an
interactor, or to use @code{inter:high-priority-level} as the
@code{:running-priority} of another interactor.

It is acceptable for an interactor to use the same priority level for its 
@code{:waiting-priority} and @code{:running-priority}, but it is a bad idea for
the  @code{:running-priority} to be @emph{lower} than the @code{:waiting-priority}.
Therefore, if you create a new priority level above the
@code{running-priority-level}
and use it as the @code{:waiting-priority} of an interactor, be sure to
create an even higher priority level for use as the @code{:running-priority}
of the interactor (or use the same priority level as both the waiting and
running priorities).

@subsection Example
@node Example
@anchor{movegrowexample1}

Consider the scroll bar. The interactor
that moves the indicator might have higher priority than the one that
operates on the background.
@cindex{scroll bar}
@cindex{Examples}
@cindex{Scroll Bar}
@cindex{Examples}
@cindex{Priority Levels}
@example
(create-instance NIL Inter:Move-Grow-Interactor
   (:window MYWINDOW)
   (:start-where (list :in-box INDICATOR))
   (:running-where (list :in-box SLIDER-SHELL))
   (:outside :last)
   (:attach-point :center)
   (:waiting-priority inter:high-priority-level))

(create-instance NIL Inter:Move-Grow-Interactor
   (:continuous NIL)
   (:window MYWINDOW)
   (:start-event :leftdown)
   (:start-where (list :in-box SLIDER-SHELL))
   (:obj-to-change indicator)
   (:attach-point :center))
@end example


@subsection Sorted-Order Priority Levels
@node Sorted-Order Priority Levels
@anchor{sorted-sec}
@cindex{priority levels}

As an experiment, and to support the Marquise tool which is in
progress, there is an alternative way to control which interactors run.
You can mark an interactor priority level as having
@code{:sorted-interactors}. When this slot of a priority level is
non-NIL, then the interactors in that level run in sorted order by the
number in the @code{:sort-order} slot of each interactor (which can be an
integer or float, negative or positive). The lowest numbered
interactor runs first. Then, if that interactor has a value in its 
@code{:exclusivity-value} slot, then no other interactor with the same value
in that slot will be run, but interactors with a different value in
that slot will be run in their sorted order. Interactors with NIL in
their @code{:sort-order} and/or @code{:exclusivity-value} slot will run after all
other interactors are run. Note that multiple interactors with the
same number in the @code{:sort-order} slot will run in an indeterminate order
(or if they have the same @code{:exclusivity-value}, then only one of them
will run, but no telling which one). The @code{:stop-when} slot of the
priority-level works as always to determine what happens when the
interactors in that level are finished.



@section Modes and Change-Active
@node Modes and Change-Active
@anchor{active}
@cindex{Modes}

In order to implement ``Modes'' in a user interface, you need to have
interactors turn off sometimes. This can be done in several ways. Section
@ref{modal-p} below discusses how to restrict all interactor input to a
single window (like a dialog box) while suspending the interactors in all
other windows. Section @ref{change-active} below discusses how to turn off
particular interactors or groups of interactors.


@subsection Modal Windows
@node Modal Windows
@anchor{modal-p}
@cindex{modal windows}

When the @code{:modal-p} slot of an @code{interactor-window} is T,
then interaction in all other Garnet windows
will be suspended until the window goes away (e.g., the user clicks an "OK"
button). Any input directed to a non-modal window will
cause a beep. If more than one modal window is visible at the same time,
then input can be directed at any of them (this allows stacking of modal
windows). The @code{:modal-p} slot can be calculated by a formula.
Typically, however, the @code{:modal-p} slot will stay T, and you will
simply set the window to be visible or invisible.

The @code{:modal-p} slot is often used in conjunction with
@code{wait-interaction-complete}, a function which suspends all lisp activity
until @code{interaction-complete} is called. An example application would make
a modal window visible, then call @code{wait-interaction-complete}. The user
would be unable to interact with the rest of the interface until the modal
window was addressed. Then, when the user clicks on the "OK" button in the
modal window, the window becomes invisible and @code{interaction-complete} is
called. Interaction then resumes as usual in the interface.
See section @ref{w-i-c} for a discussion of @code{wait-interaction-complete}.

The @code{error-gadget} and @code{query-gadget} dialog boxes use this feature
exactly as in the example above. They
ensure that the user responds to the error message before continuing any
action in the rest of the interface. The property sheet gadget display
routines and the @code{gilt:show-in-window} routine have an optional modal
parameter which uses this feature. You may be able to implement your design
using these gadgets and routines, rather than using the @code{:modal-p} slot
explicitly.



@subsection Change-Active
@node Change-Active
@cindex{Change-Active}
@cindex{active}
@anchor{change-active}
Interactors can either be turned on and off individually using
the @code{:active} slot in each interactor, or you can put a group of
interactors together in a priority level (see section @ref{priorities})
and turn on and off the entire group using the priority level's @code{:active}
slot.

The @code{:active} slot of an interactor may be @code{s-value}'d explicitly,
causing the interactor to abort immediately. But to change the activity of
a priority level, you should use the function @code{Change-Active}:

@example
inter:Change-Active @emph{an-interactor-or-priority-level new-value}@ref{function}
@end example
@cindex{Change-Active}
This makes the interactor or priority-level be active (if @emph{new-value} is T)
or inactive (if @emph{new-value} is NIL). When @code{change-active} makes a
priority level not active, then all interactors on the priority level will
abort immediately. Interactors are not guaranteed to abort immediately
if their priority level's @code{:active} slot is simply set to NIL.



@section Events
@node Events
@cindex{Events}
@anchor{Events}

Some functions, such as @code{Start-Interactor} (see section
@ref{startinteractor}) take an ``event'' as a
parameter. You might also want to look at an event to provide extra
features.

@code{Inter:Event} is an interactor-defined structure (a regular Lisp
structure, not a KR schema), and is not the same as
the events created by the X window manager or Mac QuickDraw.
Normally, programs do not need to ever look at the event structure,
but it is exported from interactors in case you need it.

@code{Inter:Event} has the following fields:

@vtable @code
@item window
@cindex{event-window}
- The Interactor window that the event occurred in.

@item char
@cindex{event-char}
- The Lisp character that the event corresponds to. If this is a mouse
event, then the @code{Char} field will actually hold a keyword like @code{:leftdown}.

@item code
@cindex{event-code}
- The X11 or MCL internal code for the event.

@item mousep
@cindex{event-mousep}
- Whether the event is a mouse event or not.

@item downp
@cindex{event-downp}
- If a mouse event, whether it is a down-transition or not.

@item x
@cindex{event-x}
- The X position of the mouse when the event happened.

@item y
@cindex{event-y}
- The Y position of the mouse when the event happened.

@item timestamp
@cindex{event-timestamp}
- The X11 or MCL timestamp for the event.
@end vtable

Each of the fields has a corresponding accessor and setf function:
@example
(event-window event)     (setf (event-window event) w)
(event-char event)       (setf (event-char event) c)
(event-code event)       (setf (event-code event) c)
(event-mousep event)     (setf (event-mousep event) T)
(event-downp event)      (setf (event-downp event) T)
(event-x event)          (setf (event-x event) 0)
(event-y event)          (setf (event-y event) 0)
(event-timestamp event)  (setf (event-timestamp event) 0)
@end example


@cindex{Make-Event}
You can create new events (for example, to pass to the
@code{Start-Interactor} function), using the standard structure creation
function @code{Make-Event}.
@example
inter:Make-Event &key (@emph{window} NIL) (@emph{char} :leftdown) (@emph{code} 1) (@emph{mousep} T) @ref{function}
                        (@emph{downp} T) (@emph{x} 0) (@emph{y} 0) (@emph{timestamp} 0))
@end example

@cindex{*Current-event*}
@cindex{Current-event}
The last event that was processed by the interactors system is stored in
the variable @code{Inter:*Current-Event*}. This is often useful for
functions that need to know where the mouse is or what actual mouse or
keyboard key was hit. Note that two of the fields of this event (window and
char) are copied into the slots of the interactor (see section
@ref{specialslots}) and can be more easily accessed from there.

@subsection Example of using an event
@node Example of using an event

@cindex{selecting in a rectangle} 
The two-point interactor calls the final-function with a NIL parameter if
the rectangle is smaller than a specified size (see section
@ref{twopapplnotif}). This feature can be used to allow the end user to
pick an object under the mouse if the user presses and releases, but to
select everything inside a rectangle if the user presses and moves (in this
case, moves more than 5 pixels).

Assume the objects to be selected are stored in the aggregate @code{all-obj-agg}.
@cindex{Select objects inside a box}
@cindex{Examples}
@cindex{Select objects inside a box}
@cindex{Examples}
@cindex{Events}
@cindex{Examples}
@cindex{Two-Point-Interactor}
@example
(create-instance 'SELECT-POINT-OR-BOX Inter:Two-Point-Interactor
  (:start-where T)
  (:start-event :leftdown)
  (:abort-if-too-small T)
  (:min-width 5)
  (:min-height 5)
  (:line-p NIL)
  (:flip-if-change-sides T)
  (:final-function
   #'(lambda (an-interactor final-point-list)
       (if (null final-point-list)
	   ; @i{then select object at point. Get point from}
	   ; @i{ the *Current-event* structure, and use it in the}
	   ; @i{ standard point-to-component routine.}
	   (setf selected-object
		 (opal:point-to-component ALL-OBJ-AGG
					  (inter:event-x inter:*Current-event*)
					  (inter:event-y inter:*Current-event*)))
	   ; @i{else we have to find all objects inside the rectangle.}
	   ; @i{ There is no standard function to do this.}
	   (setf selected-object
		 (My-Find-Objs-In-Rectangle ALL-OBJ-AGG final-point-list))))))
@end example


@section Starting and Stopping Interactors Explicitly
@node Starting and Stopping Interactors Explicitly
@cindex{Start-interactor}
@anchor{startinteractor}

Normally an interactor will start operating (go into the ``running'' state)
after its start-event happens over its start-where. However, sometimes it
is useful to explicitly start an interactor without waiting for its start
event. You can do this using the function @code{Start-interactor}.
For example, if a menu selection should cause a sub-menu to start
operating, or if after creating a new rectangle you want to immediately
start editing a text string that is the label for that rectangle.
 
@example
inter:Start-Interactor @emph{an-interactor} &optional (@emph{event} T)@ref{function}
@end example

This function does nothing if the interactor is already running or if it is
not active.
If an event is passed in, then this is used as the x and y location to
start with. This may be important for selecting which object the
interactor operates on, for example if the @code{:start-where} of the
interactor is @code{(:element-of <agg>)}, the choice of which element is made
based on the value of x and y in the event.
(See section @ref{events} for a description of the event). If
the event parameter is T (the default), then the last event that
was processed is re-used. The event is also used to calculate
the appropriate default stop event (needed if the start-event is
a list or something like @code{:any-mousedown} and the stop-event is not supplied).
If the event is specified as NIL or the x and y in the event do not pass
@code{:start-where}, the interactor is still started, but the initial object
will be NIL, which might be a problem (especially for button-interactors,
for example). NOTE: If you want the interactor to never start by itself,
then its @code{:start-where} or @code{:start-event} can be set to NIL. 

Examples of using @code{start-interactor} are in the file @code{demo-sequence.lisp}.

@cindex{Abort-interactor}
Similarly, it is sometimes useful to abort an interactor explicitly. This
can be done with the function:
@example
inter:Abort-Interactor @emph{an-interactor}@ref{function}
@end example
If the interactor is running, it is aborted (as if the abort event had occurred).

@cindex{Stop-Interactor}
@code{Stop-Interactor} can be called to stop an interactor as if the stop
event had happened.
@example
inter:Stop-Interactor @emph{an-interactor}@ref{function}
@end example
It reuses the last object the interactor was operating on, and the current event is
ignored. This function is useful if you want to have the interactor
stopped due to some other external action.
For example, to stop a text-interactor when the user chooses a menu item,
simply call stop-interactor on the text-interactor from the final-function
of the menu.

@section Special slots of interactors
@node Special slots of interactors
@anchor{specialslots}

There are a number of slots of
interactors that are maintained by the system that can be used by
programmers in formulas or custom action routines. These are:

@vtable @code
@item :first-obj-over
this is set to the object that is returned from

@item :start-where
This might be useful if you want a formula in the

@item :obj-to-change
lot that will depend on which object is pressed on
(see the examples below and in section @ref{editstringexample}). Note that
if the @code{:start-where} is T, then

@item :first-obj-over
ill be T, rather than an object. The value in

@item :first-obj-over
does not change as the interactor is running (it is
only set once at the beginning).

@item :current-obj-over
this slot is set with the object that the mouse
was last over (see section @ref{menufinalfeedbackobj}).

@item :current-window
this is set with the actual window of the last (or
current) input event. This might be useful for multi-window interactors (see
section @ref{multiwindow}). The @code{:current-window} slot is set
repeatedly while the interactor is running.

@item :start-char
The Lisp character (or keyword if a mouse event) of the
actual start event. This
might be useful, for example, if the start event can be one of a set of
things, and some parameter of the interactor depends on which one. See the
example below. The value in

@item :start-char
does not change as the interactor is running (it is
only set once at the beginning).

@end vtable

@subsection Example of using the special slots
@node Example of using the special slots

This example uses two slots of the interactor in formulas. A formula in the
@code{:grow-p} slot determines whether to move or grow an object based on
whether the user starts with a left or right mouse button
(@code{:start-char}). A formula in
the @code{:line-p} slot decides whether to change this object as a line or a
rectangle based on
whether the object started on (@code{:first-obj-over}) is a line or not.
Similarly, a formula in the feedback slot chooses the correct type of
object (line or rectangle).

The application creates a set of objects and stores them in an
aggregate called @code{all-object-agg}.

@anchor{movegrowexample2}
@cindex{Examples}
@cindex{Move or Change Size}
@cindex{Examples}
@cindex{Special Slots}
@example
(create-instance 'MOVE-OR-GROWER Inter:Move-Grow-Interactor
   (:start-event '(:leftdown :rightdown))  ;@i{either left or right}
   (:grow-p (o-formula (eq :rightdown (gvl :start-char)))) ;@i{grow if right button}
   (:line-p (o-formula (is-a-p (gvl :first-obj-over) opal:line)))
   (:feedback-obj (o-formula
		   (if (gvl :line-p)
		       MY-LINE-FEEDBACK-OBJ
		       MY-RECTANGLE-FEEDBACK-OBJ)))
   (:start-where `(:element-of ,ALL-OBJECT-AGG))
   (:window MYWINDOW))
@end example

@section Multiple Windows
@node Multiple Windows
@cindex{Multiple Windows}
@anchor{multiwindow}
@cindex{window}
Interactors can be made to work over multiple windows. The @code{:window}
slot of an interactor can contain a single window (the normal case), a list
of windows, or T which means all Interactor windows (this is rather
inefficient). If one of the last
two options is used, then the interactor will operate over all the
specified windows. This means that as the interactor is running, mouse
movement events are processed for all windows that are referenced. Also,
when the last of the windows referenced is deleted, then the interactor is
automatically destroyed.

This is mainly useful if you want to have an object move among various
windows. If you want an object to track the mouse as it changes windows,
however, you have to explicitly change the aggregate that the object is in
as it follows the mouse, since each window has a single top-level aggregate
and aggregates cannot be connected to multiple windows. You will probably
need a custom @code{:running-action} routine to do this (see section
@ref{customroutines}). This is true of the feedback object as well as the
main object.

You can look at the demonstration program
@code{demo-multiwin.lisp} to see how this might be done.


@section Wait-Interaction-Complete
@node Wait-Interaction-Complete
@anchor{w-i-c}

Interactors supplies a pair of functions which can be used to suspend
Lisp processing while waiting for the user to complete an action.
It is a little complicated to do this at the Interactors level,
but there is a convenient function for Gilt-created dialog boxes called
@code{gilt:Show-In-Window-And-Wait} (see the Gilt manual). Also,
@code{garnet-gadgets:display-error-and-wait} and
@code{garnet-gadgets:display-query-and-wait} can be used to pop up
message windows and wait for the user's response (see the
@code{error-gadget} in the Gadgets manual).

@cindex{wait-interaction-complete}
For other applications, you can call:
@example
inter:Wait-Interaction-Complete &optional @emph{window-to-raise}@ref{function}
@end example
which does not return until an interactor executes:
@cindex{interaction-complete}
@example
inter:Interaction-Complete &optional @emph{val}@ref{function}
@end example
If a @emph{val} is supplied, then this is returned as the value of
@code{Inter:Wait-Interaction-Complete}. The @emph{window-to-raise} parameter is
provided to avoid a race condition that occurs when you call update on a
window and
immediately call @code{wait-interaction-complete}. If you have problems with
this function, then try supplying your window as the optional argument.
@code{Wait-interaction-complete} will then raise your window to the top and
update it for you.


Typically, @code{Inter:Interaction-Complete} will be called in the
final-function of the interactor (or the selection-function of the gadget)
that should cause a value to be returned, such as a value associated with
the "OK" button of a dialog box. Note that you must use some other mechanism
of interactors to make sure that only the interactors you care about are
executable; @code{Wait-Interaction-Complete} allows @emph{all} interactors in
@emph{all} windows to run.




@section Useful Procedures
@node Useful Procedures

@cindex{bell}
@cindex{beep}
The text interactor beeps (makes a sound) when you hit an illegal
character. The function
to cause the sound is exported as
@example
inter:Beep@ref{function}
@end example
which can be used anywhere in application code also.

@cindex{warp-pointer}
The Interactors package exports the function
@example
inter:Warp-Pointer @emph{window x y}@ref{function}
@end example
which moves the position of the mouse cursor to the specified point
in the specified window. The result is the same as if the user had moved
the mouse to position <x,y>.



@section Custom Action Routines
@node Custom Action Routines
@cindex{Custom Action Routines}
@cindex{Action Routines}
@anchor{customroutines}

We have found that the interactors supply sufficient flexibility to support
almost all kinds of interactive behaviors. There are many parameters that
you can set in each kind of interactor, and you can use formulas
to determine values for these dynamically. The @code{final-function} can be used for
application notification if necessary.

However, sometimes a programmer may find that special actions are required
for one or more of the action routines. In this case, it is easy to
override the default behavior and supply your own functions. As described
in section @ref{interslots}, the action routines are:

@table @code
:stop-action

:start-action

:running-action

:abort-action

:outside-action

:back-inside-action
@end table

Each of the interactor types has its own functions supplied in each of
these slots.

If you want the default behavior @emph{in addition to} your own custom behavior, then
you can use the KR function @code{Call-Prototype-Method} to call the standard
function from your function. The parameters are the same as for your function.

For example, the @code{:running-action} for Move-Grow interactors is defined
(in section @ref{movegrowcustomaction}) as:
@example
(lambda (an-interactor object-being-changed new-points))
@end example
so to create an interactor with a custom action as well as the default
action, you might do:
@anchor{movegrowexample3}
@cindex{Examples}
@cindex{Running-action}
@example
(create-instance NIL Inter:Move-Grow-Interactor
   ... @i{the other usual slots}
   (:running-action
    #'(lambda (an-interactor object-being-changed new-points)
	(call-prototype-method an-interactor object-being-changed new-points)
	(@i{Do-My-Custom-Stuff}))))
@end example

The parameters to all the action procedures for all the interactor types
are defined in the following sections.

@subsection Menu Action Routines
@node Menu Action Routines
@cindex{Action Routines}
@cindex{Menu}
@cindex{Menu action routines}
@anchor{Menucustomaction}
@cindex{Menu action routines}

The parameters to the action routines of menu interactors are:

@table @code
@item :Start-action
@example
(lambda (an-interactor first-object-under-mouse))
@end example
Note that @code{:running-action} is not called until the
mouse is moved to a different object (it is not called on this first object
which is passed as @code{first-object-under-mouse}).

@item :Running-action 
@example
(lambda (an-interactor prev-obj-over new-obj-over))
@end example
This is called once each time the object under the mouse changes (not each
time the mouse moves).

@item :Outside-action 
@example
(lambda (an-interactor outside-control prev-obj-over))
@end example
This is called when the mouse moves out of the entire menu.
 @c (or over one of the exception items)
@code{Outside-Control} is simply the value of the @code{:outside} slot.

@item :Back-inside-action
@example
(lambda (an-interactor outside-control prev-obj-over new-obj-over))
@end example
Called when the mouse was outside all items and then moved back inside.
@code{Prev-obj-over} is the last object the mouse was over before it went
outside. This is used to remove feedback from it if @code{:outside} is
@code{:last}.

@item :Stop-action
@example
(lambda (an-interactor final-obj-over))
@end example
The interactor guarantees that @code{:running-action} @emph{has} been called on
@code{final-obj-over} before the @code{:stop-action} procedure is called.

@item :Abort-action
@example
(lambda (an-interactor last-obj-over))
@end example
@end table

@subsection Button Action Routines
@node Button Action Routines
@cindex{Action Routines}
@cindex{Button}
@cindex{Button action routines}
@anchor{buttoncustomaction}

The parameters to the action routines of button interactors are:

@vtable @code
:Start-action

@example
(lambda (an-interactor object-under-mouse))
@end example
Note that @code{back-inside-action} is not called this first time.

:running-action
This is not used by this interactor.
@code{:Back-inside-action} and @code{:Outside-action} are used instead.

:back-inside-action
@example
(lambda (an-interactor new-obj-over))
@end example
This is called each time the mouse comes back to the original object.

:outside-action
@example
(lambda (an-interactor last-obj-over))
@end example
This is called if the mouse moves outside of
@code{:running-where} before stop-event. The default @code{:running-where} is
@code{'(:in *)} which means in the object that the interactor started on.

:stop-action
@example
(lambda (an-interactor final-obj-over))
@end example

:abort-action
@example
(lambda (an-interactor obj-over))
@end example
Obj-over will be the object originally pressed on, or NIL if outside
when aborted.

@end vtable


@subsection Move-Grow Action Routines
@node Move-Grow Action Routines
@cindex{Action Routines}
@cindex{Move-Grow}
@cindex{Move-Grow action routines}
@anchor{movegrowcustomaction}

The parameters to the action routines of move-grow interactors are:

@table @code


:start-action
@example
(lambda (an-interactor object-being-changed first-points))
@end example
@code{First-points} is a list of the original left, top, width and
height for the object, or the original X1, Y1, X2, Y2, depending on the
setting of @code{:line-p}. The @code{object-being-changed} is the actual object
to change, not the feedback object. Note that @code{:running-action} is not
called on this first point; it will not be called
until the mouse moves to a new point.


:running-action
@example
(lambda (an-interactor object-being-changed new-points))
@end example
The @code{object-being-changed} is the actual object
to change, not the feedback object.


:outside-action
@example
(lambda (an-interactor outside-control object-being-changed))
@end example
The @code{object-being-changed} is the actual object
to change, not the feedback object. @code{Outside-control} is set with the
value of @code{:outside}.


:back-inside-action
@example
(lambda (an-interactor outside-control object-being-changed new-inside-points))
@end example
The @code{object-being-changed} is the actual object
to change, not the feedback object. Note that
the running-action procedure is not called on the point passed to this
procedure.


:stop-action
@example
(lambda (an-interactor object-being-changed final-points))
@end example
The @code{object-being-changed} is the actual object
to change, not the feedback object. @code{:Running-action} was not
necessarily called on the point passed to this procedure.


:abort-action
@example
(lambda (an-interactor object-being-changed))
@end example
The @code{object-being-changed} is the actual object
to change, not the feedback object.

@end table


@subsection Two-Point Action Routines
@node Two-Point Action Routines
@cindex{Action Routines}
@cindex{Two-Point}
@cindex{Two-Point action routines}
@anchor{twopcustomaction}

The parameters to the action routines of two-point interactors are:

@vtable @code

:start-action
@example
(lambda (an-interactor first-points))
@end example
The @code{first-points} is a list of the initial box or 2 points for the object
(the form is determined by the @code{:line-p} parameter). If
@code{:abort-if-too-small} is non-NIL, then @code{first-points} will be NIL.
Otherwise, the width and height of the object will be the @code{:min-width} and
@code{:min-height} or 0 if there are no minimums.
Note that @code{:running-action} is not
called on this first point; it will not be called
until the mouse moves to a new point.


:running-action
@example
(lambda (an-interactor new-points))
@end example
@code{New-points} may be NIL if @code{:abort-if-too-small} and
the size is too small.


:outside-action
@example
(lambda (an-interactor outside-control))
@end example
@code{Outside-control} is set with the value of @code{:outside}.


:back-inside-action
@example
(lambda (an-interactor outside-control new-inside-points))
@end example
Note that the running-action procedure is not called on the point passed to this
procedure. @code{New-inside-points} may be NIL if @code{:abort-if-too-small}
is non-NIL.


:stop-action
@example
(lambda (an-interactor final-points))
@end example
@code{:Running-action} was not
necessarily called on the point passed to this procedure.
@code{Final-points} may be NIL if @code{:abort-if-too-small} is non-NIL.


:abort-action
@example
(lambda (an-interactor))
@end example

@end vtable

@subsection Angle Action Routines
@node Angle Action Routines
@cindex{Action Routines}
@cindex{Angle}
@cindex{Angle action routines}
@anchor{anglecustomaction}

In addition to the standard measure of the angle, the
procedures below also provide an incremental measurement of the difference
between the current and last values. This might be used if you just want
to have the user give circular gestures to have something rotated. Then,
you would just want to know the angle differences. An example of this is in
@code{demo-angle.lisp}.

The parameters to the action routines of angle interactors are:

@vtable @code
@code{:Start-action} -
@example
(lambda (an-interactor object-being-rotated first-angle))
@end example
The
@code{first-angle} is the angle from directly to the right of the
@code{:center-of-rotation} that the mouse presses. This angle is in
radians. The @code{object-being-rotated} is the actual object
to move, not the feedback object. Note that @code{:running-action} is not
called on @code{first-angle}; it will not be called
until the mouse moves to a new angle.

@code{:Running-action} -
@example
(lambda (an-interactor object-being-rotated new-angle angle-delta))
@end example
The @code{object-being-rotated} is the actual object
to move, not the feedback object. @code{Angle-delta} is the difference
between the current angle and the last angle. It will either be positive
or negative, with positive being counter-clockwise. Note that it is always
ambiguous which way the mouse is rotating from sampled points, and the
system does not @emph{yet} implement any hysteresis, so if the user rotates
the mouse swiftly (or too close around the center point), the delta may
oscillate between positive and negative values, since it will guess wrong
about which way the user is going. @emph{In the future, this could be fixed
by keeping a history of the last few points and assuming the user is going
in the same direction as previously.}

@code{:Outside-action} -
@example
(lambda (an-interactor outside-control object-being-rotated))
@end example
The @code{object-being-rotated} is the actual object
to move, not the feedback object. @code{Outside-control} is set with the
value of @code{:outside}.

@code{:Back-inside-action} -
@example
(lambda (an-interactor outside-control object-being-rotated new-angle))
@end example
The @code{object-being-rotated} is the actual object
to move, not the feedback object. Note that
the running-action procedure is not called on the point passed to this
procedure. There is no @code{angle-delta} since it would be zero if
@code{:outside-control} was @code{NIL} and it would probably be inaccurate for
@code{:last} anyway.

@code{:Stop-action} -
@example
(lambda (an-interactor object-being-rotated final-angle angle-delta))
@end example
The @code{object-being-rotated} is the actual object
to move, not the feedback object. @code{:Running-action} was not
necessarily called on the angle passed to this procedure. @code{Angle-delta}
is the difference from the last call to @code{:running-action}.

@code{:Abort-action} -
@example
(lambda (an-interactor object-being-rotated))
@end example
The @code{object-being-rotated} is the actual object
to move, not the feedback object.

@end vtable


@subsection Text Action Routines
@node Text Action Routines
@cindex{Action Routines}
@cindex{Text}
@cindex{Text action routines}
@anchor{textcustomaction}

The parameters to the action routines of text interactors are:

@vtable @code
@code{:Start-action} -
@example
(lambda (an-interactor new-obj-over start-event))
@end example
@code{New-Obj-over} is the
object to edit, either @code{:obj-to-change} if it is supplied, or if
@code{:obj-to-change} is NIL, then the object returned from @code{:start-where}.
The definition of @code{event}s is in section @ref{events}.

@code{:Running-action} -
@example
(lambda (an-interactor obj-over event))
@end example

@code{:Outside-action} -
@example
(lambda (an-interactor obj-over))
@end example
Often, @code{:running-where} will be T so that this is never called.

@code{:Back-Inside-action} -
@example
(lambda (an-interactor obj-over event))
@end example

@code{:Stop-action} -
@example
(lambda (an-interactor obj-over stop-event))
@end example

@code{:Abort-action} -
@example
(lambda (an-interactor obj-over abort-event))
@end example

@end vtable



@subsection Gesture Action Routines
@node Gesture Action Routines
@cindex{action routines}
@cindex{Gesture}
@cindex{gesture action routines}
@anchor{gestcustomaction}

The parameters to the action routines of gesture interactors are:

@vtable @code
@code{:Start-action} -
@example
(lambda (an-interactor object-under-mouse point))
@end example
The @code{point} is the first point of the gesture.


@code{:Running-action} -
@example
(lambda (an-interactor new-obj-over point))
@end example

@code{:Outside-action} -
@example
(lambda (an-interactor prev-obj-over))
@end example
This beeps and erases the trace if @code{show-trace} is non-NIL. It also
sets @code{:went-outside} to T.

@code{:Back-inside-action} -
@example
(lambda (an-interactor new-obj-over))
@end example
This currently does nothing.

@code{:Stop-action} -
@example
(lambda (an-interactor final-obj-over point))
@end example
@code{:Running-action} was not necessarily called on the point passed to this
procedure, so it is added to @code{*points*}. This procedure calls
@code{gest-classify} with the points in the trace, @code{*points*}, and
the classifier given by @code{:classifier}.


@code{:Abort-action} -
@example
(lambda (an-interactor))
@end example
This erases the trace if @code{:show-trace} is non-NIL and
@code{:went-outside} is NIL.

@end vtable


@subsection Animation Action Routines
@node Animation Action Routines

The @code{animator-interactor} does not use these action slots. All of the
work is done by the function supplied in the @code{:timer-handler} slot.




@section Debugging
@node Debugging

@cindex{Debugging}

There are a number of useful functions that help the programmer debug
interactor code. Since these are most useful in conjunction with the tools
that help debug KR structures and Opal graphical objects, all of these are
described in a separate Garnet Debugging Manual.

In summary, the functions provided include:

@itemize
@cindex{PS}
Interactors are KR objects so they can be printed using
@code{kr:ps} and @code{hemlock-schemas}.

@cindex{Trace-Inter}
The @code{Inter:Trace-Inter} routine is
useful for turning on and off tracing output that tells what interactors
are running. Type @code{(describe 'inter:trace-inter)} for a description.
@emph{This function is only available when the @code{garnet-debug} compiling
switch is on (the default).}

@cindex{Ident}
@code{(garnet-debug:ident)} will tell the name of the next event
(keyboard key or mouse button) you hit.

@cindex{Look-inter}
@code{(garnet-debug:look-inter &optional parameter)} describes the active
interactors, or a particular interactor, or the interactors that affect a
particular graphic object.

@cindex{Print-Inter-Levels}
@code{(inter:Print-Inter-Levels)}
will print the names of all of the active interactors in all priority levels.

@cindex{Print-Inter-Windows}
@cindex{Windows (debugging function)}
@code{(inter:Print-Inter-Windows)} will print the names of all the interactor
windows, and @code{(garnet-debug:Windows)} will print all Opal and Interactor
windows.

@cindex{clean-up}
Destroying the interactor windows will normally get rid of interactors.
You can use @code{(opal:clean-up :opal)} to delete all interactor windows.

If for some reason, an interactor is not
deleted (for example, because it is not attached to a window), then
@cindex{Reset-Inter-Levels}
@example
inter:Reset-Inter-Levels &optional @emph{level}@ref{function}
@end example
will remove @emph{all} the existing interactors by simply resetting the queues (it
does not destroy the existing interactors, but they will never be
executed). If a level is specified, then only interactors on that level
are destroyed. If level is NIL (the default), then all levels are reset.
This procedure should not be used in applications, only for debugging.
It is pretty drastic.
@end itemize

@verbatim
====================================================
@section Issues
@node Issues


How handle sliding out of a menu and having a sub-menu appear?

Should we increase the number of interactors and decrease the number of
parameters to each?

What other specific interactors are needed?

Need trill button also?

Can we eliminate some of these interactors if we make interactors simpler?
For example, use a timer interactor and a regular button interactor
together to make a trill. 

Can Menu and Button interactors be combined?

How to make the feedback object have the same properties as the real
object, e.g., with respect to constraints on movement (grids, only in X,
etc.). Want to be able to get them dynamically from the object and/or from
the particular interactor or parameters to the interactor (e.g., when press
here, only move in X)  Solutions: extra parameters w/filters passed to the
interactors, have a "move-object" function (like create-function in twop)
that is passed either the feedback-obj or the real object (but this is
similar to the running-action and stop-action), somehow copy the
constraints into the feedback object (may require creating a new object
and/or new constraint objects), or leave as is so user defines own
running-action and stop-action procedures.
====================================================
@end verbatim

@ref{References}


@chapter Aggregadgets, Aggrelists, & Aggregraphs
@node Aggregadgets, Aggrelists, & Aggregraphs


Andrew Mickish,
Roger B. Dannenberg,
Philippe Marchal,
David Kosbie,
A. Bryan Loyall

@value{DATE}

@section Abstract
@node Abstract

Aggregadgets and aggrelists are objects used to define natural hierarchies
of other objects in the Garnet system. They allow the interface designer to
group graphical objects and associated behaviors into a single prototype
object by declaring the structure of the components.
Aggrelists are particularly useful in the creation of menu-type objects,
whose components are a sequence of similar items corresponding to a list
of elements. Aggrelists will automatically maintain the layout of the
graphical list of objects. Aggregraphs are similarly used to create and
maintain graph structures.




@section Aggregadgets
@node Aggregadgets


@section Accessing Aggregadgets and Aggrelists
@node Accessing Aggregadgets and Aggrelists
@cindex{loading aggregadgets}
The aggregadgets and aggrelists files are automatically loaded when the
file @code{garnet-loader.lisp} is used to load Garnet. The
@code{garnet-loader} file uses one loader file for both aggregadgets
and aggrelists called @code{aggregadgets-loader.lisp}. Loading this file
causes the KR, Opal, and Interactors files to be loaded also.

Aggregadgets and aggrelists reside in the @code{Opal} package. 
All identifiers in this manual are exported from the @code{Opal} package unless
another package name is explicitly given. These identifiers can be
referenced by using the @code{opal} prefix, e.g. @code{opal:aggregadget};
the package name may be dropped if the line
@code{(use-package "OPAL")}
is executed before referring to any object in that package.

@section Aggregadgets
@node Aggregadgets

During the construction of a complicated Garnet interface, the designer will
frequently be required to arrange sets of objects into groups
that are easy to manipulate. These sets may have intricate dependencies among
the objects, or possess a hierarchical structure that suggests a further
subgrouping of the individual objects. Interactors may also be associated with
the objects that should intuitively be defined along with the objects
themselves.

Aggregadgets provide the designer with a straightforward method for the
definition and use of sets of Garnet objects and interactors. When an
aggregadget is supplied
with a list of object definitions, Garnet will internally create instances
of those objects and add them to the aggregadget as components. If the
objects are given names, Garnet will create slots in the aggregadget
which point to the objects, granting easy access to the components.
Interactors that manipulate the components of
the aggregadget may be similarly defined.

By creating instances of aggregadgets, the designer actually groups the
objects and interactors under a single prototype (class) name. The defined
prototype may be used repeatedly to create more instances of the defined
group. To illustrate this feature of aggregadgets, consider the schemata
shown below:
@example
(create-instance 'MY-GROUP opal:aggregadget
   (:parts
           ...)       @emph{; some group of graphical objects}
   (:interactors
           ...))      @emph{; some group of interactors}

(create-instance 'GROUP-1 MY-GROUP)

(create-instance 'GROUP-2 MY-GROUP
   ...)               @emph{; definition of more slots}
@end example

The schema MY-GROUP defines a set of associated graphical objects and
interactors using an instance of the @code{opal:aggregadget} object. The
schemata @code{group-1} and @code{group-2} are instances of the @code{my-group}
prototype which inherit all of the parts and behaviors defined in the
prototype. The @code{group-2} schema additionally defines new slots in the
aggregadget for some special purpose.


@subsection How to Use Aggregadgets
@node How to Use Aggregadgets
@anchor{what-an-agg}
@anchor{parts-syntax-sec}
@cindex{aggregadget}
@cindex{parts in aggregadgets}
In order to group a set of objects together as components of an aggregadget,
the designer must define the objects in the @code{:parts} slot of the
aggregadget.

The syntax of the @code{:parts} slot is a backquoted list of lists, where
each inner list defines one component of the aggregadget.
The definition of each component includes a keyword that will be used as a
name for that part
(or NIL if the part is to be unnamed), the prototype of that part, and a
set of slot definitions that customize the component from the prototype.

The aggregadget will internally convert this list of parts into components of
the aggregadget, with each part named by the keyword provided (or unnamed,
if the keyword is NIL).

Everything inside the backquote that should be evaluated immediately must be
preceded by a comma. Usually the following will need commas:
the prototype of the component, variable names, calls to @code{formula}
and @code{o-formula}, etc.

After an aggregadget is created, the designer should not refer to the
@code{:parts} slot. Each component may be accessed by name as a slot of the
aggregadget. Additionally, all components are listed in the
@code{:components} slot just as in aggregates.
@cindex{components slot}  As with aggregates, components are listed
in display order, that is, @emph{from back to front}.

A short example of an aggregadget definition
is shown in figure @ref{check-mark}, and the picture of this
aggregadget is in figure @ref{simple-expl-pict-ref}.

@float Figure, fig:ex9
@example
(create-instance 'CHECK-MARK opal:aggregadget
   (:parts
    `((:left-line ,opal:line
                  (:x1 70)
                  (:y1 45)
                  (:x2 95)
                  (:y2 70))
      (:right-line ,opal:line
                   (:x1 95)
                   (:y1 70)
                   (:x2 120)
                   (:y2 30)))))
@end example
@caption{A simple CHECK-MARK aggregadget.}
@anchor{check-mark}
@end float

@float Figure, fig:ex10
@center @image{agg-check-mark, 5.5in}

@caption{The picture of the CHECK-MARK aggregadget.}
@anchor{simple-expl-pict-ref}
@end float

Of course, the designer may define other slots in the aggregadget besides the
@code{:parts} slot. One convenient programming style involves the 
definition of several slots in the top-level aggregadget (such as
@code{:left}, @code{:top}, etc.) with formulas in several components that refer
to these values, thereby allowing a change in one top-level slot to
propagate to all dependent slots in the components. Slots of components may
also contain formulas that refer to other components (see section
@ref{agg-dependencies}).


@subsection Named Components
@node Named Components

When keywords are given in the @code{:parts} list that correspond to each
component, those keywords are used as names for the components. In figure
@ref{check-mark}, the names are @code{:left-line} and @code{:right-line}.
Since these names were supplied, the slots @code{:left-line} and @code{:right-line}
are set in the CHECK-MARK aggregadget with the components themselves as values.
That is, @code{(gv CHECK-MARK :left-line)} yields the actual component that
was created from the @code{:parts} description.

The slot @code{:known-as} in the component is also set with the name of the
component. In the example above, @code{(gv CHECK-MARK :left-line :known-as)}
yields @code{:left-line}. Another way to look at these slots and objects is
shown in figures @ref{agg-ps-ref} and @ref{part-ps-ref}.

When adding a new component to an aggregadget, you can set the @code{:known-as}
slot of the component with a keyword name, which will be used in the top-level
aggregadget as a slot name that points directly to the new component. The
example at the end of section @ref{constants-and-aggregadgets} illustrates
the idea of setting the @code{:known-as} slot.

@float Figure, fig:ex11
@example

@b{lisp>} (ps CHECK-MARK)

{#k<CHECK-MARK>
  :RIGHT-LINE = #k<KR-DEBUG:RIGHT-LINE-226>
  :LEFT-LINE = #k<KR-DEBUG:LEFT-LINE-220>
  :COMPONENTS = #k<KR-DEBUG:LEFT-LINE-220> #k<KR-DEBUG:RIGHT-LINE-226>
  ...
  :PARTS = ((:LEFT-LINE #k<OPAL:LINE>
                        (:X1 70) (:Y1 45) (:X2 95) (:Y2 70))
            (:RIGHT-LINE #k<OPAL:LINE>
                         (:X1 95) (:Y1 70) (:X2 120) (:Y2 30)))
  ...
  :IS-A = #k<OPAL:AGGREGADGET>
}
NIL
@b{lisp>}
@end example
@caption{The printout of the CHECK-MARK aggregadget.}
@anchor{agg-ps-ref}
@end float
@cindex{components slot}


@float Figure, fig:ex12
@example

@b[lisp>] (ps (gv CHECK-MARK :right-line))

{#k<KR-DEBUG:RIGHT-LINE-226>
  :PARENT =  #k<CHECK-MARK>
  :KNOWN-AS =  :RIGHT-LINE
  ...
  :Y2 =  30
  :X2 =  120
  :Y1 =  70
  :X1 =  95
  :IS-A =  #k<OPAL:LINE>
}
NIL
@b[lisp>] 

@end example
@caption{The @code{:right-line} component of CHECK-MARK.}
@anchor{part-ps-ref}
@end float

As shown in figure @ref{agg-ps-ref}, CHECK-MARK has two components:
RIGHT-LINE-226 which is a line created according to the definition of 
@code{:right-line} in the @code{:parts} slot of the CHECK-MARK
aggregadget, and LEFT-LINE-220 corresponding to the definition of the
@code{:left-line} part. The CHECK-MARK
aggregadget also has two slots, @code{:right-line} and @code{:left-line}, whose
values are the corresponding components.


@subsection Destroying Aggregadgets
@node Destroying Aggregadgets

@cindex{destroy}
@code{opal:Destroy} @emph{gadget}@ref{method}

@cindex{destroy-me}
@code{opal:Destroy-Me} @emph{gadget}@ref{method}

The @code{destroy} method destroys an aggregadget or aggrelist 
and its instances.
To destroy a gadget means to destroy its interactors, components,
and item-prototype-object as well as the gadget schema itself.
The @code{destroy-me} method for
aggregadgets and aggrelists destroys the prototype but not its
instances. @emph{Note:} users of gadgets should call @code{destroy};
implementors of subclasses should override @code{destroy-me}.


@subsection Constants and Aggregadgets
@node Constants and Aggregadgets
@cindex{constants in aggregadgets}
@anchor{constants-and-aggregadgets}
The ability to define constant slots is an advanced feature of Garnet that is
discussed in detail in the KR manual. However, the aggregadgets use
some of the features of constant slots by default.

All aggregadgets created with an initial @code{:parts} list have
constant @code{:components}. That is, after the aggregadget has
been created with all of its parts, the @code{:components} slot becomes
constant automatically, and the components of the aggregadget are
not normally modifiable. Also, the @code{:known-as} slot of each part
and the slot in the aggregadget corresponding to the name of each
part is constant. By declaring these slots constant, Garnet is able
to automatically get rid of the greatest number of formulas possible,
thereby freeing up memory for other objects.

For example, given the following instance of an @code{aggregadget},
@example
(create-instance 'MY-AGG opal:aggregadget
  (:parts
   `((:obj1 ,opal:rectangle
            (:left 20) (:top 40))
     (:obj2 ,opal:circle
            (:left 50) (:top 10)))))
@end example
the slots @code{:components}, @code{:obj1}, and @code{:obj2} will be
constant in MY-AGG. The result is that you cannot remove components
or add new components to this aggregadget without disabling the
constant mechanism.

If you really want to add another component to the aggregadget, you
could use the macro @code{with-constants-disabled}, which is described
in the KR Manual:
@example
(with-constants-disabled
  (opal:add-component MY-AGG (create-instance NIL opal:roundtangle
                               (:known-as :obj3)  @emph{; will become a constant slot}
                               (:left 40) (:top 20))))
@end example
Adding components to a constant aggregadget is discouraged because
the aggregadget's dimension formulas that
were already thrown away (if they were evaluated) will not be updated with the
dimensions of the new components. That is, if OBJ3 in the example
above is outside of the original bounding box of MY-AGG
(calculated by the formulas in MY-AGG's @code{:left}, @code{:top}, @code{:width},
and @code{:height} slots), then Opal will fail to display the new
component correctly because it only updates the area enclosed by
MY-AGG's bounding box. 

A better solution than forcibly adding components is to create a
non-constant aggregadget to begin with. Since only aggregadgets that
are created with a @code{:parts} slot are constant, you should start with an
aggregadget without a @code{:parts} list, and add your components using
@code{add-component}. Thus, the better way to build the aggregadet above is:
@example
(create-instance 'MY-AGG opal:aggregadget)
(opal:add-components MY-AGG (create-instance NIL opal:rectangle
                              (:known-as :obj1)
                              (:left 20) (:top 40))
                            (create-instance NIL opal:circle
                              (:known-as :obj2)
                              (:left 50) (:top 10)))
@emph{; Then later...}
(opal:add-component MY-AGG (create-instance NIL opal:roundtangle
                             (:known-as :obj3)
                             (:left 40) (:top 20)))
@end example
Note that you will have to supply your own @code{:known-as} slots in the
components if you want the aggregadet to have slots referring to those
components.


@subsection Implementation of Aggregadgets
@node Implementation of Aggregadgets
@anchor{known-as-sec}
An aggregadget is an instance of the prototype @code{opal:aggregate},
with an initialize method that interprets the @code{:parts} slot
and provides other functions.
This initialize method performs the following tasks:

@itemize
an instance of every part is created,

all these instances are added (with @code{add-component}) as the components
of the aggregadget,

for each part, a slot is created in the aggregate. The name of this slot is
the name of the part, and its value is the instance of the corresponding
part.

The slot @code{:known-as} in the part is set with the part's name.

In some cases (described in detail later), some or all of the
structure of the prototype aggregadget is inherited by the new instance. 
@end itemize


@subsection Dependencies Among Components
@node Dependencies Among Components
@anchor{agg-dependencies}
@cindex{dependencies}
@cindex{Formulas", Secondary="in aggregadgets}
@cindex{o-formula}

Aggregadgets are designed to facilitate the definition of dependencies among
their components. When a slot of one component depends on the value of a
slot in another component of the same aggregadget, that dependency is
expressed using a formula.

The aggregadget is considered the parent of
the components, and the components are all siblings within the aggregadget.
Thus, the @code{:parent} slot of each component can be used to travel up the
hierarchy, and the slot names of the aggregadget and its components can be
used to travel down.

Consider the following modification to the CHECK-MARK schema
defined in section @ref{what-an-agg}. In figure @ref{check-mark}, the
@code{:x1} and @code{:y1} slots of the @code{:right-line} object are the same as
the @code{:x2} and @code{:y2} slots of the @code{:left-line} object so that
the two lines meet at a common point. Rather than explicitly
repeating these coordinates in the @code{:right-line} object, dependencies
can be defined in the @code{:right-line} object that cause its origin to always
be the terminus of the @code{:left-line}. Figure @ref{modified-check-mark}
shows the definition of this modified schema.

@float Figure, fig:ex13
@example
(create-instance 'MODIFIED-CHECK-MARK opal:aggregadget
   (:parts
    `((:left-line ,opal:line
                  (:x1 70)
                  (:y1 45)
                  (:x2 95)
                  (:y2 70))
      (:right-line ,opal:line
                   (:x1 ,(o-formula (gvl :parent :left-line :x2)))
                   (:y1 ,(o-formula (gvl :parent :left-line :y2)))
                   (:x2 120)
                   (:y2 30)))))
@end example
@caption{A modified CHECK-MARK schema.}
@anchor{modified-check-mark}
@end float

@cindex{commas}
Commas must precede the calls to @code{o-formula} and the references to the
@code{opal:line} prototype because these items must be evaluated
immediately. Without commas, 
the @code{o-formula} call, for example, would
be interpreted as a quoted list due to the backquoted @code{:parts} list.

The macro @code{gvl-sibling} is provided to abbreviate references between
the sibling components of an aggregadget:

@cindex{gvl-sibling}
@defmac opal:gvl-sibling sibling-name &rest slots

For example, the @code{:x1} slot of the @code{:right-line} object in figure
@ref{modified-check-mark} may be
given the equivalent value
@example
,(o-formula (opal:gvl-sibling :left-line :x2))
@end example

@end defmac

@subsection Multi-level Aggregadgets
@node Multi-level Aggregadgets

Aggregadgets can be used to define more complicated objects with a
multi-level hierarchical structure. Consider the picture of a check-box
shown in figure @ref{check-box-pict-ref}.

@float Figure, fig:ex14
@center @image{agg-check-box, 5.5in}
@caption{A picture of a check-box.}
@anchor{check-box-pict-ref}
@end float

The check-box can be considered a hierarchy of objects:  the CHECK-MARK
object defined in figure @ref{check-mark}, and a box. This
hierarchy is illustrated in figure @ref{check-box-hier-ref}.

@float Figure, fig:ex15
@example

                             check-box
                               /  \
                              /    \
                            box  check-mark
                                    /  \
                                   /    \
                            left-line   right-line
@end example
@caption{The hierarchical structure of a check-box.}
@anchor{check-box-hier-ref}
@end float

The CHECK-BOX hierarchy is implemented through aggregadgets in figure 
@ref{check-box-def-ref}. Although the CHECK-BOX schema defines the
@code{:box} component explicitly, the details of the @code{:mark} object have
been defined elsewhere in the CHECK-MARK schema (see 
figure @ref{check-mark}).
The aggregadget definition for the CHECK-MARK part could have been
written out explicitly, as in the more complicated CHECK-BOX schema of
figure @ref{custom-check-box1}. However, the CHECK-BOX definition
presented here uses a modular approach that allows the reuse of the
CHECK-MARK schema in other applications.

@float Figure, fig:ex16
@example
(create-instance 'CHECK-BOX opal:aggregadget
   (:parts
    `((:box ,opal:rectangle
            (:left 75)
            (:top 25)
            (:width 50)
            (:height 50))
      (:mark ,CHECK-MARK))))
@end example
@caption{The definition of a check-box.}
@anchor{check-box-def-ref}
@end float

See section @ref{Custom-check-box2} for another example of a modularized
multi-level aggregadget, and see section @ref{instances-sec} for 
information about inheriting structure from other multi-level aggregadgets.

@subsection Nested Part Expressions for Aggregadgets
@node Nested Part Expressions for Aggregadgets
Recall that parts are specified in a @code{:parts} slot and
that the syntax for a part is


@code{(@emph{name} @emph{prototype} {{@var{slot}  @var{value}}}@var{+[*]})}


where @emph{name} is either a keyword or NIL, @emph{prototype} is a prototype
for the part, and @emph{slots} is a list of local slot definitions. 
If @emph{prototype} is an aggregadget, then @emph{slots} may contain
another parts slot; thus, an entire aggregadget tree can be specified
by nested @code{:parts} slots.

For example, figure @ref{x-box-fig} implements a box containing an X.
Notice how the @code{:mark} part of X-BOX is an aggregadget containing
its own parts.
@float Figure, fig:ex17
@center @image{xbox-fig, 5.5in}
@example

;;; compute vertical position in :box according to a proportion
(defun vert-prop (frac) 
  (+ (gvl :parent :parent :box :top)
     (round (* (gvl :parent :parent :box :height) 
	       frac))))

;;; compute horizontal position in :box according to a proportion
(defun horiz-prop (frac)
  (+ (gvl :parent :parent :box :left)
     (round (* (gvl :parent :parent :box :width)
	       frac))))

(create-instance 'X-BOX opal:aggregadget
   (:left 20) 
   (:top 20)
   (:width 50)
   (:height 50)
   (:parts
    `((:box ,opal:rectangle
	    (:left ,(o-formula (gvl :parent :left)))
	    (:top  ,(o-formula (gvl :parent :top)))
	    (:width  ,(o-formula (gvl :parent :width)))
	    (:height ,(o-formula (gvl :parent :height))))
      (:mark ,opal:aggregadget
	     (:parts
	      ((:line1 ,opal:line
		       (:x1 ,(o-formula (horiz-prop 0.3)))
		       (:y1 ,(o-formula (vert-prop 0.3)))
		       (:x2 ,(o-formula (horiz-prop 0.7)))
		       (:y2 ,(o-formula (vert-prop 0.7))))
	       (:line2 ,opal:line
		       (:x1 ,(o-formula (horiz-prop 0.7)))
		       (:y1 ,(o-formula (vert-prop 0.3)))
		       (:x2 ,(o-formula (horiz-prop 0.3)))
		       (:y2 ,(o-formula (vert-prop 0.7)))))))))))

@end example
@caption{A box with an X, illustrating nested parts.}
@anchor{x-box-fig}
@end float


@subsection Creating a Part with a Function
@node Creating a Part with a Function
@cindex{Part-generating functions}
@cindex{Single parts}
@cindex{Functions for parts}
@cindex{Single parts}
@anchor{creating-part-fn}

Instead of defining a prototype as a part, the designer may specify a
function which will be called in order to generate the part. This
feature can be useful when you plan to create several instances of an
aggregadget that are similar, but with different objects as parts.
For example, the aggregadgets in figure @ref{single-part-fn} all have
the same prototype.

@float Figure, fig:ex18
@center @image{single-part-fn, 5.5in}
@caption{Aggregadgets that generate a part through a function.}
@anchor{single-part-fn}
@end float

The syntax for generating a part with a function is to specify a
function within the @code{:parts} list where a prototype for the part
would usually go. The function must take one argument, which is the
aggregadget whose part is being generated. Slots of the aggregadget
may be accessed at any time inside the function.

The purpose of the function is to return an
object that will be a component of the aggregadget. You should
@b{not} add the part to the aggregadget yourself in the function.
However, you must be careful to always return an object that can be
used directly as a component. For example, the @code{opal:circle} object
would not be a suitable object to return, since it is the prototype of
many other objects. Instead, you would return an @emph{instance} of
@code{opal:circle}.

Additionally, you must be careful to consider the case where the
object to be used has already been used before. That is, if you wanted
the function to return a rectangle more than once, the function must be
smart enough to return a particular rectangle the first time, and return
a different rectangle the second time and every time thereafter.
Usually it is sufficient to look at the @code{:parent} slot of the
object to check if it is already part of another aggregadget. The
following code, which generates the figure in @ref{single-part-fn},
takes this multiple usage of an object into consideration.

@example
(defun Get-Label (agg)
  (let* ((item (gv agg :item))
         @emph{;; Item may be an object or a string}
	 (new-label (if (schema-p item)
			(if (gv item :parent)
			    @emph{;; The item has been used already --}
			    @emph{;; Use it as a prototype}
			    (create-instance NIL item)
			    @emph{;; Use the item itself}
			    item)
		        (create-instance NIL opal:text
			  (:string item)
			  (:font (opal:get-standard-font
                                  :sans-serif :bold :very-large))))))
    (s-value new-label :left (o-formula (opal:gv-center-x-is-center-of (gvl :parent))))
    (s-value new-label :top (o-formula (opal:gv-center-y-is-center-of (gvl :parent))))
    new-label))

(create-instance 'AGG-PROTO opal:aggregadget
  (:item "Text")
  (:top 20) (:width 60) (:height 80)
  (:parts
   `((:frame ,opal:rectangle
	     (:left ,(o-formula (gvl :parent :left)))
	     (:top ,(o-formula (gvl :parent :top)))
	     (:width ,(o-formula (gvl :parent :width)))
	     (:height ,(o-formula (gvl :parent :height))))
     (:label ,#'Get-Label))))

(create-instance 'CIRCLE-LABEL opal:circle
  (:width 30) (:height 30)
  (:line-style NIL)
  (:filling-style opal:black-fill))

(create-instance 'SQUARE-LABEL opal:rectangle
  (:width 30) (:height 30)
  (:line-style NIL)
  (:filling-style opal:black-fill))

(create-instance 'AGG1 AGG-PROTO
  (:left 10)
  (:item CIRCLE-LABEL))

(create-instance 'AGG2 AGG-PROTO
  (:left 90)
  (:item SQUARE-LABEL))

(create-instance 'AGG3 AGG-PROTO
  (:left 170)
  (:item "W"))
@end example

Some of the functionality provided by a part-generating function is
overlapped by the customization syntax for aggregadget instances
described in section @ref{overriding-slots}. For example, the labels
in figure @ref{single-part-fn} could have been customized from the
prototype by supplying prototypes in the local @code{:parts} list of
each instance. However, for some applications using aggrelists, this
feature is indespensable (see section @ref{multi-parts-fn}).


@subsection Creating All of the Parts with a Function
@node Creating All of the Parts with a Function
@cindex{Part-generating functions}
@cindex{All parts}
@cindex{Functions for parts}
@cindex{All parts}
@anchor{run-time}

As an alternative to supplying a list of component definitions in the
@code{:parts} slot, the designer may instead specify a function which will
generate the parts of the aggregadget during its initialization.
This feature is useful when the components of the aggregadget are related in
some respect that is easily described by a function procedure, as in figure
@ref{multi-line-pict-ref}.

@float Figure, fig:ex19
@center @image{agg-multi-line, 5.5in}
@caption{The multi-line picture.}
@anchor{multi-line-pict-ref}
@end float

This feature of aggregadgets is not usually used since, in most cases,
aggrelists supply the same functionality. When all the components of an
aggregadget are instances of the same prototype, the designer should
consider implementing an itemized aggrelist, discussed in chapter
@ref{aggrelists}.

The function may be specified in the @code{:parts} slot as either a
previously defined function or a lambda expression.
The function must take one parameter:  the aggregadget whose parts are being
created. The function must return a list of the created parts (e.g., a
list of instances of @code{opal:line}) and,
optionally, a list of the names of the parts. If supplied, the names must
be keywords
which will become slot names for the aggregadget, providing access to the
individual components (see section @ref{agg-dependencies}). (@emph{Note:} The
standard lisp function @code{values} may be used to return two arguments from the
generating function.)
@cindex{values (lisp function)}

@cindex{multi-line}
Figure @ref{multi-line1-ref} shows how to create an aggregadget made
of multiple lines, with the end-points of the lines given in the
special slot @code{:line-end-points}. The figure creates the object on
the left of figure @ref{multi-line-pict-ref}.

@float Figure, fig:ex20
@example
(create-instance 'MULTI-LINE opal:aggregadget
   (:parts
    `(,#'(lambda (self)
	   (let ((lines NIL))
	     (dolist (line-ends (gv self :lines-end-points))
	       (setf lines (cons (create-instance NIL opal:line
				   (:x1 (first line-ends))
				   (:y1 (second line-ends))
				   (:x2 (third line-ends))
				   (:y2 (fourth line-ends)))
				 lines)))
	     (reverse lines)))))
   (:lines-end-points '((10 10 100 100)
			(10 100 100 10)
			(55 10 55 100)
			(10 55 100 55))))
@end example

@caption{An aggregadget with a function to create the parts.}
@anchor{multi-line1-ref}
@end float


Figure @ref{multi-line2-ref} shows how to create the same aggregadgets as in
figure @ref{multi-line-pict-ref}, but with a separately defined function rather
than a lambda expression.
In addition, this function returns the list of the names of
the parts. Two instances of the aggregadget are created, with only one of
these instances having names for the lines.

@float Figure, fig:ex21
@example
(defun Make-Lines (lines-agg)
  (let ((lines NIL))
    (dolist (line-ends (gv lines-agg :lines-end-points))
      (setf lines (cons (create-instance NIL opal:line
			   (:x1 (first line-ends))
			   (:y1 (second line-ends))
		           (:x2 (third line-ends))
			   (:y2 (fourth line-ends)))
			lines)))
    (values (reverse lines) (gv lines-agg :lines-names))))

(create-instance 'MY-MULTI-LINE1 opal:aggregadget
   (:parts `(,#'Make-Lines))
   (:lines-end-points '((10 10 100 100)
                        (10 100 100 10)
                        (55 10 55 100)
                        (10 55 100 55)))
   (:lines-names
    '(:down-diagonal :up-diagonal :vertical :horizontal)))

(create-instance 'MY-MULTI-LINE2 opal:aggregadget
   (:parts `(,#'Make-Lines))
   (:lines-end-points '((120 100 170 10)
                        (170 10 220 100)
                        (220 100 150 100))))
@end example

@caption{An aggregadget with a function to create named parts.}
@anchor{multi-line2-ref}
@end float

It should be noted that the use of a function to create parts is @emph{not}
inherited. If the @code{:parts} slot is omitted, then the actual parts (not
the function that created the parts) are inherited from the prototype. It
is possible to override the @code{:initialize} method to obtain a different
instantiation convention, but probably it is simplest just always to specify
the @code{:parts} slot indicating the function that creates parts.


@section Interactors in Aggregadgets
@node Interactors in Aggregadgets
@anchor{agg-interactors}
@cindex{interactors}

Interactors may be grouped in aggregadgets in precisely the same way that
objects are grouped. The slot @code{:interactors} is analogous to the
@code{:parts} slot, and may contain a list of interactor definitions that
will be attached to the aggregadget.

As with the @code{:parts} slot, @code{:interactors} must contain a backquoted
list of lists with commas preceding everything that should be evaluated
immediately@ref{dash}prototypes, function calls, variable references, etc. 
The name of a function that generates a set of interactors can also be
given with the same parameters and functionality as the @code{:parts}
function described in section @ref{run-time}.
@cindex{function for :interactors}
@cindex{interactors function}

@cindex{behaviors slot}
If a keyword is supplied as the name for an interactor, then a slot with
that name will be
automatically created in the aggregadget, and the value of that slot will
be the interactor. For example, in figure @ref{framed-text}, a slot
called @code{:text-inter} will be created in the aggregadget to refer to
the text interactor.
The system will also add to the aggregadget a @code{:behaviors} slot, containing
a list of pointers to the interactors. This slot is analogous to the
@code{:components} slot for graphical objects.


@cindex{operates-on}
Each interactor will be given a new @code{:operates-on} slot which is
analogous to the @code{:parent} slot for component objects. The
@code{:operates-on} slot contains a pointer to the aggregadget that the
interactor belongs to. This slot should be used when referring to the
aggregadget from within interactors.

@cindex{windows for interactors}
In order to activate any interactor in Garnet, its @code{:window} slot must
contain a pointer to the window in which the interactor operates.
In most cases, the window for the interactor will be found in
the @code{:window} slot of the aggregadget, which is internally
maintained by aggregates. Hence, the following slot definition should be
included in all interactors defined in an aggregadget:
@example
(:window ,(o-formula (gv-local :self :operates-on :window)))
@end example
@emph{Note:} in this formula, @code{gv-local} is used to follow local
links @code{:operates-on} and @code{:window}. Using @code{gv-local} instead of
@code{gv} or @code{gvl} when referring to these slots helps avoid accidental
references to these slots in the aggregdagets' prototype.
Most values for the @code{:window} slots of aggregadget interactors will
resemble this formula.

The interactors are independent of the parts, and either feature
may be used with or without the other. When using both parts and
interactors, any object may refer to any other using the methods described
in section @ref{agg-dependencies}.

Figure @ref{framed-text} shows how to create a ``framed-text'' aggregadget
that allows the input and display of text. This aggregadget is made of two
parts, a frame (a rectangle) and a text object, and one interactor
(a text-interactor). Figure @ref{agg-inter-ps-ref} is a partial printout of
the FRAMED-TEXT aggregadget with its built-in interactor, illustrating the
slots created by the system. A picture of the aggregadget is shown in
figure
@ref{framed-text-pix}.
@cindex{framed-text example}

@float Figure, fig:ex22
@example
(create-instance 'FRAMED-TEXT opal:aggregadget
   (:left 0)      @emph{; Set these slots to determine}
   (:top 0)       @emph{; the position of the aggregadget.} 
   (:parts
    `((:frame ,opal:rectangle
          (:left ,(o-formula (gvl :parent :left)))
          (:top ,(o-formula (gvl :parent :top)))
          (:width ,(o-formula (+ (gvl :parent :text :width) 4)))
          (:height ,(o-formula (+ (gvl :parent :text :height) 4))))
      (:text ,opal:text
          (:left ,(o-formula (+ (gvl :parent :left) 2)))
          (:top ,(o-formula (+ (gvl :parent :top) 2)))
          (:cursor-index NIL)
          (:string ""))))
   (:interactors
     @emph{; Press on the text object (inside the frame) to edit the string}
    `((:text-inter ,inter:text-interactor
	  (:window ,(o-formula (gv-local :self :operates-on :window)))
          (:feedback-obj NIL)
          (:start-where ,(o-formula
                          (list :in (gvl :operates-on :text))))
          (:abort-event #\control-\g)
          (:stop-event (:leftdown #\RETURN))))))
@end example
@caption{Definition of an aggregadget with a built-in interactor.}
@anchor{framed-text}
@end float


@float Figure, fig:ex23
@example

@b[lisp>] (ps FRAMED-TEXT)
{#k<FRAMED-TEXT>
  ...
  :COMPONENTS =  #k<KR-DEBUG:FRAME-205> #k<KR-DEBUG:TEXT-207>
  :FRAME =  #k<KR-DEBUG:FRAME-205>
  :TEXT =  #k<KR-DEBUG:TEXT-207>
  :BEHAVIORS =  #k<KR-DEBUG:TEXT-INTER-214>
  :TEXT-INTER =  #k<KR-DEBUG:TEXT-INTER-214>
  ...
  :IS-A =  #k<OPAL:AGGREGADGET>
}
NIL
@b[lisp>] (ps (gv FRAMED-TEXT :text-inter))

{#k<KR-DEBUG:TEXT-INTER-214>
  ...
  :OPERATES-ON =  #k<FRAMED-TEXT>
  ...
  :IS-A =  #k<INTERACTORS:TEXT-INTERACTOR>
}
NIL
@b[lisp>] 

@end example
@caption{The printouts of an aggregadget and its attached interactor.}
@anchor{agg-inter-ps-ref}
@end float


@float Figure, fig:ex24
@center @image{framed-text-pix, 5.5in}
@caption{A picture of the FRAMED-TEXT aggregadget.}
@anchor{framed-text-pix}
@end float



@section Instances of Aggregadgets
@node Instances of Aggregadgets
@anchor{agg-insts}
The preceding chapter discussed the use of the @code{:parts} slot
to define the structure of new aggregadgets. Once an aggregadget
is created, the structure will be inherited by instances. The
@code{:parts} slot can be used to extend or override this default
structure.

@subsection Default Instances of Aggregadgets
@node Default Instances of Aggregadgets
@anchor{instances-sec}
By default, when an instance of an aggregadget is created,
an instance of each component and interactor is also created.
Figure
@ref{instance-fig} illustrates an aggregadget on the left and its instance
on the right. Notice that each object within the prototype aggregadget
serves as a prototype for each corresponding object in the instance
aggregadget. The structure of the instance aggregate matches the structure
of the prototype, including ``external'' references to objects not in either
aggregate, as illustrated by the reference from C to D. Since D is external
to the aggregate, there is no D', and the reference to D is inherited by C'.


@float Figure, fig:ex25
@center @image{instance-fig, 5.5in}
@caption{A prototype aggregate and one instance. The dashed lines
go from instances to their prototypes, solid lines 
join children to parents, and the dotted line from C to D represents 
a formula dependence which is inherited by C'.}
@anchor{instance-fig}
@end float

When creating instances, it is possible to override slots and parts
of the prototype aggregadget, provided that these slots were not declared
constant in the prototype.

@subsection Overriding Slots and Structure
@node Overriding Slots and Structure
@anchor{overriding-slots}
Just as instances of
KR objects can override slots with local values, aggregadgets can override
slots or even entire parts (objects) with local values. The @code{:parts}
and @code{:interactors} syntax is used to override details of an
aggregadget when constructing an instance.

When creating an instance of an aggregadget that already has components,
there are several variations of the @code{:parts} syntax that can be used
to inherit components. As illustrated in these examples, if @emph{any} parts
are listed in
a @code{:parts} list, then @emph{all} parts should be listed. This is
explained further in section @ref{more-syntax-sec}:
@enumerate
If the entire @code{:parts} slot is omitted, then the components are
instantiated in the default manner described above. For example,
@example
(create-instance 'NEW-X-BOX X-BOX (:left 100))
@end example
will instantiate the @code{:box} and @code{:mark} parts of @code{x-box}
by default.

Any element in the list of parts may be a keyword rather than a list.
The keyword must name a component of the prototype, and an instance
of that component is created. Parts are always added in the order
they are listed, regardless of their order in the prototype.
For example:
@example
(:parts `(:shadow :box :feedback))
@end example

@cindex{omit (keyword in aggregadgets)}
Any element in the list of parts may be a list of the form
@code{(@emph{name} :omit)}, where @emph{name} is the name of a component
in the prototype, and @code{:omit} indicates that an instance of that
part is not included in the instance aggregadget. For example:
@example
(:parts `((:shadow :omit)
	  :box
	  :feedback))
@end example

@cindex{modify (keyboard in aggregadgets)}
Any element in the list of parts may be a list of the form
@cindex{modify (keyword)}
@code{(@emph{name} :modify @emph{slots})}, where @emph{name} is the part name,
@code{:modify} means to use the default prototype, and @emph{slots} is a
standard list of slot names and values which override slots inherited
from the prototype. Only the changed slots
need to be listed; the others are inherited from the prototype. [Note:
this is different from the @code{:parts} slot, where you must list all the
parts if you are changing any of them.]
If the object is an aggregadget, then one of the
slots may be a @code{:parts} list to further specify components.
For example:
@example
(:parts `((:shadow :modify (:offset 5))
	  :box
	  :feedback))
@end example

Any element of the list of parts may be a list of the form
@code{(@emph{name} @emph{prototype} @emph{slots})}, as described in section
@ref{parts-syntax-sec}. This indicates that the part should be added
to the instance aggregadget.
If @emph{name} names an existing component in the aggregadget, then
the new part will override the part that would otherwise be inherited.
@end enumerate


@subsection Simulated Multiple Inheritance
@node Simulated Multiple Inheritance
In some cases, it is desirable to inherit particular slots from
a default prototype object, but to override the actual prototype.
For example, one might want to change rectangles in a prototype
into circles but still inherit the @code{:top} and @code{:left} slots.
Alternatively, one might want to replace a number box with a dial
but still inherit a @code{:color} slot from the prototype number box.

The @code{:parts} syntax has a special variation to accomplish this form
of multiple inheritance. If the keyword @code{:inherit} occurs at the
top level in the @emph{slots} list, then the next element of @emph{slots}
must be a list of slot names. All the slots not mentioned in the
@code{:inherit} clause are inherited from the new prototype (the circle in
the example below). For example:
@example
(:parts `((:shadow ,opal:circle
	    (:offset 5)
	    :inherit (:left :top :width :height :filling-style))
	  :box
	  :feedback))
@end example


@subsection Instance Examples
@node Instance Examples
Figure @ref{circle-x-box-fig} illustrates how to override and inherit
parts from an aggregadget. The prototype aggregadget is the @code{x-box}
aggregadget shown in figure @ref{x-box-fig}. In the instance named
CIRCLE-X-BOX, a circle has been inserted between the box and the ``X''
mark, and the box has a gray fill.

@float Figure, fig:ex26
@center @image{circle-xbox-fig, 5.5in}
@example

(create-instance 'CIRCLE-X-BOX X-BOX
   (:left 150)
   (:top 160)
   (:parts 
    `((:box :modify (:filling-style ,opal:gray-fill))
      (:circle ,opal:circle
	       (:left ,(o-formula (+ (gvl :parent :left) 2)))
	       (:top ,(o-formula (+ (gvl :parent :top) 2)))
	       (:width ,(o-formula (- (gvl :parent :width) 4)))
	       (:height ,(o-formula (- (gvl :parent :height) 4)))
	       (:filling-style ,opal:white-fill))
      :mark))))
@end example
@caption{Adding a circle and changing the filling style in an instance
of the X-BOX aggregadget.}
@anchor{circle-x-box-fig}
@end float

In figure @ref{circle-box-fig}, the CIRCLE-X-BOX aggregadget is
further modified by replacing the ``X'' with a circle.

@float Figure, fig:ex27
@center @image{circle-box-fig, 5.5in}
@example

(defun circle-box-test ()
  (create-instance 'CIRCLE-BOX CIRCLE-X-BOX
   (:left 150)
   (:top 220)
   (:parts
    `(:box 
      :circle
      (:mark :omit)
      (:inner-circle ,opal:circle
	     (:left ,(o-formula (+ (gvl :parent :left) 10)))
	     (:top ,(o-formula (+ (gvl :parent :top) 10)))
	     (:width ,(o-formula (- (gvl :parent :width) 20)))
	     (:height ,(o-formula (- (gvl :parent :height) 20))))))))
@end example
@caption{Omitting the ``X'' and adding an inner circle to the
CIRCLE-X-BOX aggregadget.}
@anchor{circle-box-fig}
@end float

@subsection More Syntax: Extending an Aggregadget
@node More Syntax: Extending an Aggregadget
@anchor{more-syntax-sec}
Normally, each part of a prototype should be explicitly mentioned
in the @code{:parts} list. This is perhaps tedious, but it makes the
code clear. There is one exception
that is provided to make it simple to add things to existing prototypes.

If @emph{none} of the parts of a prototype are mentioned in the parts list,
then instances of @emph{all} of the prototype's parts are included in
the instance aggregadget. If additional parts are specified, they
are added after the default parts, so they will appear graphically on
top. @emph{It is
an error to mention some but not all of a prototype's parts in a @code{:parts}
list.}  (The current implementation only looks to see if the @emph{first}
part of the prototype is mentioned in the @code{:parts} list in order to
decide whether or not to include all of the prototype parts.)  

Figure @ref{x-sq-box-fig} illustrates the extension of 
the @code{:mark} part of the @code{x-box} prototype with
a rectangle. Since parts @code{:line1}
and @code{:line2} are not mentioned, they are included in the @code{:mark} 
part automatically.

@float Figure, fig:ex28
@center @image{x-sq-box-fig, 5.5in}
@example

(defun x-sq-box-test ()
  (create-instance 'X-SQ-BOX X-BOX
    (:left 210)
    (:top 20)
    (:parts
     `(:box		; inherit the box with no change
       (:mark :modify	; modify the mark
	(:parts		; since :line1 and :line2 are not mentioned,
			; they are inherited as is
	 ((:square ,opal:rectangle	; add a new part to the mark
	      (:left ,(o-formula (horiz-prop 0.2)))
	      (:width ,(o-formula (- (horiz-prop 0.8) 
				     (horiz-prop 0.2))))
	      (:top ,(o-formula (vert-prop 0.2)))
	      (:height ,(o-formula (- (vert-prop 0.8) 
				      (vert-prop 0.2))))))))))))
@end example
@caption{Extending the x-box prototype with a new rectangle in the mark
part.}
@anchor{x-sq-box-fig}
@end float

@section Aggrelists
@node Aggrelists
@cindex{aggrelists}
@anchor{aggrelists}

Many interfaces require the arrangement of a set of objects in a graphical
list, such as menus and parallel lines. Aggrelists are designed to
facilitate the arrangement of objects in graphical lists while providing
many customizable slots that determine the appearance of the list. The
methods @code{add-component} and @code{remove-component} can be used to alter
the components in the list after the aggrelist has been instantiated.
(See section @ref{aggrelist-manipulation-sec}.)

@cindex{itemized aggrelists}
A special style of aggrelists, called ``itemized aggrelists'', may be used
when the items of the list are all instances of the same prototype (e.g., all
items in a menu are text strings).
These aggrelists use the methods @code{add-item} and @code{remove-item}
to manipulate the components of the list.

Aggrelists are independent of aggregadgets and may be used separately or
inside aggregadgets. Aggrelists may also have aggregadgets as components
in order to create objects such as menus or choice lists.

Interactors may be defined for aggrelists using the same methods that
implement interactors in aggregadgets (section @ref{agg-interactors}).

@subsection How to Use Aggrelists
@node How to Use Aggrelists

@sp 1
The definition of the @code{aggrelist} prototype in Opal is:
@sp 1

@example
(create-instance 'opal:aggrelist opal:aggregate
 (:maybe-constant '(:left :top :width :height :direction :h-spacing :v-spacing
		    :indent :h-align :v-align :max-width :max-height
		    :fixed-width-p :fixed-height-p :fixed-width-size
		    :fixed-height-size :rank-margin :pixel-margin :items :visible))
 (:left 0)
 (:top 0)
 (:width (o-formula ...))
 (:height (o-formula ...))
 (:direction :vertical)	      @emph{; Can be :horizontal, :vertical, or NIL}
 (:h-spacing 5)		      @emph{; Pixels between horizontal elements}
 (:v-spacing 5)		      @emph{; Pixels between vertical elements}
 (:indent 0)		      @emph{; How much to indent on wraparound}
 (:h-align :left)	      @emph{; Can be :left, :center, or :right}
 (:v-align :top)	      @emph{; Can be :top, :center, or :bottom}
 (:max-width  (o-formula (...)))
 (:max-height (o-formula (...)))
 (:fixed-width-p NIL)	      @emph{; Whether to use fixed-width-size}
 (:fixed-height-p NIL)        @emph{; Whether to use fixed-height-size}
 (:fixed-width-size NIL)      @emph{; The width of all components}
 (:fixed-height-size NIL)     @emph{; The height of all components}
 (:rank-margin NIL)           @emph{; If non-NIL, the number of components in each row/column}
 (:pixel-margin NIL)          @emph{; Same as :rank-margin, but with pixels}
 (:head NIL)                  @emph{; The first component (read-only slot)}
 (:tail NIL)                  @emph{; The last component (read-only slot)}
 (:items NIL)                 @emph{; List of the items or a number}
 (:item-prototype NIL)        @emph{; Specification of prototype of the items (when itemized)}
 (:item-prototype-object NIL) @emph{; The actual object, set internally (read-only slot)}
 ...)
@end example

Aggrelists are easily customized by providing values for the controlling
slots. Any slot listed below may be given a value during the definition
of an aggrelist. The slots can also be modified (using the KR function
@code{s-value}) after the aggrelist is displayed to change the appearance of
the objects. However, each slot has a default value and the designer
may choose to ignore most of the slots.

@cindex{constants in aggrelists}
The list in @code{:maybe-constant} contains those slots that will be
declared constant in an aggrelist whose @code{:constant} slot contains T.
That is, when you create an aggrelist with the slot @w{@code{(:constant T)}},
then all of these slots are guaranteed not to change, and all formulas
that depend on those slots will be removed and replaced by absolute
values. This removal of formulas has the potential to save a large amount
of storage space.

The following slots are available for customization of aggrelists:

@vtable @code

@code{:left} @ref{shortdash} The leftmost coordinate of the aggrelist
(default is 0).

@code{:top} @ref{shortdash} The topmost coordinate of the aggrelist
(default is 0).

@code{:items} @ref{shortdash} A number (indicating the number of items
in the aggrelist) or a list of values that will be used by the components.
If the value is a list, then do not destructively modify the value;
instead, set the value with a new list (using @code{list}) or use @code{copy-list}.

@code{:item-prototype} @ref{shortdash} Either a schema or a
description of a schema (see section @ref{the-i-p-slot}).

@cindex{direction}
@code{:direction} @ref{shortdash} Either :@code{horizontal},
@code{:vertical} or NIL. If the value is either @code{:horizontal} or 
@code{:vertical}, the system will install values in the @code{:left} and
@code{:top} slots of each component, in order to lay out the
list properly according to the direction. If the value is NIL, then the
designer must provide formulas for the @code{:left} and @code{:top}
slots of each component (default is @code{:vertical}).

@cindex{v-spacing}
@code{:v-spacing} @ref{shortdash} Vertical spacing between elements
(default is 5). 

@cindex{h-spacing}
@code{:h-spacing} @ref{shortdash} Horizontal spacing between elements
(default is 5). 

@cindex{fixed-width-p}
@code{:fixed-width-p} @ref{shortdash} If set to T, all the components
will be placed in fields of constant width. These fields will be of
the size of the widest component, unless the slot
@code{:fixed-width-size} is non-NIL, in which case it will default to
the value stored there (default is NIL). 

@cindex{fixed-width-size}
@code{:fixed-width-size} @ref{shortdash} The width of all components,
if @code{:fixed-width-p} is T (default is NIL).

@cindex{fixed-height-p}
@code{:fixed-height-p} @ref{shortdash} If set to T, all the components
will be placed in fields of constant height. These fields will be of
the size of the tallest component, unless the slot
@code{:fixed-height-size} is non-NIL, in which case it will default to
the value stored there (default is NIL). 

@cindex{fixed-height-size}
@code{:fixed-height-size} @ref{shortdash} The height of all components, if
@code{:fixed-width-p} is T (default is NIL).

@cindex{h-align}
@code{:h-align} @ref{shortdash} The type of horizontal alignment to use within
a field (only applicable if @code{fixed-width-p} is T). Allowed values are
 @code{:left}, @code{:center}, or @code{:right} (default is @code{:left}).

@cindex{v-align}
@code{:v-align} @ref{shortdash} The type of vertical alignment to use within
a field (only applicable is @code{fixed-height-p} is T). Allowed values are
 @code{:top}, @code{:center}, or @code{:bottom} (default is @code{:top}).

@cindex{rank-margin}
@code{:rank-margin} @ref{shortdash} If non-NIL, then after this many
components, a new row will be started for horizontal lists, or a new
column for vertical lists (default is NIL).

@cindex{pixel-margin}
@code{:pixel-margin} @ref{shortdash} If non-NIL, then this acts as an
absolute position in pixels in the window; if adding the next component would
result in extending beyond this value, then a new row or column is started
(default is NIL).

@cindex{indent}
@code{:indent} @ref{shortdash} The amount to indent upon starting a new row/column (in pixels)
(default is 0).
@end vtable


@subsection Itemized Aggrelists
@node Itemized Aggrelists
@cindex{itemized aggrelists}
When all the components of an aggrelist are instances of the same prototype,
the aggrelist is referred to as an itemized aggrelist. This type of
aggrelist provides for the automatic generation of the components from a
specified item prototype. This feature is convenient when creating objects
such as menus or button panels, whose components are all similar.
(In a non-itemized aggrelist, the components may be of several types,
though they still take advantage of the layout mechanisms of
aggrelists, as in section @ref{non-itemized-sec}.)

To cause an aggrelist to generate its components from a prototype, the
@code{:item-prototype} and the @code{:items} slot may be set.

@subsection The :item-prototype Slot
@node The :item-prototype Slot
@cindex{item-prototype}
@anchor{the-i-p-slot}
The @code{:item-prototype} slot contains a description of the
prototype object that will be used to create the items. This slot is
analogous to the @code{:parts} slot for aggregadgets.
Garnet builds an object from the @code{:item-prototype} description and stores
this object in the @code{:item-prototype-object} slot of the aggrelist.
@b{Do not specify or set the} @code{:item-prototype-object} @b{slot}.

The prototype may be any Garnet object, including
aggregadgets, and may be given either as an existing schema name 
or as a quoted list holding an object definition, as in
@example
(:item-prototype `(,opal:rectangle (:width 100)
                                   (:height 50)))
@end example
The keyword @code{:modify}
@cindex{modify (keyword)}
may be used to indicate changes to an inherited item prototype, as in
@example
(:item-prototype `(:modify (:width 100)
                           (:height 50)))
@end example
The prototype for the @code{:item-prototype-object} in this case will be 
the @code{:item-prototype-object}
of the prototype of the aggrelist being specified.
This form would be used to modify the default in some way (see section
@ref{modify-item-sec}).

If no local @code{:item-prototype} slot is specified, the default is
to create an instance of the @code{:item-prototype-object} of the 
prototype aggrelist. If there is no @code{:item-prototype-object}, 
then this is not an itemized aggrelist (see section @ref{non-itemized-sec}).

@subsection The :items Slot
@node The :items Slot
@cindex{items}
The @code{:items} slot holds either a number or a list. If it is a
number @emph{n}, then @emph{n} identical instances of @code{:item-prototype-object}
will be created and added to the aggrelist. If it is a list of @emph{n}
elements, @emph{n} instances of @code{:item-prototype-object} will be
created and added to the aggrelist.

When @code{:items} is a list of elements, the designer must define a formula
in the @code{:item-prototype} that extracts the desired element from the list
for each component. In a menu, for example, the @code{:items} slot will
usually be a list of strings. Components should index their individual
strings from the @code{:items} list according to their @code{:rank}. The
following slot 
definition, to be included in the @code{:item-prototype}, would yield this
functionality:
@example
@code{(:string (o-formula (nth (gvl :rank) (gvl :parent :items))))}
@end example
This formula assigns the @emph{n}th string in the @code{:items} list to the
@emph{n}th component of the aggrelist.


The @code{:items} slot may also hold a nested list so that the components
can extract more than one value from it. For example, if the components
of a menu are characterized both by a label and a function (to be called
when the item is selected), the @code{:item} slot of the menu will be a list
of pairs '((@emph{label} @emph{function}) ...), and the components will
access their strings and associated functions with formulas such as:
@example
(:string (o-formula (first (nth (gvl :rank) (gvl :parent :items)))))
(:function (o-formula (second (nth (gvl :rank)
                                   (gvl :parent :items)))))
@end example

The list in the @code{:items} list may not be destructively modified. If you
need to modify the current value of the slot, you should create a new list
(e.g., with @code{list}) or use @code{copy-list} on the current value and modify
the resulting copied list.


@subsection Aggrelist Components
@node Aggrelist Components
@cindex{components of aggrelists}

When the value of @code{:items} changes, the number of components corresponding
to the change will be adjusted automatically during the next call to
@code{opal:update}. In most cases, users will never have to do anything
special to cause the components to become consistent with the @code{:items} list.

In some cases, an application might need to refer to the new components
(or the new positions of the components) @emph{before} calling @code{opal:update}.
It is possible to explicitly adjust the number of components in the aggrelist
after setting the @code{:items} list by calling:

@cindex{notice-items-changed}
@code{opal:Notice-Items-Changed} @emph{aggrelist}@ref{method}

where @emph{aggrelist} is the aggrelist whose @code{:items} slot has changed.
This function will additionally execute the layout function on the components,
so that they will have up-to-date @code{:left} and @code{:top} values.


@subsection Constants and Aggrelists
@node Constants and Aggrelists
@anchor{constants-in-aggrelists}
@cindex{constants in aggrelists}

@sp 1
@b{Constant :items and :components}

All aggrelists created with a constant @code{:items} slot have a constant
@code{:components} slot automatically. That is, after the
aggrelist has been created with all of its components according to its
@code{:items} list, the @code{:components} slot becomes constant by
default, and the items and components become unmodifiable (with the
two exceptions below). In addition, the @code{:head} and @code{:tail}
slots of the aggrelist, which point to the first and last component,
also become constant. By declaring these slots constant, Garnet is
able to automatically get rid of the greatest number of formulas possible.

If you really want to add another item to a constant aggrelist, you
could wrap a call to @code{add-item} in @code{with-constants-disabled},
which disables the protective constant mechanism, and is described
fully in the KR Manual. However, just as with aggregadgets (discussed
in section @ref{constants-and-aggregadgets}), this is discouraged
due to the likelihood that the dimension formulas of the aggrelist
will have already been evaluated and thrown away before the new item
is added, resulting in an incorrect bounding box for the aggrelist.

A better solution is to create a non-constant aggrelist to begin with.
If you plan to change the @code{:items} slot, then do not include it in the
@code{:constant} list. If you are using T in the constant list, be sure
to @code{:except} the @code{:items} slot.

@b{Constant :left and :top in Components}

The @code{:left} and @code{:top} slots of each component are set during the
layout of the aggrelist. If all of the slots controlling the layout are
constant in the aggrelist, then the @code{:left} and @code{:top} slots of the
components will be declared constant after they are set. The slots controlling
the layout are:

@table @code
:left

:top

:items

:direction

:v-spacing

:h-spacing

:indent

:v-align

:h-align

:fixed-width-p

:fixed-height-p

:fixed-width-size

:fixed-height-size

:rank-margin

:pixel-margin
@end table

Even if you do not supply customized values for these slots, you will still
need to declare them constant for the desired effect. They are all included
in the aggrelist's @code{:maybe-constant} list, so it is easy to declare them
all constant with a @code{:constant} value of T.

Since the aggrelist layout function sets the @code{:left} and @code{:top} slots
of each component, it is important @b{not} to declare these slots constant
yourself, unless you do so after the aggrelist has already been laid out.


@subsection A Simple Aggrelist Example
@node A Simple Aggrelist Example
@anchor{aggitem-expl-ref}
The following code is a short example of an itemized aggrelist
composed of text strings, and the picture of this aggrelist is in
figure @ref{aggitem-expl-pict}. Note that the @code{:left} and
@code{:top} slots of the @code{:item-prototype} have been left undefined.
The aggrelist will fill these slots with the appropriate values
automatically. 

@example
(create-instance 'MY-AGG opal:aggrelist
   (:left 10) (:top 10)
   (:direction :horizontal)
   (:items '("This" "is" "an" "example"))
   (:item-prototype
    `(,opal:text
      (:string ,(formula '(nth (gvl :rank) (gvl :parent :items)))))))
@end example

@float Figure, fig:ex29
@center @image{agg-list-item, 5.5in}
@caption{The picture of an itemized aggrelist.}
@anchor{aggitem-expl-pict}
@end float


@subsection An Aggrelist with an Interactor
@node An Aggrelist with an Interactor
As another example of an itemized aggrelist, consider the schema
FRAMED-TEXT-LIST defined in figure @ref{framed-text-list}. 
A picture of the FRAMED-TEXT-LIST aggrelist appears in figure
@ref{framed-text-list-pix}.

@float Figure, fig:ex2
@example
(create-instance 'FRAMED-TEXT-LIST opal:aggrelist
   (:left 0) (:top 0)
   (:items '("An aggrelist" "using an" "aggregate" 
	     "as an" "item-prototype"))
   (:item-prototype
    `(,opal:aggregadget
      (:parts
       ((:frame ,opal:rectangle
	   (:left ,(o-formula (gvl :parent :left)))
	   (:top ,(o-formula (gvl :parent :top)))
	   (:width ,(o-formula (+ (gvl :parent :text :width) 4)))
	   (:height ,(o-formula (+ (gvl :parent :text :height) 4))))
	(:text ,opal:text
	   (:left ,(o-formula (+ (gvl :parent :left) 2)))
	   (:top ,(o-formula (+ (gvl :parent :top) 2)))
	   (:cursor-index NIL)
	   (:string ,(o-formula
		      (nth (gvl :parent :rank)
		      (gvl :parent :parent :items)))))))
      (:interactors
       ((:text-inter ,inter:text-interactor
	   (:window ,(o-formula 
		      (gv-local :self :operates-on :window)))
	   (:feedback-obj NIL)
	   (:start-where ,(o-formula
	     (list :in (gvl :operates-on :text))))
	   (:abort-event #\control-\g)
	   (:stop-event (:leftdown #\RETURN))
	   (:final-function
	    ,#'(lambda (inter text event string x y)
		 (let ((elem (gv inter :operates-on)))
		   (change-item (gv elem :parent)
				string
				(gv elem :rank))))) ))))))
@end example
@caption{An aggrelist using an aggregadget as the @code{:item-prototype}.}
@anchor{framed-text-list}
@end float

@float Figure, fig:ex2
@center @image{framed-text-list-pix, 5.5in}
@caption{A picture of the FRAMED-TEXT-LIST aggrelist.}
@anchor{framed-text-list-pix}
@end float

This
aggrelist explicitly defines an aggregadget as the @code{:item-prototype}.
This aggregadget is similar to the FRAMED-TEXT schema defined
in figure @ref{framed-text}, but there is an additional @code{:final-function}
slot (see figure @ref{framed-text-list}). The purpose of the
@code{:final-function} is to keep the strings in the
@code{:items} list consistent with the strings in the components.

Interaction works as follows:  Each item is an aggregadget with
its own @code{text-interactor} behavior and @code{text} component.
The cursor text @code{:string} slot is constrained to the corresponding
element in the FRAMED-TEXT-LIST's @code{:items} slot, but this
is a one-way constraint.
The text interactor modifies the @code{:string} slot of the
cursor text using @code{s-value}, which leaves the formula in place,
but temporarily changes the slot value. At this point, the @code{:items}
slot and the cursor text @code{:string} slots are inconsistent, and
any change to @code{:items} would cause all @code{:string} slot formulas
to re-evaluate, possibly losing the string data set by the interactor.
To avoid this problem, the @code{:final-function} of the
text interactor directly sets the @code{:items}
slot using @code{change-item} to be consistent with the formula. This
initiates a re-evaluation, but because all values are consistent,
no data is lost. Furthermore, if the FRAMED-TEXT-LIST is saved
(see section @ref{write-gadget-sec}), the @code{:items} list will have
the current set of strings, and what is written will match what is
displayed.

Since the aggregadget defined here is similar to the
FRAMED-TEXT schema defined in figure @ref{framed-text}, the
@code{:item-prototype} slot definition could be replaced with
@example
(:item-prototype 
 `(,FRAMED-TEXT
   (:parts
    (:frame
     (:text :modify
	(:string ,(o-formula (nth (gvl :parent :rank)
				  (gvl :parent :parent :items)))))))
   (:interactors
    ((:text-inter :modify
		  (:final-function
		   ,#'(lambda (inter text event string x y)
			(let ((elem (gv inter :operates-on)))
			  (change-item (gv elem :parent)
				       string
				       (gv elem :rank))))))))))
@end example
provided that the definition for the FRAMED-TEXT schema preceded the
FRAMED-TEXT-LIST definition.

See section @ref{Menu-Aggrelist-Example} for an example of a menu
made with an itemized aggrelist.


@subsection An Aggrelist with a Part-Generating Function
@node An Aggrelist with a Part-Generating Function
@anchor{multi-parts-fn}
@cindex{Part-generating functions}
@cindex{Aggrelists}

Section @ref{creating-part-fn} discussed a feature of aggregadgets
that allows you to create parts of an aggregadget by specifying
part-generating functions. This feature of aggregadgets can be
especially useful when an aggregadget is the @code{:item-prototype} of
an aggrelist. While the same principles hold for aggregadgets whether
they are solitary or used in aggrelists, there is a special
consideration regarding the @code{:item-prototype-object} that warrants
further discussion.

A typical application of aggrelists that would involve a
part-generating function might specify a list of objects in its
@code{:items} list and generate components that have those objects as
parts. Such an application is pictured in figure @ref{esp-cards}.
The @code{:item-prototype} for this aggrelist is an aggregadget with a
part-generating function that determines its label. The definition of
the aggrelist, along with its part-generating function appears below.

@float Figure, fig:ex2
@center @image{esp-cards-pix, 5.5in}
@caption{An aggrelist that uses a part-generating function in its
:item-prototype}
@anchor{esp-cards}
@end float

@example
(defun Get-Label-In-Aggrelist (agg)
  (let ((alist (gv agg :parent)))
    (if alist  @emph{;; The item-prototype has no parent}
	(let* ((item (gv agg :item))
	       (new-label (if (schema-p item)
			      (if (gv item :parent)
				  @emph{;; The item has been used already --}
				  @emph{;; Use it as a prototype}
				  (create-instance NIL item)
				  @emph{;; Use the item itself}
				  item)
			      (create-instance NIL opal:text
				(:string item)
				(:font (opal:get-standard-font
					:sans-serif :bold :very-large))))))
	  (s-value new-label :left
		   (o-formula (+ (gvl :parent :left)
				 (round (- (gvl :parent :width)
					   (gvl :width)) 2))))
	  (s-value new-label :top
		   (o-formula (+ (gvl :parent :top)
				 (round (- (gvl :parent :height)
					   (gvl :height)) 2))))
	  new-label)
        ;; Give the item-prototype a bogus part
        (create-instance NIL opal:null-object))))
@end example

@example
(create-instance 'CIRCLE-LABEL opal:circle
  (:width 30) (:height 30)
  (:line-style NIL)
  (:filling-style opal:black-fill))

(create-instance 'SQUARE-LABEL opal:rectangle
  (:width 30) (:height 30)
  (:line-style NIL)
  (:filling-style opal:black-fill))
@end example

@example
(create-instance 'PLUS-LABEL opal:aggregadget
  (:width 30) (:height 30)
  (:parts
   `((:rect1 ,opal:rectangle
      (:left ,(o-formula (+ 10 (gvl :parent :left))))
      (:top ,(o-formula (gvl :parent :top)))
      (:width 10) (:height 30)
      (:line-style NIL) (:filling-style ,opal:black-fill))
     (:rect2 ,opal:rectangle
      (:left ,(o-formula (gvl :parent :left)))
      (:top ,(o-formula (+ 10 (gvl :parent :top))))
      (:width 30) (:height 10)
      (:line-style NIL) (:filling-style ,opal:black-fill)))))
@end example

@example
(create-instance 'STAR-LABEL opal:polyline
  (:width 30) (:height 30)
  (:point-list (o-formula
		(let* ((width (gvl :width))    (width/5 (round width 5))
		       (height (gvl :height))  (x1 (gvl :left))
		       (x2 (+ x1 width/5))     (x3 (+ x1 (round width 2)))
		       (x5 (+ x1 width))       (x4 (- x5 width/5))
		       (y1 (gvl :top))         (y2 (+ y1 (round height 3)))
		       (y3 (+ y1 height)))
		  (list x3 y1  x2 y3  x5 y2  x1 y2  x4 y3  x3 y1))))
  (:line-style opal:line-2))
@end example

@example
(create-instance 'ALIST opal:aggrelist
  (:left 10) (:top 20)
  (:items (list CIRCLE-LABEL SQUARE-LABEL "W" PLUS-LABEL STAR-LABEL))
  (:direction :horizontal)
  (:item-prototype
   `(,opal:aggregadget
     (:item ,(o-formula (nth (gvl :rank) (gvl :parent :items))))
     (:width 60) (:height 80)
     (:parts
      ((:frame ,opal:rectangle
	       (:left ,(o-formula (gvl :parent :left)))
	       (:top ,(o-formula (gvl :parent :top)))
	       (:width ,(o-formula (gvl :parent :width)))
	       (:height ,(o-formula (gvl :parent :height))))
       (:label ,#'Get-Label-In-Aggrelist))))))
@end example

The parts-generating function Get-Label-In-Aggrelist takes into
account the aggregadget that will be generated for the
@code{:item-prototype-object} in ALIST. In this example, we are
concerned about reserving our label prototypes solely for use in the
visible components. We could ignore this case, but then one of our prototypes
(like CIRCLE-LABEL) would become a component of the @code{:item-prototype-object}
which never appears in the window. (Additionally, problems could
arise if we destroyed the aggrelist along with its @code{:item-prototype-object}
and still expected to use the label as a prototype). Instead, we
specifically check if we are generating a part for the
@code{:item-prototype-object} and return a bogus object, saving our real
labels for the visible instances. 

The gadgets that use aggrelists (like the button panels and menus) all
use this feature, so you can have Garnet objects in the @code{:items}
list of a gadget. See the Gadgets manual for further details.


@subsection Non-Itemized Aggrelists
@node Non-Itemized Aggrelists
@anchor{non-itemized-sec}
@cindex{parts in aggrelists}
Non-itemized aggrelists may be specified with the @code{:parts} slot,
just as in aggregadgets, except aggrelists will automatically set the
@code{:left} and @code{:top} slots (among others). Figure @ref{parts-list-fig}
creates an aggrelist with three components, and a picture of this
aggrelist is shown in figure @ref{agglist-expl-ref}.

@float Figure, fig:ex2
@example
(create-instance 'MY-AGG opal:aggrelist 
  (:left 10) (:top 10)
  (:parts
   `((:obj1 ,opal:rectangle (:width 60) (:height 30))
     (:obj2 ,opal:oval (:width 60) (:height 30))
     (:obj3 ,opal:roundtangle (:width 60) (:height 30)))))
@end example
@caption{Example of an aggrelist with a parts slot.}
@anchor{parts-list-fig}
@end float

@float Figure, fig:ex2
@center @image{agg-list, 5.5in}
@caption{The picture of an aggrelist with three components.}
@anchor{agglist-expl-pict}
@end float

Instances of aggrelists are similar to instances of aggregadgets except
for the handling of default components and the @code{:item-prototype-object}
slot. Unlike aggregadgets, components that were generated by a
@code{:parts} list are not automatically inherited, so an aggrelist with
an empty @code{:parts} slot will @emph{not} inherit the parts of its
prototype. The only way to inherit these components is to 
name them in the prototype and to list each name as one of the instance's
@code{:parts}. For example, the following instance of MY-AGG (defined
above) will inherit the parts defined in the prototype:
@example
(create-instance 'MY-INST MY-AGG
  (:left 100)
  (:parts '(:obj1 :obj2 :obj3)))
@end example

Note that this syntax is consistent with the rules for customizing the
parts of aggregadgets described in section @ref{agg-insts}.

@cindex{constants in aggrelists}
Like aggregadgets, aggrelists created with a @code{:parts} slot
have constant @code{:components} by default. To cause the @code{:left} and
@code{:top} slots of the components to become constant after the aggrelist
is laid out, all of the layout parameters listed in section
@ref{constants-in-aggrelists} (including the @code{:items} slot) must be declared
constant.


@section Instances of Aggrelists
@node Instances of Aggrelists
@anchor{modify-item-sec}
When an instance is made of an itemized aggrelist,
components are automatically created as instances of the item prototype
object according to the local or inherited @code{:items} slot.

A consequence of these rules for making instances is that a default instance
of a non-itemized aggrelist will typically have no components, while a default
instance of an itemized aggrelist will typically have the same component
structure as its prototype due to the inherited @code{:items} slot.

@subsection Overriding the Item Prototype Object
@node Overriding the Item Prototype Object
For itemized aggrelists, an instance of the item prototype object is made
automatically and stored in the @code{:item-prototype-object} slot of the
instance aggrelist. The same syntax used in the @code{:parts} slot can be
used to override slots of the item prototype object. For example, figure
@ref{modify-item-fig} illustrates a variation on the text list in figure
@ref{framed-text-list}. Here, the @code{:frame} component is inherited and
modified to be gray and relatively wider than its prototype, a new
component, @code{:white-box} is added, and the @code{:text} component is
inherited and modified to be centered in the new larger surrounding
@code{:frame}. The text interactor is inherited without modification by
default. 

@emph{Note:} The @code{:items} list, if left unspecified, would be shared
with FRAMED-TEXT-LIST. It is generally a good idea to specify
the @code{:items} to avoid sharing.

@float Figure, fig:ex2
@center @image{boxed-text-list-pix, 5.5in}
@example

(create-instance 'BOXED-TEXT-LIST FRAMED-TEXT-LIST
   (:items '("An aggrelist" "using an" "inherited"
	     "but modified" "item-prototype"))
   (:left 120)
   (:top 0)
   (:item-prototype
    `(:modify
      (:parts
       ((:frame :modify
	   ; make the frame gray
	   (:filling-style ,opal:gray-fill)
	   ; make the frame wider
	   (:width ,(o-formula (+ (gvl-sibling :text :width) 16)))
	   ; make the frame taller
	   (:height ,(o-formula (+ (gvl-sibling :text :height) 16))))
	(:white-box ,opal:rectangle
	   (:filling-style ,opal:white-fill)
	   (:left ,(o-formula (+ (gvl :parent :left) 4)))
	   (:top ,(o-formula (+ (gvl :parent :top) 4)))
	   (:width ,(o-formula (+ (gvl-sibling :text :width) 8)))
	   (:height ,(o-formula (+ (gvl-sibling :text :height) 8))))
	(:text :modify  ; move the text to allow for the border
	   (:left ,(o-formula (+ (gvl :parent :left) 8)))
	   (:top ,(o-formula (+ (gvl :parent :top) 8)))))))))
@end example
@caption{An aggrelist that overrides parts of an inherited
@code{:item-prototype}. The prototype FRAMED-TEXT-LIST was defined in
figure @ref{framed-text-list}.}
@anchor{modify-item-fig}
@end float

@section Manipulating Gadgets Procedurally
@node Manipulating Gadgets Procedurally

A collection of functions is available to alter aggregadget and
aggrelist prototypes. When the prototype is altered, the changes
propagate down to instances of the prototype. Inheritance of slots
is a standard feature of KR, but inheritance of structural changes
is unique to aggregadgets and aggrelists and is implemented by
the functions and methods described in this chapter.

The philosophy behind structural inheritance is simply stated:
@emph{changing a prototype and then making an instance should be
equivalent to making an instance and then changing the prototype.}
In practice, this equivalence is difficult to achieve completely;
exceptions will be noted.

@subsection Copying Gadgets
@node Copying Gadgets
@cindex{copy-gadget}
@code{opal:Copy-Gadget} @emph{gadget}@ref{function}

This function copies an aggregadget, aggrelist, aggregate, or Opal graphical
object. The copy will have the same structure as the original. This is
different from (and more expensive than) creating an instance because 
nothing will be inherited from the original.

When copying an itemized aggrelist, components are not copied, because they
inherit from the local items-prototype-object. Instead, the @code{:items} 
slot and the item-prototype-object are copied, and new components are generated
accordingly.


@subsection Aggregadget Manipulation
@node Aggregadget Manipulation
@subsection Add-Component
@node Add-Component
@anchor{add-component-sec}

@sp 1
@cindex{add-component}
@code{opal:Add-Component} @emph{gadget} @emph{element} [[@code{:where}] @emph{position} [@emph{locator}]]@ref{method}
@sp 1

This function behaves just like the @code{add-component} method for
aggregates (see the @emph{Opal Reference
Manual}) except that, 
@itemize
if @emph{gadget} is a prototype, then instances of
@emph{element} are also added to instances of @emph{gadget}. This is recursive
so that instances of instances, etc., are also affected;

if @emph{element} has slot @code{:known-as} with value @emph{name}, then the
@emph{name} slot of @emph{gadget} is set to be @emph{element}. This creates
the standard link from @emph{gadget} to @emph{element} (see Section
@ref{known-as-sec}). Ordinarily, the @code{:known-as} slot of @emph{element}
should be set before calling @code{add-component}.
@end itemize

@emph{Note:}  Names of components and interactors
must be unique within their parent. For
example, there must not be two components named @code{:box}.

The
@emph{position} and @emph{locator} arguments can be used to adjust the
placement of @emph{graphical-object} with respect to the rest of the
components of @emph{gadget}.

@emph{position} can be any of these five values:
@table @code

@code{:front} 
@code{:back} 
@code{:behind} 
@code{:in-front} 
@code{:at}
or any of the following aliases:

@code{:tail} 
@code{:head} 
@code{:before} 
@code{:after} 
@code{:at}
@end table

The keyword @code{:where} is optional; for example, 
@example
(add-component aggrelist new-component :where :head)

(add-component aggrelist new-component :head)
@end example
are valid and equivalent calls to @code{add-component}.
The default value for @code{:where} is @code{:tail}
(add to the end of the list, which is graphically 
on top or at the front).

If @emph{position} is either @code{:before}/@code{:behind} or
@code{:after}/@code{:in-front} 
then the value of @emph{locator} should be a graphical object already in the
component list of the aggregate, in which case @emph{graphical-object} is placed
with respect to @emph{locator}.

If @emph{position} is @code{:at}, @emph{graphical-object} is placed at the
@emph{locator}th position in the component list, where
the zeroth position is the head of the list.

@emph{Note:} The @code{add-component} method will always add the component at
the most reasonable position if the specified location does not exist.
For example, if @code{add-component} is asked to add a component after another
one that does not exist, the new component will be added at the tail.

Instances of @emph{element} are created and added to instances of @emph{gadget}
using recursive calls to @code{add-component}. Since instances of
@emph{gadget} may not have the same structure as @emph{gadget}, 
it is not always obvious where to add a component.
In particular, a given @emph{locator} object will never exist
in instances, so a new instance @emph{locator} must be inferred from
the prototype @emph{locator} as follows:
@itemize
If the instance gadget has a component that is an instance of the
prototype @emph{locator}, then that component is the instance @emph{locator}.

Otherwise, if the instance gadget has a component with the same
@emph{name} (@code{:known-as}) as the prototype @emph{locator}, then that
component is the instance @emph{locator}.

Otherwise, a warning is printed, and there is no locator.
@end itemize

Given this procedure for finding an instance @emph{locator},
the insert point is determined as follows:
@itemize
The default position is @code{:front}.

If the @emph{position} is specified as @code{:front} or @code{:tail}, always insert
the component at the @code{:front}.

If the @emph{position} is specified as @code{:back} or @code{:head}, always insert
the component at the @code{:back}.

If the @emph{position} is @code{:behind} or @code{:before} @emph{locator}, and
an instance @emph{locator} is found, then insert @code{:behind} the instance
@emph{locator}, otherwise insert at the @code{:front} (the rationale here
is to err toward the front, making errors immediately visible).

If the @emph{position} is @code{:in-front} or @code{:after} @emph{locator}, and
an instance @emph{locator} is found, then insert @code{:in-front} of the instance
@emph{locator}, otherwise insert at the @code{:front}.

If the @emph{position} is @code{:at}, then @emph{locator} is an index. Use
the same index to insert an @emph{element} instance in each @emph{gadget}
instance.
@end itemize

@subsection Remove Component
@node Remove Component
@anchor{remove-component-sec}

@cindex{remove-component}
@code{opal:Remove-Component} @emph{gadget element} [ @emph{destroy?} ]@value{Method}

The @code{remove-component} method removes the
@emph{element} from @emph{gadget}. If @i{gadget} is connected to
a window, then @i{element} will be erased when the
window next has an update message sent to it.


Because aggregadgets allow
even the prototype of a component to be overridden in an instance,
determining what components to remove is not always straightforward.
First, @code{remove-component} removes all instances of @emph{component}
from their parents @emph{if} the parent @code{is-a-p} the @emph{gadget} argument.
(This avoids breaking up aggregates that use instances of components but
which are not instances of @emph{gadget}.)  Then, @code{remove-component}
removes all parts of instances of @emph{gadget}
that have a @code{:known-as} slot that matches that of
the @emph{component}. Components are removed with recursive calls to 
@code{remove-component} to affect the entire instance tree.

If @emph{destroy?} is not NIL (the default is NIL), then the removed objects
are destroyed.


@subsection Add-Interactor
@node Add-Interactor
Interactors can be added by calling

@cindex{add-interactor}
@code{opal:Add-Interactor} @emph{gadget} @emph{interactor}@ref{method}

where @emph{gadget} is an aggregadget or aggrelist. If the
interactor has a @code{:known-as} slot, then this becomes the
name of the interactor. The @code{:operates-on}
slot in the interactor is set to the gadget.

An instance of @emph{interactor} is added to each instance of
@emph{gadget} using a recursive call to @code{add-interactor}.

@emph{Note:} @emph{gadget} should not have an interactor or component
with the same name (@code{:known-as} slot) already. Otherwise,
an inconsistent gadget will result.


@subsection Remove-Interactor
@node Remove-Interactor
@cindex{remove-interactor}
@code{opal:Remove-Interactor} @emph{gadget} @emph{interactor} [@emph{destroy?}]@ref{method}

is used to remove an interactor. The interactor @code{:operates-on}
slot is destroyed, as is the link from @emph{gadget} to the @emph{interactor}
(determined by the value of the @emph{interactor}'s @code{:known-as} slot).
In addition, the @emph{interactor}'s @code{:active} slot is set to NIL.
The @emph{interactor} is also destroyed if the optional @emph{destroy?} 
parameter is not NIL.

Instances of @emph{interactor} that belong to instances of @emph{gadget}
(as determined by the @code{:operates-on} slot) are recursively
removed.
As with @code{remove-component},
interactors that have the same name as @emph{interactor}
are removed from instances of @emph{gadget}. (This will only have
an effect if, in an instance of @emph{gadget}, the default inherited
interactor has been overridden or replaced by a different one.)

@emph{Note:} Since a call to @code{remove-interactor} will deactivate
the interactor, be sure to set the @code{:active} slot appropriately if
the interactor is subsequently added to a gadget.

@subsection Take-Default-Component
@node Take-Default-Component
@cindex{take-default-component}
@code{opal:Take-Default-Component} @emph{gadget} @emph{name} [@emph{destroy?}]@ref{method}

This function removes a local component named by @emph{name}, e.g. @code{:box},
and replaces it with an instance of the corresponding component in
@emph{gadget}'s prototype. The removed component is destroyed if and only if
the optional @emph{destroy} argument is not NIL.

The placement of the new component is inherited as well as the component
itself. As with @code{add-component}, ``inherited position'' is not
well defined when the structure of @emph{gadget} does not match
the structure of its prototype. The algorithm for choosing the
position is as follows:
If the prototype component is the first one, then the instance
becomes the first component of @emph{gadget}. Otherwise, a locator (see
@code{add-component}) is found
in the prototype such that the locator is ``@code{:in-front}'' of the
prototype component. If this locator has an instance in @emph{gadget}, 
the instance is used as a locator in a
call to @code{add-component}, with the @emph{position} parameter being
@code{:in-front}. If the locator does not exist in @emph{gadget}, then the
@emph{position} used is @code{:front}, so at least any error should become
visibly apparent.

Changes are propagated to instances of @emph{gadget}.

@subsection Itemized Aggrelist Manipulation
@node Itemized Aggrelist Manipulation

@subsection Add-Item
@node Add-Item
@cindex{add-item}
@code{opal:Add-Item} @i{aggrelist} [@i{item}] [[@code{:where}] @emph{position} [@i{locator}] [@code{:key} @i{function-name}]] @ref{method}

If supplied, @emph{item} will be added to the @code{:items} slot of
@emph{aggrelist}, and a new instance of @code{:item-prototype-object} will
be added to the components of @emph{aggrelist}. The @code{add-item} method will
perform the necessary bookkeeping to maintain the appearance of the list.

It is an error (actually, a continuable break condition) to add an
item to an aggrelist whose @code{:items} slot is constant. To work around
this error, consult section @ref{constants-and-aggregadgets}.

The @emph{position}, @emph{locator} and @emph{function-name} arguments can be used to 
adjust the
placement of @emph{item} with respect to the rest of the items
of @emph{aggrelist}.

@emph{position} can be any of these five values:

@table @code

@code{:front} 
@code{:back} 
@code{:behind} 
@code{:in-front} 
@code{:at}
or any of the following aliases:

@code{:tail} 
@code{:head} 
@code{:before} 
@code{:after} 
@code{:at}
@end table
@emph{Note:} the graphically @emph{front} object is at the @emph{tail} of the
components list, etc.
If position is either @code{:before}/@code{:behind} or @code{:after}/@code{:in-front}
then the value of @emph{locator} should be an item already in the
@code{:items} slot of the aggrelist, in which case @emph{item} is placed
with respect to @emph{locator}.

For example, the following line will add a new item to the aggrelist
defined in section @ref{aggitem-expl-ref}:

@example
(opal:add-item MY-AGG "really" :after "is")
@end example

The string "really" will be added to @code{my-agg} with the resulting
aggrelist appearing as "This is really an example".

Furthermore, if the @code{:items} slot holds a nested list, @emph{:key
function-name} can be used to match @emph{locator} only with the result
of @emph{function-name} applied to each element of @code{:items}.
For example, if the @code{:items} slot of @code{an-aggrelist} is
@code{(("foo" 4) ("bar" 2) ("foo" 7))},
@example
(add-item an-aggrelist '("foobar" 3) :after "foo" :key #'car)
@end example
compare "foo" only to the @code{car}s of the list, and therefore will add
the new item as the second element of the list. The line
@example
(add-item an-aggrelist '("barfoo" 5) :before 7 :key #'cadr)
@end example
will add the new item just before the last one.

@emph{Note:} @code{add-item} will add the item at the most reasonable position
if the specified position does not exist. For example, if
@code{add-item} is asked to add a component after another 
one that does not exist, the new component will be added at the tail.

@subsection Remove-Item
@node Remove-Item
@cindex{remove-item}
@code{opal:Remove-Item} @i{aggrelist} [@i{item} [@code{:key} @i{function-name}]] @ref{Method}

The method @code{remove-item} removes @emph{item} from the @code{:items} list and
the @code{:components} list of @emph{aggrelist}.

It is an error (actually, a continuable break condition) to add an
item to an aggrelist whose @code{:items} slot is constant. To work around
this error, consult section @ref{constants-and-aggregadgets}.

If the @code{:items} slot holds a nested list, @emph{:key function-name}
can be used to specify to try to match @emph{item} only with the result
of @emph{function-name} applied to each element of @code{:items}.
For example, if the @code{:items} slot of @code{an-aggrelist} is
@code{(("foo" 4) ("bar" 2) ("foo" 7))},
@example
(remove-item AN-AGGRELIST "foo" :key #'car)
@end example
removes the first item, while
@example
(remove-item AN-AGGRELIST '("foo" 7))
@end example
removes the last one.

@subsection Remove-Nth-Item
@node Remove-Nth-Item
@cindex{remove-nth-item}

@code{opal:Remove-Nth-Item} @emph{aggrelist} @emph{n}@ref{method}

To remove an item by position rather than by content, use
@code{remove-nth-item}. The @emph{n}@+(th) item is removed from
the @code{:items} slot of @emph{aggrelist}, and the component corresponding
to that item will be removed during the next call to @code{opal:update}.

It is an error to add an
item to an aggrelist whose @code{:items} slot is constant. To work around
this error, consult section @ref{constants-and-aggregadgets}.


@subsection Change-Item
@node Change-Item
@cindex{change-item}

To change just one item in the @code{:items} list, call

@cindex{change-item}
@code{opal:Change-Item} @emph{aggrelist item n}@ref{method}

where @emph{aggrelist} is the aggrelist to be modified, @emph{item} is a
new value for the @code{:items} list, and @emph{n} is the index of the 
item to be changed (the index of the first item is zero).

This function is potentially more efficient than calling @code{add-item} and
@code{remove-item}, because it ensures that the component corresponding to the
changed item will be reused if possible, instead of destroying and reallocating
a new component.


@subsection Replace-Item-Prototype-Object
@node Replace-Item-Prototype-Object
@cindex{replace-item-prototype-object}

@code{opal:Replace-Item-Prototype-Object} @emph{aggrelist} @emph{item-proto}@ref{method}

This function is used to replace the @code{:item-prototype-object} slot of
an itemized aggrelist. Any aggrelists which inherit
the slot from this one will also be affected. The components of affected
aggrelists are replaced with instances of the new
@code{:item-prototype-object}.

For example, suppose an application uses a number of instances
of  radio buttons,
an aggrelist whose item prototype object
determines the appearance of a single button. By calling
@code{replace-item-prototype-object} on the radio buttons prototype,
all button throughout the application will change to reflect the
new style.

@subsection Ordinary Aggrelist Manipulation
@node Ordinary Aggrelist Manipulation
@anchor{aggrelist-manipulation-sec}

@subsection Add-Component
@node Add-Component
@cindex{add-component}

The @code{add-component}, defined in section @ref{add-component-sec} can also
be used to add components to an aggrelist. The system automatically adjusts
the appearance of the aggrelist to accommodate the changes in the list of
components.

In addition to adding @emph{graphical-object} to @emph{aggrelist},
@code{add-component} will add some slots to @emph{graphical-object}, or modify
existing slots. The slots created or modified by @code{add-component} are:

@vtable @code
@code{:left, :top} @ref{shortdash} Unless the @code{:direction} slot of
@emph{aggrelist} is NIL, the system will set these slots with integers that
arrange @emph{graphical-object} neatly in the layout of the aggrelist components.

@code{:rank} @ref{shortdash} This slot is set with a number that indicates
the position of this component in the list (the head has rank 0). If this
component is not visible, then this value has no meaning.

@code{:prev} @ref{shortdash} This contains the previous component in the list,
regardless of what is visible.

@code{:next} @ref{shortdash} This contains the next component in the list,
regardless of what is visible.

@end vtable

@emph{Note:} @code{add-components} (plural) can be used to add several
components to an aggrelist.

An alternative implementation of figure @ref{parts-list-fig} is shown in
figure @ref{agglist-expl-ref}. In each component of the aggrelist, the
@code{:left} and @code{:top} slots have been left undefined. The aggrelist will
fill these slots with the appropriate values automatically.

@float Figure, fig:ex2
@example
(create-instance 'MY-AGG opal:aggrelist (:top 10) (:left 10))
(create-instance 'MY-RECT opal:rectangle
   (:width 100) (:height 30))
(create-instance 'MY-OVAL opal:oval
   (:width 100) (:height 30))
(create-instance 'MY-ROUND opal:roundtangle
   (:width 100) (:height 30))
(add-components MY-AGG MY-RECT MY-OVAL MY-ROUND)
 
@end example
@caption{Example of an aggrelist built using add-component.}
@anchor{agglist-expl-ref}
@end float


@subsection Remove-Component
@node Remove-Component

See section @ref{remove-component-sec} for a description of this method.

@cindex{null-object}
@b{Useful hint:} It is possible to make components of an aggrelist 
temporarily disappear by simply
setting their @code{:visible} slot to @code{nil} --- the list will adjust itself so
that there is no gap where the item once was. If a gap is desired, then an
@code{opal:null-object} may be inserted into the list --- this is an
@code{opal:view-object} that has its @code{:visible} slot set to T, but has no
draw method.


@subsection Remove-Nth-Component
@node Remove-Nth-Component
@cindex{remove-nth-component}

@sp 1
@code{opal:Remove-Nth-Component} @emph{aggrelist n}@ref{method}

The @emph{n}@+(th) component of @emph{aggrelist} is removed by
invoking @code{remove-local-component}. Instances of @emph{aggrelist}
are @emph{not} affected.


@subsection Local Modification
@node Local Modification
A number of functions exist to modify gadgets without changing their
instances. Their behavior is exactly like the corresponding
recursive version described earlier, except that changes are
not propagated to instances.

@cindex{add-local-component}
@code{opal:Add-Local-Component} @emph{gadget} @emph{element} [[@code{:where}] @emph{position} [@emph{locator}]]@ref{method}

@cindex{remove-local-component}
@code{opal:Remove-Local-Component} @emph{gadget element} [ @emph{destroy?} ]@value{Method}

@cindex{add-local-interactor}
@code{opal:Add-Local-Interactor} @emph{gadget} @emph{interactor}@ref{method}

@cindex{remove-local-interactor}
@code{opal:Remove-Local-Interactor} @emph{gadget} @emph{interactor} [@emph{destroy?}]@ref{method}

@cindex{add-local-item}
@code{opal:Add-Local-Item} @i{aggrelist} [@i{item}] [[@code{:where}] @emph{position} [@i{locator}] [@code{:key} @i{function-name}]] @ref{method}

@cindex{remove-local-item}
@code{opal:Remove-Local-Item} @i{aggrelist} [@i{item} [@code{:key} @i{function-name}]] @ref{Method}


@section Reading and Writing Aggregadgets and Aggrelists
@node Reading and Writing Aggregadgets and Aggrelists
@cindex{write-gadget}
@cindex{saving aggregadgets}
An aggregadget or aggrelist may be written to a file. This creates
a compilable lisp program that can be reloaded to recreate the object
that was saved. To save an aggregadget, use the @code{opal:write-gadget}
function:

@subsection Write-Gadget
@node Write-Gadget
@anchor{write-gadget-sec}

@sp 1
@cindex{write-gadget}
@code{opal:Write-Gadget} @emph{gadget} @emph{file-name} &optional @emph{initialize?}@ref{function}

where @emph{gadget} is a graphical object, an
aggregadget or an aggrelist (or a list of these), and @emph{file-name}
is the file name (a string) to be written, or @code{t} to write
to @code{*standard-output*}. If several calls are made to @code{write-gadget}
to output a sequence of
gadgets to the same stream, set the @emph{initialize?} flag
to NIL after the first call. The default value of @emph{initialize?} is T.

If the gadget has any references to
gadgets that are not part of the standard set of Opal objects or
Interactors, then a warning is printed. @emph{Note:} @emph{gadget}
must not be a symbol or list of symbols:
@example
(write-gadget (list BUTTON SLIDER) "misc.lisp")  @!@emph{; RIGHT!}
(write-gadget '(BUTTON SLIDER) "misc.lisp")@/@emph{; WRONG!}
@end example

Slots that are ordinarily created automatically are not written
by @code{write-gadget}. For example, the @code{:is-a-inv} slot 
(maintained by KR) and the @code{:update-slots-values} slot (maintained
by Opal) are not written. The slots to ignore are found in the
@cindex{do-not-dump-slots}
@code{:do-not-dump-slots} slot, which is normally inherited. In some
cases, it may be desirable to suppress the output of certain slots,
e.g. bookkeeping information, and this can be done by setting
@code{:do-not-dump-slots} as follows:
@example
(s-value @emph{my-proto}
         :do-not-dump-slots
         (append @emph{list-of-slots} (gv @emph{my-proto} :do-not-dump-slots)))
@end example
Do not destructively modify @code{:do-not-dump-slots}!  Putting
the slot name @code{:do-not-dump-slots} on the list will prevent the
@code{:do-not-dump-slots} slot from being written. This is probably
not a good idea, since if the object is written and reloaded, the
local @code{:do-not-dump-slots} information will be lost.

@subsection Avoiding Deeply Nested Parts Slots
@node Avoiding Deeply Nested Parts Slots
One would expect an instance of a standard gadget (see the @emph{Garnet
Gadgets Reference Manual}) to have a very concise output representation;
however, once the instance is manipulated, various slots are set
by interactors. Often, these slots are deeply nested in the gadget
structure, and the output has correspondingly deeply nested @code{:parts}
slots. This is a consequence of the fact that Garnet maintains
little separation 
between the gadget definition and local state information. 

One solution is to carefully install slot names on the
@code{:do-not-dump-slots} slot to suppress the output of slots for
which the default inherited value is acceptable. Another, more
drastic, solution is to set the @cindex{do-not-dump-objects}
@code{:do-not-dump-objects} slot
in selected objects. This slot may have one of three values:
@itemize
NIL @ref{shortdash} The default; write out all slots and parts
that differ from the prototype.

@code{:me}
@cindex{me} @ref{shortdash} Assume that all components and 
interactors are inherited without modification, so there is
no need to write @code{:parts}, @code{:interactors}, or @code{:item-prototype}
slots at this level. Other slots, such as @code{:left} and @code{:top}
should be written.

@code{:children}
@cindex{children} 
@ref{shortdash} Write out @code{:parts}, @code{:interactors}
and @code{:item-prototype} slots, but do not allow further nesting. This
is equivalent to setting the @code{:do-not-dump-objects} slot of each
component, interactor, and the item-prototype to @code{:me}.
@end itemize

@subsection More Details
@node More Details
The @code{write-gadget}
function makes no attempt to write out objects that are needed
as prototypes or that are referenced by formulas.
It is the user's responsibility to make sure these objects are loaded
before loading a gadget; otherwise, an ``unbound symbol'' error is
likely to occur.
If the @emph{gadget} argument is a list, then each aggregadget or aggrelist
of the list is written in sequence to the file.

To load a gadget after it has been written, the standard lisp loader
(@code{load}) should be used.

When an aggregadget is written that uses a function to create parts
(see section @ref{run-time}), the created parts are written explicitly
and in full, as opposed to simply writing out the original @code{:parts}
slot. This guarantees that any modifications to the aggregadget after
it was created will be correctly written.

@cindex{verbose-write-gadget}
@cindex{*verbose-write-gadget*}
@code{opal:*verbose-write-gadget*}@ref{variable}

If @code{*verbose-write-gadget*} is non-NIL,
objects will be printed to @code{*error-output*}
as they are visited by @code{write-gadget}. Indentation indicates the
level of the object in the aggregate hierarchy. @emph{Note:} objects will
be printed even if, due to inheritance, nothing needs to be written.

@subsection Writing to Streams
@node Writing to Streams
The @code{write-gadget} function can be used as is for simple applications,
but it is sometimes desirable to write a header to a file and perhaps
embed code written by @code{write-gadget} into a function definition.
This is done by temporarily re-binding @code{*standard-output*} as in the
following example:
@example
(with-open-file (*standard-output* "my-file.lisp"
		 :direction :output :if-exists :supersede)
    @emph{;; write header to standard output:}
    (format T "... file header info goes here ...")
    @emph{;; write a gadget:}
    (write-gadget my-gadget t)
    @emph{;; if there are more gadgets, call with initialize? set to NIL:}
    (write-gadget another-gadget T NIL))
@end example

@subsection References to External Objects
@node References to External Objects
Gadgets may contain references to ``external objects'', that is,
objects that are not part of the gadget. 
When an external object is written,
A warning is ordinarily
printed  to notify the user that
the object must be present when the gadget code is loaded.

@cindex{standard-names}
@cindex{*standard-names*}
@code{opal:*standard-names*}@ref{variable}

Many objects, including standard Opal objects, standard Interactors, and 
objects in the Garnet Gadget library, are considered part of the Garnet
environment, so no warning is written for these references. The list
@code{*standard-names*} tells @code{write-gadget} what object symbols to assume
will be defined when the gadget is loaded. This list can be extended
with new new names before calling @code{write-gadget}.

@cindex{defined-names}
@cindex{*defined-names*}
@code{opal:*defined-names*}@ref{variable}

The global variable @code{*defined-names*} is initialized to 
@code{*standard-names*}
when you call @code{write-gadget}. As gadgets are written, their names are
pushed onto @code{*defined-names*}, so if a list of gadgets is written
and the second references the first, no warning will be printed.
@code{*defined-names*} (not @code{*standard-names*}) is what @code{write-gadgets}
actually searches to see if a name is defined. 

@cindex{required-names}
@cindex{*required-names*}
@code{opal:*required-names*}@ref{variable}

The variable @code{*required-names*} 
is initialized to NIL when you call @code{write-gadget}.
Whenever a name is written that is not on @code{*defined-names*}, it
is pushed onto @code{*required-names*} and a warning is printed.
Inspecting the value of @code{*required-names*} after calling
@code{write-gadget} can give the caller information about what
additional gadgets should be saved.

The initialization of @code{*defined-names*} and @code{*required-names*}
is suppressed when the @emph{initialize?} argument to @code{write-gadget}
is set to NIL.


@subsection References to Graphic Qualities
@node References to Graphic Qualities

A reference to an @code{opal:graphic-quality} object is handled as a 
special case. Graphic qualities include @code{opal:filling-style},
@code{opal:line-style}, @code{opal:color}, @code{opal:font}, and 
@code{opal:font-from-file}. Although these are objects, they are
treated more like record structures throughout the Garnet system.
For example, changing a slot in a graphic quality will not
automatically cause an update; only replacing a graphic quality
with a new one (or faking it with a call to @code{kr:mark-as-changed})
will cause the update.

Because of the way graphic qualities are used, it is best to
think of graphic qualities as values rather than shared objects.
Consequently, @code{write-gadget} writes out graphic qualities
by calling @code{create-instance} to construct an equivalent object
rather than by writing an external reference that is likely to be
undefined when the file is loaded. 

For example, here is a rectangle with a special color, and the output
generated by @code{write-gadget}:
@example
(create-instance 'MY-RED RED
   (:red 0.5))

(create-instance 'MY-RECT RECTANGLE
   (:color my-red))

* (write-gadget MY-RECT T)
(create-instance 'MY-RECT RECTANGLE
   (:COLOR (create-instance NIL COLOR
              (:BLUE 0.0)
	      (:GREEN 0.0)
	      (:RED 0.5))))
@end example


@subsection Saving References From Within Formulas
@node Saving References From Within Formulas
Writing direct references from within @code{o-formula}'s 
to other objects is not possible (in a lisp implementation-independent
way) because @code{o-formula} builds a closure, and bindings within the
closure are not externally visible. For example, in
@example
(let ((thermometer THERMOMETER-1))
  (o-formula (gv thermometer :temperature)))
@end example
the variable @emph{thermometer} is bound inside the @code{let} and is not
accessible to any routine that would write the formula. Even though
the expression @code{(gv thermometer :temperature)} is saved
in the formula in the current KR implementation, this does not
reveal the binding needed to reconstruct the formula.

Fortunately, 
aggregadgets and aggrelists rarely make direct references to objects.
Typically, references to objects take the form of paths in formulas,
for example, @code{(gvl :parent :box :left)}. However, there may be
occasions when a direct reference is required, for example, when an
aggregadget depends upon the value of some separate application object.

There are several ways to avoid problems associated with direct references
from formulas:
@itemize
Use @code{formula} instead of @code{o-formula}. The @code{formula} function
interprets its expression, so expressions with embedded references
can be constructed at run-time. For example, the thermometer example
could be written as:
@example
(formula `(gv ',thermometer :temperature))
@end example
embedding the actual reference directly into the expression. This
expression can be written and read back in without problems.
However, since formula expressions are interpreted, re-evaluation of the 
formula will be much slower than the corresponding o-formula.

Put the object reference into a slot, avoiding direct references altogether.
For example, to create a dependency on the @code{:temperature} slot of object 
THERMOMETER-1, set the @code{:thermometer} slot of the gadget to
THERMOMETER-1, and reference the slot from the formula:
@example
(o-formula (gvl :thermometer :temperature))
@end example
Since the reference to THERMOMETER-1 is now a slot value rather
than a hidden binding in a closure, it can be written and read back in
without problems. The only performance penalty of this approach
will be the extra slot access, which should not add much overhead.
There is, however, the added problem of choosing slot names so as not
to interfere with other formulas.
@end itemize



@verbatim
Use an @code{e-formula}, described below. This provides the functionality
and speed of @code{o-formula} as well as the ability to save to files
at the expense of a little more work for the programmer and some 
extra function definitions.

@subsection The e-formula function
@node The e-formula function
@cindex{e-formula}
@code{e-formula} @emph{expression}@ref{function}

The argument to @code{e-formula} is an expression that, when evaluated,
will return a formula. The expression is retained so that the 
original @code{e-formula} expression can be reconstructed when the
formula is written to a file. Returning once again to the thermometer
example, here is how the problem would be solved using @code{e-formula}:
@example
(defun temperature-formula (thermometer)
   (o-formula (gv thermometer :temperature)))

(create-instance 'DISPLAY-1 DISPLAY
   (:value (e-formula `(temperature-formula ',THERMOMETER-1)))
@end example
The first expression defines
an auxiliary (compiled) function @code{temperature-formula}.
The second expression creates an instance of the prototype
@code{display} (not implemented here) whose @code{:value} slot holds
the desired formula.

When the @code{e-formula} expression is evaluated, the argument,
@example
(temperature-formula '#k<THERMOMETER-1>)
@end example
is evaluated. The @code{temperature-formula} function in turn produces
an @code{o-formula} in which the reference to @code{#k<thermometer-1>} is
captured by a compiled closure. Because the @code{o-formula} is based
on a compiled closure, it will evaluate quickly. Note that the
Lisp interpreter is invoked only to @emph{create} the formula, not to evaluate
it.

When @code{display-1} is written to a file, @code{write-gadget} will
write
@example
(e-formula `(temperature-formula ',THERMOMETER-1))
@end example
which is the same expression used to create the original formula.
A warning will be issued when the THERMOMETER-1 is written:
@example
Warning: non-standard schema written as THERMOMETER-1
@end example
to warn that a direct reference to THERMOMETER-1 was written
and must be defined when the schema is reloaded.
In order to reload this formula, the function @code{temperature-formula}
must be also be defined.
@end verbatim



@section More Examples
@node More Examples

@subsection A Customizable Check-Box
@node A Customizable Check-Box
@anchor{Custom-check-box1}

Figure @ref{example-1} shows the definition of a 
check-box whose position and size can be determined by the
programmer when it is used as a prototype object.

The @code{:parts} slot
defines the @code{:box} object as an instance of @code{opal:rectangle} with
coordinates dependent on the parent aggregadget. Similarly, the @code{:mark}
object is an @code{opal:aggregadget} itself, and its components are dependent
on slots in the top-level aggregadget.

Two instances of CHECK-BOX are created --- the first one using the
default values for the coordinates and the second one using both default
and custom coordinates. Both are pictured in figure
@ref{example-1-pic}.

@float Figure, fig:ex2
@example
(create-instance 'CHECK-BOX opal:aggregadget
   (:left 20)
   (:top 20)
   (:width 50)
   (:height 50)
   (:parts
    `((:box ,opal:rectangle
         (:left ,(o-formula (gvl :parent :left)))
         (:top ,(o-formula (gvl :parent :top)))
         (:width ,(o-formula (gvl :parent :width)))
         (:height ,(o-formula (gvl :parent :height))))
      (:mark ,opal:aggregadget
         (:parts
          ((:left-line ,opal:line
              (:x1 ,(o-formula (+ (gvl :parent :parent :left)
                     (floor (gvl :parent :parent :width) 10))))
              (:y1 ,(o-formula (+ (gvl :parent :parent :top)
                     (floor (gvl :parent :parent :height) 2))))
              (:x2 ,(o-formula (+ (gvl :parent :parent :left)
                     (floor (gvl :parent :parent :width) 2))))
              (:y2 ,(o-formula (+ (gvl :parent :parent :top)
                     (floor (* (gvl :parent :parent :height) 9)
			    10))))
              (:line-style ,opal:line-2))
          (:right-line ,opal:line
              (:x1 ,(o-formula 
		     (opal:gvl-sibling :left-line :x2)))
              (:y1 ,(o-formula
		     (opal:gvl-sibling :left-line :y2)))
              (:x2 ,(o-formula (+ (gvl :parent :parent :left)
                     (floor (* (gvl :parent :parent :width) 9)
			    10))))
              (:y2 ,(o-formula (+ (gvl :parent :parent :top)
                     (floor (gvl :parent :parent :height) 10))))
              (:line-style ,opal:line-2))))))))

(create-instance 'CB1 CHECK-BOX)

(create-instance 'CB2 CHECK-BOX (:left 90) (:width 100) (:height 60))
@end example
@caption{The definition of a customizable check-box.}
@anchor{example-1}
@end float

@float Figure, fig:ex2
@center @image{agg-custom-cb, 5.5in}
@caption{Instances of the customizable check-box.}
@anchor{example-1-pic}
@end float


@subsection Hierarchical Implementation of a Customizable Check-Box
@node Hierarchical Implementation of a Customizable Check-Box
@anchor{custom-check-box2}

Figure @ref{example-2} shows the definition of a customizable
check-box as in figure @ref{example-1}. However, this second CHECK-BOX
definition exploits the hierarchical structure of the check box to
modularize the definition of the schema. The modular style allows for
the reuse of previously defined code --- the @code{check-mark} schema
may now be used for other applications as well.

@float Figure, fig:ex2
@example
(create-instance 'CHECK-MARK opal:aggregadget
  (:parts
   `((:left-line ,opal:line
      (:x1 ,(o-formula (+ (gvl :parent :parent :left)
			  (floor (gvl :parent :parent :width) 10))))
      (:y1 ,(o-formula (+ (gvl :parent :parent :top)
			  (floor (gvl :parent :parent :height) 2))))
      (:x2 ,(o-formula (+ (gvl :parent :parent :left)
			  (floor (gvl :parent :parent :width) 2))))
      (:y2 ,(o-formula (+ (gvl :parent :parent :top)
			  (floor (* (gvl :parent :parent :height) 9) 10))))
      (:line-style ,opal:line-2))
     (:right-line ,opal:line
      (:x1 ,(o-formula (opal:gvl-sibling :left-line :x2)))
      (:y1 ,(o-formula (opal:gvl-sibling :left-line :y2)))
      (:x2 ,(o-formula (+ (gvl :parent :parent :left)
			  (floor (* (gvl :parent :parent :width) 9) 10))))
      (:y2 ,(o-formula (+ (gvl :parent :parent :top)
			  (floor (gvl :parent :parent :height) 10))))
      (:line-style ,opal:line-2)))))

(create-instance 'CHECK-BOX opal:aggregadget
  (:left 20)
  (:top 20)
  (:width 50)
  (:height 50)
  (:parts
   `((:box ,opal:rectangle
      (:left ,(o-formula (gvl :parent :left)))
      (:top ,(o-formula (gvl :parent :top)))
      (:width ,(o-formula (gvl :parent :width)))
      (:height ,(o-formula (gvl :parent :height))))
     (:mark ,check-mark))))
@end example
@caption{A hierarchical implementation of a customizable check-box.}
@anchor{example-2}
@end float


@subsection Menu Aggregadget with built-in interactor, using Aggrelists
@node Menu Aggregadget with built-in interactor, using Aggrelists
@anchor{Menu-Aggrelist-Example}

The figure @ref{menu-aggrelist-ref} shows how to create a menu aggregadget,
by using itemized aggrelist to create the items of the menu.
This example also shows how to attach an interactor to such an object.
The menu is made of four parts: a frame, a shadow, a feedback
and an items-agg, which is an aggrelist containing the items
of the menu. Each item is an instance of the prototype @code{menu-item}.
The items are created according to the labels and notify-functions given in
the @code{:items} slot of the menu. The menu also contains a built-in interactor which, when
activated, will call the functions associated to the selected item.

The figure @ref{menu-aggrelist2-ref} shows how to create an instance
of the menu. A picture of these menus (the prototype and its instance)
is shown in figure @ref{menu-aggitem-pict}.

@float Figure, fig:ex2
@center @image{agg-list-item-menu, 5.5in}
@caption{The two menus (prototype and instance) made with itemized aggrelist.}
@anchor{menu-aggitem-pict}
@end float

@float Figure, fig:ex2
@example
(defun my-cut () (format T "~%Function CUT called~%"))
(defun my-copy () (format T "~%Function COPY called~%"))
(defun my-paste () (format T "~%Function PASTE called~%"))
(defun my-undo () (format T "~%Function UNDO called~%"))

(create-instance 'MENU-ITEM opal:text
   (:string (o-formula (car (nth (gvl :rank) (gvl :parent :items)))))
   (:action (o-formula (cadr (nth (gvl :rank)
				  (gvl :parent :items))))))

(create-instance 'MENU opal:aggregadget
   (:left 20) (:top 20) 
   (:items '(("Cut" (my-cut)) ("Copy" (my-copy))
             ("Paste" (my-paste)) ("Undo" (my-undo))))
   (:parts 
    `((:shadow ,opal:rectangle
	(:filling-style ,opal:gray-fill)
	(:left ,(o-formula (+ (gvl :parent :frame :left) 8)))
	(:top ,(o-formula (+ (gvl :parent :frame :top) 8)))
	(:width ,(o-formula (gvl :parent :frame :width)))
	(:height ,(o-formula (gvl :parent :frame :height))))
      (:frame ,opal:rectangle
	(:filling-style ,opal:white-fill)
	(:left ,(o-formula (gvl :parent :left)))
	(:top ,(o-formula (gvl :parent :top)))
	(:width ,(o-formula (+ (gvl :parent :items-agg :width) 8)))
	(:height ,(o-formula (+ (gvl :parent :items-agg :height) 8))))
      (:feedback ,opal:rectangle
	(:left ,(o-formula (- (gvl :obj-over :left) 2)))
	(:top ,(o-formula (- (gvl :obj-over :top) 2)))
	(:width ,(o-formula (+ (gvl :obj-over :width) 4)))
	(:height ,(o-formula (+ (gvl :obj-over :height) 4)))
	(:visible ,(o-formula (gvl :obj-over)))
	(:draw-function :xor))
      (:items-agg ,opal:aggrelist
	(:fixed-width-p T)
	(:h-align :center)
	(:left ,(o-formula (+ (gvl :parent :left) 4)))
	(:top ,(o-formula (+ (gvl :parent :top) 4)))
	(:items ,(o-formula (gvl :parent :items)))
	(:item-prototype ,menu-item))))
   (:interactors
    `((:press ,inter:menu-interactor
	(:window ,(o-formula (gv-local :self :operates-on :window)))
	(:start-where ,(o-formula (list :element-of
			(gvl :operates-on :items-agg))))
	(:feedback-obj ,(o-formula (gvl :operates-on :feedback)))
	(:final-function 
	  ,#'(lambda (interactor final-obj-over)
		(eval (gv final-obj-over :action))))))))
@end example
@caption{Definition of a menu with built-in interactor and itemized aggrelist.}
@anchor{menu-aggrelist-ref}
@end float

@float Figure, fig:ex2
@example
(defun my-read () (format T "~%Function READ called~%"))
(defun my-save () (format T "~%Function SAVE called~%"))
(defun my-cancel () (format T "~%Function CANCEL called~%"))

(create-instance 'MY-MENU MENU
   (:left 100) (:top 20) 
   (:items '(("Read" (my-read)) ("Save" (my-save))
             ("Cancel" (my-cancel)))))
@end example
@caption{Creation of an instance of MENU.}
@anchor{menu-aggrelist2-ref}
@end float


@section Aggregraphs
@node Aggregraphs

@anchor{aggregraphs}
@cindex{aggregraphs}

The purpose of Aggregraphs is to allow the easy
creation and manipulation of graph objects, analogous to the
creation and manipulation of lists by Aggrelists. In addition to the standard
@code{aggregraph}, Opal provides the @code{scalable-aggregraph} which will fit
inside dimensions supplied by the programmer, and the
@code{scalable-aggregraph-image} which changes appearance in response to
changes in the original graph.


@section Using Aggregraphs
@node Using Aggregraphs
@cindex{graph-node}
@cindex{source-node}

In order to generate an aggregraph from a source graph, the source graph must
be described by defining its roots (a graph may have more than one root) and
a function to generate children from parent nodes. When the
aggregraph is initialized, the generating function is first called on the
root(s), then on the children of the roots, and so on. For each
@emph{source-node} in the original graph, a new @emph{graph-node} is created and
added to the aggregraph. Graphical links are also created which connect the
graph-nodes appropriately. The layout function (which can be specified by the
user) is then called to layout the graph in a pleasing manner.
The resulting aggregraph instance can then be displayed and manipulated
like any other Garnet object.

Although most
programmers will be satisfied with the graphs generated by the default layout
function, section @ref{layout-graph} contains a discussion of how to
customize the function used to compute the locations for the nodes in the
graph.

See the file @code{demo-graph.lisp} for a complete interface that uses many
features of aggregraphs.

@subsection Accessing Aggregraphs
@node Accessing Aggregraphs
@cindex{garnet-aggregraphs-loader}

The aggregraph files are @b{not} automatically loaded when the file
@code{garnet-loader.lisp} is used to load Garnet. There is a separate file
called @code{aggregraphs-loader.lisp} that is used to load all the aggregraphs
files. This file is loaded when the line
@code{(load Garnet-Aggregraphs-Loader)}
is executed after Garnet has been loaded with @code{garnet-loader.lisp}.

Aggregraphs reside in the @code{Opal} package. We recommend that programmers
explicitly reference the @code{Opal} package when creating instances of
aggregraphs, as in @code{opal:aggregraph}. However, the package name may be
dropped if the line
@code{(use-package 'opal)}
is executed before referring to any object in that package.


@subsection Overview
@node Overview
@cindex{children-function}
@cindex{info-function}
@cindex{source-roots}

In general, programmers will be able to ignore most of the aggregraph slots
described in the following sections, since they are used to customize the
layout function of the aggregraph. However, three slots must be set before
before any aggregraph can be initialized:

@itemize
@code{:children-function} -- This slot should contain a function that generates
a list of child nodes from a parent node. The function takes the parameters
@code{(lambda (source-node depth))}
where @emph{depth} is a number maintained internally by aggregraphs that
corresponds to the distance of the current node from the root,
and @emph{source-node} is an
object in the source graph to be expanded. The function should return a list
of the children of @emph{source-node} in the source graph, or NIL to indicate the
node either has no children or should not be expanded (when depth > 1, for
example).

@code{:info-function} -- The function in this slot should take the parameter
@code{(lambda (source-node))}
where @emph{source-node} is an object in the source graph. It should return a
string associated with the @emph{source-node} so that a label can be placed on
its corresponding graph node in the aggregraph. (If the node-prototype is
customized by the programmer, then this function might return some other
identifying object instead of a string.)  The value returned by the function
is stored in the @code{:info} slot of the graph node.

@code{:source-roots} -- A list of roots in the source graph.
@end itemize

@b{Caveats:}

The source nodes must be distinguishable by one of the tests
@code{#'eq}, @code{#'eql}, or @code{#'equal}. The default is @code{#'eql}.
(Refer to the @code{:test-to-distinguish-source-nodes} slot in section
@ref{aggregraph-slots}.)

Instances of aggregraphs can be used as prototypes for other aggregraphs
without providing values for all the required slots in the prototype.


@subsection Aggregraph Nodes
@node Aggregraph Nodes
@anchor{node-slots}
@cindex{node}
@cindex{graph-node}
@cindex{node-prototype}
@cindex{link-prototype}

Each type of aggregraph has its own type of node and link prototypes. For the
@code{aggregraph}, the prototypes are @code{aggregraph-node-prototype} and
@code{aggregraph-link-prototype}, which are defined in the slots
@code{:node-prototype} and @code{:link-prototype}. To change the look of the nodes
or the links in an aggregraph, the programmer will need to define new
prototype objects in these slots. Section @ref{aggregraph-with-interactor}
contains an example aggregraph schema that modifies the node prototype.

The node and link prototypes for @code{scalable-aggregraph} are
@code{scalable-aggregraph-node-prototype} and
@code{scalable-aggregraph-link-prototype}. The prototypes for
@code{scalable-aggregraph-image} are
@code{scalable-aggregraph-image-node-prototype} and
@code{scalable-aggregraph-image-link-prototype}.

The actual nodes and links of the aggregraph are kept in "sub-aggregates" of
the aggregraph. The aggregates in the @code{:nodes} and @code{:links} slots of
the top-level aggregraph have the nodes and links as their components. To
access the individual links and nodes, look at the
@code{:components} slot of these aggregates. For example, the instruction
@example
(opal:do-components (gv graph :nodes)
                    #'(lambda (node)
                        (format T "~A~%" (gv node :info))))
@end example
will print out the names of all the nodes in the graph.

@cindex{back-pointer}
As each graph-node is created, a pointer to the corresponding
source-node is put in the slot @code{:source-node} of the graph-node.
This allows access to the source node from the graph-node. If
desired, a user can supply a function in the slot
@code{:add-back-pointer-to-nodes-function}. This function will be called on each
source-node/graph-node pair, and should put a pointer to the
graph-node in the source-node data structure. This can be used to
establish back pointers in the programmer's data structure.

The function in the slot @code{:source-to-graph-node} can be useful in finding
a particular node in the graph. When this method is given a source-node, it
will return the corresponding graph-node if one already exists in the graph.


Useful slots in the node objects include:

@vtable @code

@code{:left} and @code{:top} -- These slots must be set either directly by the
layout function or indirectly through formulas (probably dependent on other
slots in the node that are set by the layout function).

@code{:width} and @code{:height} -- Dimensions of the node.

@code{:links-to-me} and @code{:links-from-me} -- Each slot contains a list of
links that point to or from the given node. To get the nodes on the other side
of the links, reference the @code{:from} and @code{:to} slots of the links,
respectively.

@code{:source-node} -- A pointer to the corresponding node in the source graph
(i.e., the source-node of this graph-node). See
@code{:add-back-pointer-to-nodes-function} for back-pointers from the
source-node to the graph-node.

@code{:layout-info-...} -- Several slots that begin with "@code{:layout-info-}"
are reserved for bookkeeping by the layout function. Do not set these slots
except as part of a customized layout function.

@end vtable



@subsection A Simple Example
@node A Simple Example
@sp 1

@example
(create-instance 'SCHEMA-GRAPH opal:aggregraph
   (:children-function #'(lambda (source-node depth)
			   (if (> depth 1)
			       NIL
			       (gv source-node :is-a-inv))))
   (:info-function #'(lambda (source-node)
		       (string-capitalize
			(kr:name-for-schema source-node))))
   (:source-roots (list opal:view-object)))
@end example

@float Figure, fig:ex2
@center @image{schema-graph, 5.5in}
@caption{Graph generated by SCHEMA-GRAPH}
@anchor{schema-graph-pix}
@end float

The graph pictured in figure @ref{schema-graph-pix} is a result of the
definition of the SCHEMA-GRAPH object above. The aggregraph was given
a description of the Garnet inheritance hierarchy just by defining the root
of the graph and a child-generating function.

The generating function in the @code{:children-function} slot is defined to
return the instances of a given schema until the aggregraph reaches a certain
depth in the graph. In this case, if the function is given a node that is
more than one link away from the root, then the function will return NIL.

The function in the @code{:info-function} slot returns the string name of
a Garnet schema.


@subsection An Example With an Interactor
@node An Example With an Interactor
@anchor{aggregraph-with-interactor}
@sp 1

@example
(create-instance 'SCHEMA-GRAPH-2 opal:aggregraph
   (:children-function #'(lambda (source-node depth)
			   (when (< depth 1)
			     (gv source-node :is-a-inv))))
   (:info-function #'(lambda (source-node)
		       (string-capitalize
			(kr:name-for-schema source))))
   (:source-roots (list opal:view-object))
   @emph{; Change the node prototype so that it will go black}
   @emph{; when the interactor sets} :interim-selected @emph{to T}
   (:node-prototype
    (create-instance NIL opal:aggregraph-node-prototype
       (:interim-selected NIL)  @emph{; Set by interactor}
       (:parts
	`((:box :modify
	   (:filling-style ,(o-formula (if (gvl :parent :interim-selected)
					   opal:black-fill
					   opal:white-fill)))
	   (:draw-function :xor) (:fast-redraw-p T))
	  :text-al))))
   @emph{; Now define an interactor to work on all nodes of the graph}
   (:interactors
    `((:press ,inter:menu-interactor
       (:window ,(o-formula (gv-local :self :operates-on :window)))
       (:start-where ,(o-formula (list :element-of
                                       (gvl :operates-on :nodes))))
       (:final-function
	,#'(lambda (inter node)
	     (let* ((graph (gv node :parent :parent))
		    (source-node (gv node :source-node)))
	       (format T "~%~% ***** Clicked on ~S *****~%" source-node)
	       (kr:ps source-node))))))))
@end example

@float Figure, fig:ex2
@center @image{schema-graph-2, 5.5in}
@caption{Graph generated by SCHEMA-GRAPH-2}
@anchor{schema-graph-2-pix}
@end float

The graph of figure @ref{schema-graph-2-pix} comes from the definition of
SCHEMA-GRAPH-2. This aggregraph models the same Garnet hierarchy as in the
previous example, but it also modifies the node-prototype for the
aggregraph and adds an interactor to operate on the graph.

The @code{:node-prototype} slot must contain a Garnet object that can be used
to display the nodes of the graph. In this case, the customized
node-prototype is an instance of the default node-prototype (which is an
aggregadget) with some changes in the roundtangle part.
The formula for the @code{:filling-style} will make the node black
when the user presses on it with the mouse.

The interactor is defined as in aggregadgets and aggrelists.
Note that the @code{:start-where} slot looks at the
components of the @code{:nodes} aggregate in the top-level aggregraph.

Aggregadget nodes can be moved easily with an @code{inter:move-grow-interactor}.
By setting the @code{:slots-to-set} slot of the interactor to
@code{(list T T NIL NIL)}, you can change the @code{:left} and @code{:top} of the
aggregraph nodes as you click and drag on them.


@section Aggregraph
@node Aggregraph
@anchor{aggregraph-slots}
@cindex{aggregraph slots}

Features and operation of an Aggregraph
        @itemize
                Creates a graph in which each node determines its own
                size based on information to be displayed in it.
                (The information is determined by the function
                @code{:info-function}.)

                The user must supply a list of source-nodes to be the
                root of the graph, a children-function which can
                be used to walk the user's graph, and an info-function to
                determine what will be displayed in each graph node.

                It is an instance of aggregadget, and interactors can be
                defined as in aggregadgets.
        @end itemize

@b{Customizable slots}
        @vtable @code
                @code{:left}, @code{:top} -- The position of the aggregraph.
                Default is 0,0.

                @code{:source-roots} -- List of source nodes to be used as the
                roots of the graph. 

                @code{:children-function} -- A function which takes a source
                node and the depth from the root and
                returns a list of children. The children are treated
                as unordered by the default layout-function.

                @code{:info-function} -- A function which takes a source node and
                returns information to be used in the display of the
                node prototype. The result is put in the @code{:info} slot
                of the corresponding graph-node. The default node-prototype
                expects a string to be returned.

                @code{:add-back-pointer-to-nodes-function} -- A function or NIL.
                The function, if present, will be called on every
                source-node graph-node pair. The result of the
                function is ignored. This allows pointers to be
                put in the source-nodes for corresponding graph-nodes.

                @code{:node-prototype} -- A Garnet object for node prototype, or
                list of prototypes (in which case a
                @code{:node-prototype-selector-function} must be
                provided--see below). In the
                instances, the @code{:info} slot is set with the result of the
                info-function called on the corresponding source-node. The
		@code{:source-node} slot is set to the corresponding source node.
                And, the @code{:links-to-me} and @code{:links-from-me} slots are
                set to
                lists of graph links pointing to the node and from the node
                respectively. The slots whose names begin with
"@code{:layout-info}" are reserved for use by the layout functions for internal
bookkeeping and so should not be set by the user (unless writing a new
layout or associated methods). If any @code{scalable-aggregraph-image} graphs are
made of this graph, the @code{:image-nodes} slot is set to a list containing the
nodes that correspond to this node. The default prototype expects a string in
the @code{:info} slot, and displays the string with a white-filled
roundtangle surrounding it. 

                @code{:link-prototype} -- Garnet object for link prototype, or
list of prototypes (in which case a @code{:link-prototype-selector-function}
must be provided--see below).
                The @code{:from} and @code{:to} slots are set to the graph-nodes
                that this link connects. The @code{:image-links} slot is set to
a list of corresponding links to this one in associated
@code{scalable-aggregraph-image} graphs. The default prototype is a 
                line between these two graph nodes. (It is connected
                to the center of the right side of the @code{:from} node and
                to the center of the left side of the @code{:to} node. This
                assumes a left to right layout of the graph for
                pleasing display. For other layout strategies, a
                different prototype may be desired.)  For directed
                graphs, a link prototype with an arrowhead may be desired.

@code{:node-prototype-selector-function} -- A function which takes a source node and the list
of prototypes provided in the @code{:node-prototype} slot and returns one of the
prototypes. Will only be used if the value in the @code{:node-prototype} slot is a
list. 

@code{:link-prototype-selector-function} -- A function which takes a "from" graph-node, a "to"
graph-node and the list of prototypes provided in the @code{:link-prototype} slot and
returns one of the prototypes. Will only be used if the value in the
@code{:link-prototype} slot is a list.

                @code{:h-spacing} -- The minimum distance in pixels
                between nodes horizontally if using default layout-function.
                The default value is 20.

                @code{:v-spacing} -- The minimum distance in pixels
                between nodes vertically if using default layout-function. The
                default value is 5.

@code{:test-to-distinguish-source-nodes} -- Must be one of @code{#'eq}, @code{#'eql},
or @code{#'equal}. The default is @code{#'eql}.

                @code{:interactors} -- Specified in the same format as
		aggregadgets.

@code{:layout-info-...} -- Several slots that begin with "@code{:layout-info-}"
are reserved for bookkeeping by the layout function. Do not set these slots
except as part of a customized layout function.

@end vtable


   
@b{Read-only slots}

@vtable @code

@code{:nodes} -- The aggregate which contains all of the graph-node objects.

@code{:links} -- The aggregate which contains all of the graph link objects.

@code{:graph-roots} -- The list of graph nodes corresponding to the
@code{:source-roots}.

@code{:image-graphs} -- The list of @code{scalable-aggregraph-image} graphs that
                      are images of this graph.
@end vtable


@b[Methods] (can be overridden)

        @vtable @code
                @code{:layout-graph} -- a function which is called to determine
                the locations for all of the nodes in the graph. Takes
                the graph object as input and sets appropriate slots in
each node to position the node (usually @code{:left} and @code{:top} slots.)
Automatically called when graph is initially created.


                @code{:delete-node} -- Takes the graph object and a graph node
and deletes it and all links attached to it. If a node is deleted that
is a root of the graph, then it is removed from @code{:graph-roots} and the
corresponding source-node is removed from @code{:source-roots}.

                @code{:add-node} -- The arguments are the graph object, a
                source-node, a list of
                parent graph-nodes, and a list of children
                graph-nodes. It creates a new graph node and places
                it in the graph positioning it appropriately. Returns NIL.

                @code{:delete-link} -- Takes the graph object and a graph link
and removes the link from the graph.

                @code{:add-link} -- Takes the graph object and two graph nodes
and creates a link from the first node to the second.

                @code{:source-to-graph-node} -- Takes the graph object and a
source node and returns the corresponding graph-node.

                @code{:find-link} -- Takes the graph object and two graph-nodes
and returns the list of 
                graph link-objects from the first to the second.

@code{:make-root} -- Takes the graph object and a graph node of the graph and
adds the graph node to the root lists of the graph.

@code{:remove-root} -- Takes the graph object and a graph node and removes the
node from the root lists of the graph.

      @end vtable

Note that these eight methods depend on each other for
intelligent layout. If one is changed it will either
have to keep certain bookkeeping information, or other
functions will have to be changed as well.

The functions which add and delete nodes and links all
attempt to minimally change the graph. The relayout
function may dramatically change it.


@section Scalable Aggregraph
@node Scalable Aggregraph
@cindex{scalable aggregraph}

Features and operation of a Scalable Aggregraph
        @itemize
                This object is similar to the normal aggregraph
                except that it can be scaled by the user.
                Text will be displayed only if it will fit within the
                scaled size of the graph nodes with the default prototypes.
		The scale factor is set by the @code{:scale-factor} slot.

                The scalable aggregraph will automatically resize if the
                @code{:scale-factor} slot is changed.

                It is an instance of aggregadget, and interactors can be
                defined as in aggregadgets.
        @end itemize

@b[Customizable slots] (same as for @code{aggregraphs} except for the following):

        @vtable @code
                @code{:scale-factor} -- A multiplier of full size which determines
                the final size of the graph (e.g. 1 causes the graph to be
                full size, 0.5 causes the graph to be half of full size, etc.)
The full size of the graph is determined by the size of the node prototypes and
layout of the nodes.

                @code{:node-prototype} -- Must be able to set the @code{:width} and
                @code{:height}, otherwise the same as in aggregraph. These slots must
have initial values which will be used as their default value (i.e. the width
and height of the nodes is @code{:scale-factor} * the values in @code{:height} and @code{:width}
slots respectively.

                @code{:link-prototype} -- Position and size must depend on the nodes
it is attached to (by the @code{:from} and @code{:to} slots) with formulas.

@code{:h-spacing} and @code{:v-spacing} are the default
values. The actual values are @code{:scale-factor} * these values.
        @end vtable


@b{Read-only slots}

The same read-only slots are available as with @code{aggregraph}
(see section @ref{aggregraph-slots}).


@b{Methods} (can be overridden)

The same methods are available as with @code{aggregraph} (see section
@ref{aggregraph-slots}).



@section Scalable Aggregraph Image
@node Scalable Aggregraph Image
@cindex{scalable aggregraph image}

Features and operation of Scalable Aggregraph Image
        @itemize
                This is designed to show another view of an
                existing aggregraph. This image is created with the
                same shape as the original, i.e. the size of nodes and
                relative positions are in proportion to the original.
                The proportion is determined by the @code{:scale-factor} or
                @code{:desired-height} and @code{:desired-width} slots. 

                The size and shape are determined by Garnet formulas.
                This has the effect of maintaining the likeness to the
                original even as the original is manipulated and
                changed.

                The default prototypes (in particular the node
                prototype), are designed for the image to be used as
                an overview of a graph which perhaps doesn't fit on
                the screen. This is why no text is displayed in
                nodes, for example. This is not the only use of the
                gadget, especially if the prototypes are changed.
        @end itemize

@b{Customizable slots}

        @vtable @code
                @code{:left}, @code{:top} -- The position of the aggregraph.
                Default is 0,0.

                @code{:desired-width} and @code{:desired-height} -- Desired width
                and height of the entire graph. The graph will be
                scaled to fit inside these maximums.

                @code{:source-aggregraph} -- The aggregraph to make an image of.

                @code{:scale-factor} -- A multiplier of full size which
		determines
                the final size of the graph (e.g. 1 causes the graph to be
                the same size as the source aggregraph, 0.5 causes the graph to
		be half the size, etc.) 
                Scale-factor overrides the @code{:desired-width} and
                @code{:desired-height} slots if all are specified.
                The default value is 1.

                @code{:node-prototype} -- Garnet object for node prototype, or a list
of prototypes (in which case a @code{:node-prototype-selector-function} must be
provided--see below). The @code{:width}, @code{:height}, @code{:left} and @code{:top}
slots must all be
settable, and the node size and position must depend on these slots. They will
all be overridden with formulas in the created instances.
                The @code{:corresponding-node} slot is set to the corresponding node
                in the source aggregraph. The default
                node-prototype is a roundtangle proportional to the bounding
                box of the corresponding node in the source aggregraph
(because of the formulas).

                @code{:link-prototype} -- Same as in aggregraph, except the
                @code{:corresponding-link} slot is set to the corresponding link in
                the source aggregraph and there is no @code{:from} or @code{:to} slot. The
@code{:x1}, @code{:y1}, @code{:x2} and @code{:y2} slots of the link must all be
settable, and the link
endpoints must depend on their values. They will all be overridden with
formulas in the created instances. The default link-prototype is a line.

@code{:node-prototype-selector-function} -- A function which takes the appropriate
corresponding-node and the list of prototypes provided in the @code{:node-prototype}
slot and returns one of the prototypes. Will only be used if the value in the
@code{:node-prototype} slot is a list.

@code{:link-prototype-selector-function} -- A function which takes the
corresponding-link and the list of prototypes provided in
the @code{:link-prototype} slot and returns one of the prototypes.
Will only be used if the value in the @code{:link-prototype} slot is a list.

                @code{:interactors} -- Specified in the same format as
		aggregadgets.
        @end vtable


@b{Read-only slots}

The same read-only slots are available as with @code{aggregraph} except
@code{:graph-roots} (see section @ref{aggregraph-slots}).


@b{Methods} (probably shouldn't be overridden)

The methods of a @code{scalable-aggregraph-image} call the methods of the source
aggregraph, and changes are reflected in the image. If the methods of the
source graph are called directly, the changes will also be reflected.

When this aggregraph image is created, pointers are created in the source
aggregraph and all of its nodes and links to the corresponding image graph,
nodes and links. These pointers are added to a list in the slot
@code{:image-graphs}, @code{:image-nodes} and @code{:image-links}
of the aggregraph, nodes and links. Pointers from the image
to the source are in the slots @code{:source-aggregraph},
@code{:source-node} and @code{:source-link} as indicated below.
These links are used by the methods (both in this
gadget and in the two gadgets described above) to maintain the image.



@section Customizing the :layout-graph Function
@node Customizing the :layout-graph Function
@anchor{layout-graph}
@cindex{layout-graph}
@cindex{layout function}

@b{NOTE:}  Writing a customized layout function is a formidable task that
few users will want to try. This section is provided for programmers whose
aggregraph application requires a graph layout that is not suited to the
default tree layout function.

The function stored in @code{:layout-graph} computes the locations for all of
the nodes and links of the graph.
It takes the graph as its argument, and the returned value is ignored.
All nodes have been created with their height and width, and are
connected to the appropriate links and nodes, before the function is called.

The default layout function is @code{layout-tree} defined in @code{Opal}.
This function can be called repeatedly
on the graph, but may drastically change the look of the graph (if a series
of adds and deletes were done before the relayout). Features of
@code{layout-tree} are:

@itemize
It works best for trees and DAGs which are tree-like
(i.e. DAGs in which the width becomes larger toward the leaves).

It takes linear time in the number of nodes.

Children are treated as unordered.

Add and delete (both nodes and links) attempt to minimally change the
graph.
@end itemize

If a new layout function is written without regard to the bookkeeping
slots or the various methods associated with the aggregraph, the other methods
will work with the new layout function but will probably not keep the graph
looking as nice as possible.

With the default link prototypes it is only necessary to place the nodes,
because the links attach to the nodes automatically with Garnet formulas.
(Note that the default links are designed for a left to right layout of the
graph. If a different layout is desired another prototype may be desired. Of
course, formulas can still be used rather than explicitly placing each link.)

In general, the other graph methods may need to maintain or use the same
bookkeeping information as the layout function. For example, @code{add-node} and
@code{delete-node}
both affect the "@code{:layout-info-}" slots used by the default layout function.
(Specifically they add or delete rectangles respectively from the object
stored in the @code{:layout-info-rect-conflict-object} slot of the graph object.
This object keeps track of all rectangles (nodes) placed on the graph and when
queried with a new rectangle returns any stored rectangles that it overlaps.)
When redefining the layout function, it may be necessary to redefine these
functions.



@chapter Garnet Gadgets
@node Garnet Gadgets 

by Andrew Mickish,
Brad A. Myers,
Rajan Parthasarathy,

@value{DATE}

@section Abstract
@node Abstract

The Garnet Gadget Set contains common user interface objects which can
be customized for use in an interface. Because the objects
are extremely versatile, they may be employed in a wide range of applications
with a minimum of modification. Examples of provided gadgets include menus,
buttons, scroll bars, sliders, and gauges.





@section Introduction
@node Introduction

Many user interfaces that span a wide variety of applications usually have
several elements in common. Menus and scroll bars, for example, are used so
frequently that an interface designer would waste considerable time and effort
recreating those objects each time they were required in an application.

The intent of the Garnet Gadget Set is to supply several frequently used objects
that can be easily customized by the designer. By importing these
pre-constructed objects into a larger Garnet interface, the designer is able
to specify in detail the desired appearance and behavior of the interface, while
avoiding the programming that this specification would otherwise entail.

This document is a guide to using the Gadget Set. The objects
were constructed using the complete Garnet system, and their descriptions assume
that the reader has some knowledge of KR, Opal, Interactors, and Aggregadgets.


@section Current Gadgets
@node Current Gadgets

Most of the gadgets described in this manual are pictured in figures
@ref{scroll-group} through @ref{db-group}

@float Figure, fig:ex2
@center @image{scroll-group-pix, 5.5in}
@center @image{motif-scroll-group-pix, 5.5in}
@caption{The Garnet-style and Motif-style scroll bars, sliders, and gauges.
@code{@b[(a)] v-scroll-bar},@*@code{@b[(b)] v-slider}, @code{@b[(c)] gauge},
@code{@b[(d)] trill-device}, @code{@b[(e)] h-scroll-bar},
@code{@b[(f)] h-slider},
@*@code{@b[(g)] motif-v-scroll-bar}, @code{@b[(h)] motif-slider},
@code{@b[(i)] motif-gauge}, @code{@b[(j)] motif-@*trill-device},
@code{@b[(k)] motif-slider}}
@anchor{scroll-group}
@end float

0
@itemize
@b{Gadgets used to choose a value from a range of values}
@vtable @code
@code{v-scroll-bar} -  Vertical scroll bar (p. @ref{scroll-bars})

@code{v-slider} -  Vertical slider (same idea as a scroll bar, but with a
tic-marked shaft rather than a rectangular bounding box) (p. @ref{sliders})

@code{gauge} -  Semi-circular gauge (the needle on the gauge may be
moved to select a value) (p. @ref{gauge})

@code{trill-device} -  Number input box with increment/decrement trill
boxes (p. @ref{trill-device})

@code{h-scroll-bar} -  Horizontal scroll bar (p. @ref{scroll-bars})

@code{h-slider} -  Horizontal slider (p. @ref{sliders})

@code{motif-v-scroll-bar} - Vertical scroll bar (p. @ref{motif-scroll-bars})

@code{motif-slider} - Vertical slider (same idea as a scroll bar, but with text
beside the indicator showing the current value) (p. @ref{motif-slider})

@code{motif-gauge} - Semi-circular gauge (p. @ref{motif-gauge})

@code{motif-trill-device} - Number input with trill boxes
(p. @ref{motif-trill-device})

@code{motif-h-scroll-bar} - Horizontal scroll bar
(p. @ref{motif-scroll-bars})

@end vtable
@end itemize



@float Figure, fig:ex2
@center @image{menu-group-pix, 5.5in}
@center @image{motif-menu-group-pix, 5.5in}
@caption{The Garnet-style and Motif-style buttons and menus.
@b{(a)} @code{menubar},@*
@b{(b)} @code{popup-menu-button}, @b{(c)} @code{menu},
@b{(d)} @code{scrolling-menu}, @b{(e)} @code{text-button-panel},@*
@b{(f)} @code{x-button-panel}, @b{(g)} @code{radio-button-panel},
@b{(h)} @code{option-button},@*
@b{(i)} @code{motif-menubar}, @b{(j)} @code{motif-menu},
@b{(k)} @code{motif-scrolling-menu},@*
@b{(l)} @code{motif-text-button-panel},
@b{(m)} @code{motif-check-button-panel},@*
@b{(n)} @code{motif-radio-button-panel},
@b{(o)} @code{motif-option-button} in its unselected and selected state}
@anchor{menu-group}
@end float


@itemize
@b{Gadgets used to choose items from a list of possible choices}
@vtable @code
@code{menubar} - A pull-down menu (p. @ref{menubar})

@code{popup-menu-button} - A button which pops up a menu when pressed. The
appearance of the button does not change with the selection.
(p. @ref{popup-menu-button})

@code{menu} -  Vertical menu, single selection (p. @ref{menu})

@code{scrolling-menu} -  A menu with a scroll bar on one side, which allows a
subset of all items in the menu to be viewed. (single or multiple selection)
(p. @ref{scrolling-menu})

@code{text-buttons} -  A panel of rectangular buttons, each with a choice
centered inside the button. As an option, the currently selected choice
may appear in inverse video. (single selection) (p. @ref{buttons} and
@ref{text-buttons})

@code{x-buttons} -  A panel of square buttons, each with a choice beside the
button. An "X" appears inside each currently selected button. (multiple
selection)  (p. @ref{buttons} and @ref{x-buttons})

@code{radio-buttons} -  A panel of circular buttons, each with a choice beside
the button. A black circle appears inside the currently selected button. 
(single selection)  (p. @ref{buttons} and @ref{radio-buttons})

@code{option-button} - A button which pops up a menu when pressed. Selection of
a choice from the menu causes that item to appear as the new label of the
button. (p. @ref{option-button})

@code{motif-menubar} - A pull-down menu. (p. @ref{motif-menubar})

@code{motif-menu} - Vertical menu, single selection  (p. @ref{motif-menu})

@code{motif-scrolling-menu} - A menu with an attached scroll bar.
(p. @ref{motif-scrolling-menu})

@code{motif-text-buttons} - A panel of rectangular buttons, each with a
choice appearing inside the button. (single selection)
(p. @ref{motif-buttons} and @ref{motif-text-buttons})

@code{motif-check-buttons} - A panel of square buttons, each with a
choice beside the buttons. (multiple selection)
(p. @ref{motif-buttons} and @ref{motif-check-buttons})

@code{motif-radio-buttons} - A panel of diamond buttons, each with a
choice beside the button. (single selection)
(p. @ref{motif-buttons} and @ref{motif-radio-buttons})

@code{motif-option-button} - A button which pops up a menu when pressed.
Selection of a choice from the menu causes that item to appear as the new
label of the button. (p. @ref{motif-option-button})

@end vtable
@end itemize




@float Figure, fig:ex2
@center @image{text-group-pix, 5.5in}
@center @image{multifont-gadget-pix, 5.5in}
@caption{Text gadgets. @b{(a)} @code{labeled-box},
@b{(b)} @code{scrolling-labeled-box},@*@b{(c)} @code{scrolling-input-string},
@b{(d)} @code{motif-scrolling-labeled-box},@*@b{(e)} @code{multifont-gadget}}
@anchor{text-group}
@end float

@itemize
@b{Gadgets used to handle text input}
@vtable @code
@code{labeled-box} -  A framed text object that may be edited. As the string
gets longer, the frame expands. (p. @ref{labeled-box})

@code{scrolling-labeled-box} - A scrolling input string in a box with a label.
The frame stays fixed, and the string scrolls.
(p. @ref{scrolling-labeled-box})

@code{scrolling-input-string} - Input a text string, but using a fixed width
area and scroll the string horizontally if necessary.
(p. @ref{scrolling-input-string})

@code{motif-scrolling-labeled-box} - A labeled box with text inside that may
be edited. (p. @ref{motif-scrolling-labeled-box})

@code{multifont-gadget} - A text editing gadget that includes word wrap,
text selection, and many functions that allow manipulation of the
text. This gadget is discussed in the Opal manual. 

@end vtable
@end itemize



@float Figure, fig:ex2
@center @image{dialog-box-pix, 5.5in}
@caption{Garnet dialog boxes. @b{(a)} @code{motif-save-gadget},
@b{(b)} @code{error-gadget},@*@b{(c)} @code{motif-query-gadget},
@b{(d)} @code{motif-prop-sheet-with-OK}}
@anchor{db-group}
@end float

@itemize
@b{Dialog boxes for reading and writing to files} (the @code{motif-save-gadget} is
pictured in figure @ref{db-group})
@vtable @code
@code{save-gadget} - Saves a file in a directory whose contents are displayed
in a scrolling menu. (p. @ref{save-gadget})

@code{load-gadget} - Loads a file from a directory whose contents are displayed
in a scrolling menu. (p. @ref{load-gadget})

@code{motif-save-gadget} - Saves a file in a directory whose contents are
displayed in a Motif style scrolling menu. (p. @ref{motif-save-gadget})

@code{motif-load-gadget} - Loads a file from a directory whose contents are
displayed in a Motif style scrolling menu. (p. @ref{motif-load-gadget})
@end vtable
@end itemize

@itemize
@b{Dialog boxes for reporting errors to the user and asking for user
input}  (the @code{error-gadget} and @code{motif-query-gadget} are pictured
in figure @ref{db-group}).
@vtable @code
@code{error-gadget} - Used to display error messages in a window with an
"OK" button (p. @ref{error-gadget})

@code{query-gadget} - A dialog box like the @code{error-gadget}, but with
multiple buttons and the ability to return values.
(p. @ref{query-gadget})

@code{motif-error-gadget} - A dialog box used to display error messages
with an "OK" button in the Motif style.
(p. @ref{motif-error-gadget})


@code{motif-query-gadget} - A Motif style dialog box with multiple buttons.
(p. @ref{motif-query-gadget})

@end vtable
@end itemize


@itemize
@b{Property sheet gadgets} (a Motif property sheet is pictured in figure
@ref{db-group})
@vtable @code
@code{prop-sheet} - Displays a set of labels and values and allows the values
to be edited. This gadget can be easily displayed in its own window.
(p. @ref{propertysheets})

@code{prop-sheet-for-obj} - A property sheet designed to display the slots
in a Garnet object. (p. @ref{propsheetforobj})

@code{prop-sheet-with-OK} - A property sheet with OK-Cancel buttons.
(p. @ref{propsheetwithok})

@code{prop-sheet-for-obj-with-OK} - A property sheet designed to display the
slots in a Garnet object with attached OK-Cancel buttons.
(p. @ref{propsheetforobjwithok})

@code{motif-prop-sheet-with-OK} - A property sheet with OK-Cancel buttons
in the Motif style. (p. @ref{motif-prop-sheets})

@code{motif-propt-sheet-for-obj-with-OK} - A Motif style property sheet designed
to display the slots in a Garnet object with attached OK-Cancel buttons.
(p. @ref{motif-prop-sheet-for-obj-with-ok})
@end vtable


@b{Scrolling windows}
@vtable @code
@code{scrolling-window} - Supports a scrollable window
(p. @ref{scrolling-windows})


@code{scrolling-window-with-bars} - Scrolling window complete with scroll bars.
(p. @ref{scrolling-windows})

@code{motif-scrolling-window-with-bars} - Motif style scrolling window
(p. @ref{motif-scrolling-window})
@end vtable


@b{Special gadgets}
@vtable @code
@code{arrow-line} - A line with an arrowhead at one end
(p. @ref{arrow-line})

@code{double-arrow-line} - A line with arrowheads at both ends
(p. @ref{double-arrow-line})

@code{browser-gadget} - Used to examine structures and hierarchies
(p. @ref{browser-gadget})

@code{graphics-selection} - Bounding boxes and
interactors to move and change the size of other graphical objects.
(p. @ref{graphics-selection})

@code{multi-graphics-selection} - Same as @code{graphics-selection}, but for
multiple objects. (p. @ref{multi-gs})

@code{polyline-creator} - For creating and editing polylines.
(p. @ref{polyline-creator})

@code{MouseLine} and @code{MouseLinePopup} - A gadget that pops up a "help" string,
informing the user about the object that the mouse is held over.

@code{standard-edit} - A module of predefined "cut" and "paste" procedures,
and many other common editing functions. (p. @ref{standardeditsec})
@end vtable
@end itemize



@section Customization
@node Customization
@cindex{customization} The most important feature of the Garnet Gadgets
is the ability to create a variety of interface styles from a small
collection of prototype objects. Each gadget includes many parameters
which may be customized by the designer, providing a great deal of
flexibility in the behavior of the gadgets. The designer may,
however, choose to leave many of the default values unchanged, while
modifying only those parameters that integrate the object into the
larger user interface.

The location, size, functionality, etc., of a gadget is determined by
the values in each of its slots. When instances of gadgets are
created, the instances inherit all of the slots and slot values from
the prototype object except those slots which are specifically
assigned values by the designer. The slot values in the prototype can
thus be considered "default" values for the instances, which may be
overridden when instances are created.@footnote{See the KR manual for a
more detailed discussion of inheritance.}  The designer may also add
new slots not defined in the gadget prototype for use by special
applications in the larger interface.
@cindex{slots}
@cindex{inheritance}
Slot values may be changed after the instances are
created by using the KR function @code{s-value}.

@section Using Gadget Objects
@node Using Gadget Objects
@cindex{garnet-gadgets package}
@cindex{gg nickname}
@cindex{use-package}
The gadget objects reside in the @code{GARNET-GADGETS} package, which
has the nickname "GG". We recommend that programmers explicitly
reference the name of the package when creating instances of the 
gadgets, as in @code{garnet-gadgets:v-scroll-bar} or @code{gg:v-scroll-bar}.
However, the package name may be dropped if the line @code{(use-package
"GARNET-GADGETS")} is executed before referring to gadget objects.

Before creating instances of gadget objects, a set of component
modules must be loaded. These modules are loaded in the correct order
when the "-loader" files corresponding to the desired gadgets are used
(see Chapter @ref{accessing}).
@cindex{loader files}

Since each top-level object is exported from the @code{GARNET-GADGETS}
package, creating instances of gadget objects is as easy as
instantiating any other Garnet objects. To use a gadget, an instance
of the prototype must be defined and added to an interactor window.
The following lines will display a vertical scroll bar in a window:
@example
(create-instance 'MY-WIN inter:interactor-window
   (:left 0) (:top 0) (:width 300) (:height 500))
(create-instance 'MY-AGG opal:aggregate)
(s-value my-win :aggregate my-agg)
(create-instance 'MY-SCROLL-BAR garnet-gadgets:v-scroll-bar)
(opal:add-component my-agg my-scroll-bar)
(opal:update my-win)
@end example
@cindex{v-scroll-bar}
@cindex{displaying objects} The first two instructions create an
interactor window named @code{my-win} and an aggregate named
@code{my-agg}. The third instruction sets the @code{:aggregate} slot of
@code{my-win} to @code{my-agg}, so that all graphical objects attached to
@code{my-agg} will be shown in @code{my-win}. The next two instructions
create an instance of the @code{v-scroll-bar} object named
@code{my-scroll-bar} and add it as a component of @code{my-agg}. The last
instruction causes @code{my-win} to become visible with
@code{my-scroll-bar} inside.

In most cases, the use of a gadget will follow the same form as the
preceding example. The important difference will be in the
instantiation of the gadget object (the fifth instruction above),
where slots may be given values that override the default values
defined in the gadget prototype. The following example illustrates
such a customization of the vertical scroll bar.

Suppose that we would like to create a vertical scroll bar whose
values span the interval [0..30], with its upper-left coordinate at
(25,50). This vertical scroll bar may be created by:
@example
(create-instance 'CUSTOM-BAR garnet-gadgets:v-scroll-bar
   (:left 25)
   (:top 50)
   (:val-1 0)
   (:val-2 30))
@end example
@cindex{customization} This instruction creates an object called
CUSTOM-BAR which is an instance of @code{v-scroll-bar}. The
vertical scroll bar CUSTOM-BAR has inherited all of the slots
that were declared in the @code{v-scroll-bar} prototype along with their
default values, except for the coordinate and range values which have
been specified in this schema definition (see section
@ref{scroll-bars} for a list of customizable slots in the scroll bar
objects).


@section Application Interface
@node Application Interface

There are several ways that the gadgets can interface with your
application. This section describes several ways the you can get the
gadgets to "do something" to your application.

@subsection The :value slot
@node The :value slot
@cindex{value slot}
@anchor{value-slot}
In most gadgets, there is a top-level @code{:value}
slot. This slot is updated automatically after a user changes the
value or position of some part of the gadget. This is therefore the
main slot through which the designer perceives action on the part of
the user.

The @code{:value} slot may be accessed directly (by the KR functions
@code{gv} and @code{gvl})
order to make other objects in the larger interface dependent on the
actions of the user. The slot may also be set directly by the KR
function @code{s-value} to change the current value or selection
displayed by the gadget (except in the scrolling menu gadget, where
the @code{:selected-ranks} slot must be set).

@cindex{initial value}
An instance of a gadget can be given initial
values by setting the @code{:value} slot after the instance has been
created. In most gadgets, this slot may
@b{not} be given a value in the @code{create-instance} call, since this
would override the formula in the slot. Therefore, the general
procedure for selecting an initial value in a gadget is to create the
instance, access the @code{:value} slot using @code{gv} (to
initialize the formula in the slot and establish dependencies), and
then use @code{s-value} to set the slot to the desired initial value.

See sections @ref{use-value} and @ref{sel-buttons} for examples of the
@code{:value} slot in use.

@subsection The :selection-function slot
@node The :selection-function slot
@anchor{sel-fn}
@cindex{selection-function}
In most gadgets there is a
@code{:selection-function} slot which holds the name of a function to be
called whenever the @code{:value} slot changes due to action by the user
(such as the pressing of a button). The @code{:selection-function} is
not automatically called when the designer's interface sets the
@code{:value} slot directly.

This is probably the most important link between the gadgets and your
application. By supplying a gadget with a selection function, then
the gadget can execute some application-specific procedure when the
user operates it.

In the scroll bars, sliders, trill device, and gauge, this function is
called after the user changes the value by moving the indicator or
typing in a new value (the function is called repeatedly while the
user drags an indicator). In buttons and menus, it is called when the
user changes the currently selected item or set of items, and it
precedes the function attached locally to the item. In the labeled
box, scrolling-input-string and scrolling-labeled-box, it is called
after the user has finished editing the text (i.e., after a carriage
return). In the @code{:graphics-selection} gadget, it is called
whenever the user selects a new object or deselects the current
object.

In the scrolling menu gadget, there are two selection functions, named
@code{:scroll-selection-function} and @code{:menu-selection-function}
which are called independently when the user moves the scroll bar or
selects a menu item, respectively.

The function must take two parameters: the top-level gadget itself and the
value of the top-level @code{:value} slot:
@example
(lambda (gadget-object value))
@end example
In x-buttons, the parameter @code{value} will be a
list of strings. The scrolling menu sends the menu item (a Garnet
schema) on which the user just clicked as its @code{value}. Other
gadgets will have only a single number or string as their @code{value}.
@cindex{selection-function}

An example use of @code{:selection-function} is in section @ref{use-selection}.


@subsection The :items slot
@node The :items slot
@cindex{items slot}
@anchor{items-slot}
The button and menu gadgets are built up from items supplied by the designer.
These items are supplied as a list in the @code{:items} slot of the gadgets.
@b{Note:} Do not destructively modify the @code{:items} list; instead, create
a new list using @code{list} or copy the old value with @code{copy-list} and
modify the copy.

@subsection Item functions
@node Item functions
@cindex{item functions}
@cindex{atoms}
There are several ways to specify items:

@itemize
@b{List of strings} - This is the obvious case, such as @code{'("Open" "Close"
"Erase")}.

@b{List of atoms} - In Garnet, the values of slots are often specified
by atoms -- symbols preceded by a colon (e.g., @code{:center}). If a
formula in the larger interface depends upon the @code{:value} slot of
the button panel, then the designer may wish the items to be actual
atoms rather than strings, so that the value is immediately used
without being coerced. Such a list would look like @code{'(:left
:center :right)}. The items will appear to the user as capitalized
strings without colons.

@b{List of objects} - In addition to string labels, the gadgets can have
labels that are objects (like circles and rectangles). Such a list might
look like @code{`(,MY-CIRCLE ,MY-SQUARE ,OBJ3)}. Objects, strings, and atoms
can be mixed together in any @code{:items} list. Most of the demo functions
for the gadgets use at least one object in the example.

@b{List of label/function pairs} - This mode is
useful when the designer wishes to execute a specific function upon
selection of a button. If the @code{:items} slot contained the list
@code{'(("Cut" My-Cut) ("Paste" My-Paste))}, then the function
@code{My-Cut} would be executed when the button labeled "Cut" becomes
selected. The designer must define these functions with two parameters:
@example
(lambda (gadget-object item-string))
@end example
The @emph{gadget-object} is the top-level gadget
(such as a @code{text-button-panel}) and the @emph{item-string} is the
string (or atom) of the item that was just selected.
@end itemize

The item functions are executed along with the selection function
whenever the user operates the gadget. These functions are different,
however, because the selection function is executed when @b{any} item
is selected, and the item functions are only executed when the item
associated with them is selected.

The gadgets always assume that if an element of the @code{:items} list is
a list, then the first element in the item is a label and the second element
is a function. If you intend to use the @code{:items} list for storing
application-specific data, you should avoid storing data in these reserved
positions of the item elements. It is fine to store arbitrary data in the
third and subsequent elements of an item list.

Section @ref{use-item-fn} shows an example implementation of item
functions.


@subsection Adding and removing items
@node Adding and removing items
@cindex{Add-item",Secondary="Gadgets}
@cindex{notice-items-changed}
There are two ways to add and remove items from a button or menu gadget:
use @code{add-item} and @code{remove-item} to change the @code{:items} list,
or set the @code{:items} slot by hand using @code{s-value}.
Both ways to change items are shown in the example below.

The various methods for changing items are

@example
opal:Add-Item @i{gadget item} [[:where] @i{position[locator]} [:key @i{function-name}]]@ref{method}

opal:Remove-Item @i{gadget} [@i{item} [:key @i{function-name}]]@ref{method}

opal:Remove-Nth-Item @emph{gadget} @emph{n}@ref{method}

opal:Change-Item @emph{gadget item n}@ref{method}
@end example

These methods are described in the Aggregadgets manual.
@code{Add-item} will add @emph{item} to the @code{:items} list of @emph{gadget}, and
will place it in the list according to the @emph{position}, @emph{locator}, and
@emph{key} parameters.

All gadgets that have an @code{:items} slot support @code{add-item} and the other
methods (except for the @code{browser-gadget}, which has other
item maintenance functions). The documentation for the @code{menubar} and
@code{motif-menu} describes special features supported by those gadgets.

For example, consider adding an item to the X-BUTTONS-OBJ in the
@code{x-button-panel} demo.
@example
@emph{; Use opal:add-item in one step}
(opal:add-item gg:X-BUTTONS-OBJ "newitem-1")

@emph{; Use s-value (directly or indirectly)}
(push "newitem-2" (gv gg:X-BUTTONS-OBJ :items))
@end example

The @code{push} function uses @code{s-value} indirectly.
@code{S-value} may also be used explicitly. After changing the @code{:items} list
with @code{s-value}, the components of the gadget
(like the individual buttons in a button panel) will be adjusted during the
next call to @code{opal:update}. If information about the gadget (like its new
dimensions) is required @emph{before} the next update, the components can be
adjusted manually with a call to @code{opal:notice-items-changed} with the
gadget as a parameter. See the Aggregadgets Manual for more information about
@code{opal:notice-items-changed}.

Because of internal references to the @code{:items} slot, destructive
modification of the @code{:items} list is not allowed. If you change the list
in the @code{:items} slot, you should create a new list (e.g., with @code{list}),
or use @code{copy-list} on the original, and destructively modify the copy.


@section Constants with the Gadgets
@node Constants with the Gadgets
@cindex{Constants", Secondary="Gadgets}
@cindex{maybe-constant}
At the top of most gadget definitions, there is a slot called
@code{:maybe-constant} with a list of slots as its value. These are the
slots that will be declared constant in an instance of a gadget, if
the instance was created with its @code{:constant} slot set to T. By
declaring a slot constant, the user promises that the value of that
slot will never change, and all formulas that depend on it can be
thrown away and replaced by absolute values.

Removing formulas that depend on constant slots can free up a large
amount of storage space. Therefore, users who have finished designing
part of an interface may want to go back through their gadget
instances and delclare constant as many slots as possible.

In addition to using the special T value in a @code{:constant} list,
you can selectively declare slots constant by listing them
explicitly (e.g., @code{(:constant '(:left :top))}).
You can also use the @code{:except} keyword, as in the following schema:
@example
(create-instance NIL gg:motif-radio-button-panel
   (:constant '(T :except :active-p))
   (:left 10)(:top 30)
   (:items '("Start" "Pause" "Quit")))
@end example
In this example, the user declares constant all of the slots in the
@code{:maybe-constant} list, with the exception of @code{:active-p}. This
allows the value of the @code{:active-p} slot to change, and retains all
the formulas that depend on it (so that the gadget will update its
appearance correctly when the value is toggled).

Constants are discussed in detail in the KR manual.


@section Accessing the Gadgets
@node Accessing the Gadgets

@anchor{accessing}

@section Gadgets Modules
@node Gadgets ModulesThe schemata definitions in the gadgets
package are modularized so that one schema may be used by several
objects. For example, trill boxes with arrows pointing to the left
and right are used in the horizontal scroll bar, the horizontal
slider, and the trill device. As a result, all of the code for the
gadget objects has a consistent style, and the gadgets themselves have
a uniform look and feel.
@cindex{modules}


@section Loading the Gadgets
@node Loading the Gadgets

Since much of the gadget code is shared
by the top-level objects, a set of "parts" modules must be loaded
before some of the top-level gadgets. The required modules are loaded
in the proper order when the loader files corresponding to the desired
gadgets are used. The standard gadgets and their associated loader
files are listed in figure @ref{loader-files-figure}. The motif
gadgets and loader files appear in figure
@ref{motif-loader-files-figure}. It is safe to load the
"xxx-loader" files multiple times, they will not re-load the
objects the second time.@cindex{loader files}

@float Figure, fig:ex2
@vtable @code
@code{arrow-line} - "arrow-line-loader"

@code{browser-gadget} - "browser-gadget-loader"

@code{double-arrow-line} - "arrow-line-loader"

@code{error-gadget} - "error-gadget-loader"

@code{gauge} - "gauge-loader"

@code{graphics-selection} - "graphics-loader"

@code{h-scroll-bar} - "h-scroll-loader"

@code{h-slider} - "h-slider-loader"

@code{labeled-box} - "labeled-box-loader"

@code{load-gadget} - "save-gadget-loader"

@code{menu} - "menu-loader"

@code{menubar} - "menubar-loader"

@code{MouseLine} and @code{MouseLinePopup} - "mouseline-loader"

@code{multifont-gadget} - "multifont-loader"

@code{multi-graphics-selection} - "multi-selection-loader"

@code{option-button} - "option-button-loader"

@code{popup-menu-button} - "popup-menu-button-loader"

@code{prop-sheet} - "prop-sheet-loader"

@code{prop-sheet-for-obj} - "prop-sheet-loader"

@code{prop-sheet-for-obj-with-OK} - "prop-sheet-win-loader"

@code{prop-sheet-with-OK} - "prop-sheet-win-loader"

@code{query-gadget} - "error-gadget-loader"

@code{radio-button} - "radio-buttons-loader"

@code{radio-button-panel} - "radio-buttons-loader"

@code{save-gadget} - "save-gadget-loader"

@code{scrolling-input-string} - "scrolling-input-string-loader"

@code{scrolling-labeled-box} - "scrolling-labeled-box-loader".

@code{scrolling-menu} - "scrolling-menu-loader"

@code{scrolling-window} - "scrolling-window-loader"

@code{scrolling-window-with-bars} - "scrolling-window-loader"

@code{standard-edit} - "standard-edit-loader"

@code{text-button} - "text-buttons-loader"

@code{text-button-panel} - "text-buttons-loader"

@code{trill-device} - "trill-device-loader"

@code{v-scroll-bar} - "v-scroll-loader"

@code{v-slider} - "v-slider-loader"

@code{x-button} - "x-buttons-loader"

@code{x-button-panel} - "x-buttons-loader"

@end vtable
@caption{Loader files for Garnet Gadgets}
@anchor{loader-files-figure}
@end float


@float Figure, fig:ex2
@vtable @code

@code{motif-check-button} - "motif-check-buttons-loader"

@code{motif-check-button-panel} - "motif-check-buttons-loader"

@code{motif-error-gadget} - "motif-error-gadget-loader"

@code{motif-gauge} - "motif-gauge-loader"

@code{motif-h-scroll-bar} - "motif-h-scroll-loader"

@code{motif-load-gadget} - "motif-save-gadget-loader")

@code{motif-menu} - "motif-menu-loader"

@code{motif-menubar} - "motif-menubar-loader"

@code{motif-option-button} - "motif-option-button-loader"

@code{motif-prop-sheet-...} - "motif-prop-sheet-win-loader"

@code{motif-query-gadget} - "motif-error-gadget-loader"

@code{motif-radio-button} - "motif-radio-buttons-loader"

@code{motif-radio-button-panel} - "motif-radio-buttons-loader"

@code{motif-save-gadget} - "motif-save-gadget-loader"

@code{motif-scrolling-labeled-box} - "motif-scrolling-labeled-box-loader"

@code{motif-scrolling-menu} - "motif-scrolling-menu-loader"

@code{motif-scrolling-window-with-bars} - "motif-scrolling-window-loader"

@code{motif-slider} - "motif-slider"

@code{motif-text-button} - "motif-text-buttons-loader"

@code{motif-text-button-panel} - "motif-text-buttons-loader"

@code{motif-trill-device} - "motif-trill-device-loader"

@code{motif-v-scroll-bar} - "motif-v-scroll-loader"

@end vtable
@caption{Loader files for Motif Gadgets}
@anchor{motif-loader-files-figure}
@end float

@cindex{garnet-gadgets-loader}
To load the entire Gadget Set, execute
@code{(load Garnet-Gadgets-Loader)} after loading the
@code{Garnet-Loader}. @emph{This is not recommended, since there are so
many gadgets, and you will only need a few of them!}  To load
particular objects, such as the @code{v-slider} and @code{menu} gadgets,
load the specific loader files:
@example
(garnet-load "gadgets:v-slider-loader")
(garnet-load "gadgets:menu-loader")
@end example
For a discussion of the @code{garnet-load} function, see the Overview at the
beginning of this reference manual.

@section Gadget Files
@node Gadget Files

There are several gadgets files that
normally have names that are longer than 31 characters. Since the Mac
restricts the length of filenames to 31 characters, some gadget files have
their names truncated on the Mac. Mac users may
continue to specify the full-length names of these files by using
@code{user::garnet-load}, described in the Overview section of this manual,
which translates the regular names of the gadgets into their truncated
31-character names so they can be loaded. It is recommended that
@code{garnet-load} be used
whenever any Garnet file is loaded, so that typically long and cumbersome
pathnames can be abbreviated by a short prefix.

@section Gadget Demos
@node Gadget Demos

Most gadgets have small demo functions that are loaded along with their
schema definitions.@footnote{Unless the @code{:garnet-debug} key was removed from
from the @code{*features*} list when the Garnet software was compiled or
loaded (see the Hints manual).}  For example, after loading the
@code{"v-slider-loader"}, you can do @code{gg:v-slider-go} to see a demo of the
vertical slider.

A complete list of all gadget demos is included in the Demonstration Programs
section of this reference manual. The names of all gadget demos are also
mentioned at the top of each section in this Gadget manual.



@section The Standard Gadget Objects
@node The Standard Gadget Objects

@anchor{Standard-Gadgets}

Each of the objects in the Gadget Set is an interface mechanism
through which the designer obtains chosen values from the user. The
scroll bars, sliders, gauge, and trill device all have a "continuous"
flavor, and are used to obtain values between maximum and minimum
allowed values. The buttons and menus are more "discrete", and allow
the selection of a single choice from several alternatives.

The sections of this chapter describe the gadgets in detail. Each
object contains many customizable slots, but the designer may choose
to ignore most of them in any given application. If slot values are
not specified when instances are created, then the default values will
be used.

Each description begins with a list of the customizable slots and
default values for the gadget object.

@section Scroll Bars
@node Scroll Bars
@anchor{scroll-bars}
@cindex{v-scroll-bar}
@cindex{h-scroll-bar}
@cindex{scroll-bars}

@example
(create-instance 'gg:V-Scroll-Bar opal:aggregadget
   (:maybe-constant '(:left :top :height :min-width :val-1 :val-2 :scr-trill-p
                      :page-trill-p :indicator-text-p :page-incr :scr-incr
                      :int-feedback-p :scroll-p :format-string :indicator-font
                      :visible))
   (:left 0)
   (:top 0)
   (:height 250)
   (:min-width 20)
   (:val-1 0)
   (:val-2 100)
   (:scr-incr 1)
   (:page-incr 5)
   (:scr-trill-p T)
   (:page-trill-p T)
   (:indicator-text-p T)
   (:int-feedback-p T)
   (:scroll-p T)
   (:indicator-font (opal:get-standard-font :fixed :roman :small))
   (:value (o-formula ...))
   (:format-string "~a")
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example
@sp 1

@example
(create-instance 'gg:H-Scroll-Bar opal:aggregadget
   (:maybe-constant '(:left :top :width :min-height :val-1 :val-2 :scr-trill-p
                      :page-trill-p :indicator-text-p :page-incr :scr-incr
                      :int-feedback-p :scroll-p :format-string :indicator-font :visible))
   (:left 0)
   (:top 0)
   (:width 250)
   (:min-height 20)
   (:val-1 0)
   (:val-2 100)
   (:scr-incr 1)
   (:page-incr 5)
   (:scr-trill-p T)
   (:page-trill-p T)
   (:indicator-text-p T)
   (:int-feedback-p T)
   (:scroll-p T)
   (:indicator-font (create-instance NIL opal:font (:size :small)))
   (:value (o-formula ...))
   (:format-string "~a")
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@float Figure, fig:ex2
@center @image{scroll-pix, 5.5in}
@caption{Vertical and horizontal scroll bars}
@end float

The loader file for the @code{v-scroll-bar} is "v-scroll-loader". The
loader file for the @code{h-scroll-bar} is "h-scroll-loader".

The scroll bar is a common interface object used to specify a desired
position somewhere in a range of possible values. The distance of the
indicator from the top and bottom of its bounding box is a graphical
representation of the currently chosen value, relative to the minimum
and maximum allowed values.

The scroll bars in the Gadget Set, @code{v-scroll-bar} and
@code{h-scroll-bar}, allow the interface designer to specify the minimum
and maximum values of a range, while the @code{:value} slot is a report
of the currently chosen value in the range. The interval is
determined by the values in @code{:val-1} and @code{:val-2}, and either
slot may be the minimum or maximum of the range. The value in
@code{:val-1} will correspond to the top of the vertical scroll bar and
the left of the horizontal scroll bar. The @code{:value} slot may be
accessed directly by some function in the larger interface, and other
formulas in the interface may depend on it. If the @code{:value} slot
is set directly, then the appearance of the scroll bar will be updated
accordingly.


The trill boxes at each end of the scroll bar allow the user to
increment and decrement @code{:value} by precise amounts. The intent of
the two sets of boxes is to give the user a choice between increment
values -- either a conventional scroll of @code{:scr-incr} in the single
arrow box or @code{:page-incr} in the double arrow box. There is no
restriction on whether one value must be larger or smaller than the
other.
@cindex{scr-incr}
@cindex{trill-incr}
@cindex{trill boxes}

In fact, the designer may choose to leave the trill boxes out
completely. The slots @code{:scr-trill-p} and @code{:page-trill-p} may be
set to NIL in order to prevent the appearance of the scroll boxes or
page boxes, respectively.
@cindex{scr-trill-p}
@cindex{page-trill-p}

The indicator may also be moved directly by mouse movements. Dragging
the indicator while the left mouse button is pressed will cause a
thick lined box to follow the mouse. The indicator then moves to the
position of this feedback box when the mouse button is released. If
@code{:int-feedback-p} is set to NIL, the thick lined box will not
appear, and the indicator itself will follow the mouse. A click of
the left mouse button in the background of the scroll bar will cause
the indicator to jump to the position of the mouse.
@cindex{indicator}
@cindex{int-feedback-p}

With each change of the indicator position, the @code{:value} slot is
updated automatically to reflect the new position. The current value
is reported as a text string inside the indicator unless the slot
@code{:indicator-text-p} is set to NIL.

Since the scroll bar must be wide enough to accommodate the widest
text string in its range of values, the width of the vertical scroll
bar (and similarly the height of the horizontal scroll bar) is the
maximum of the width of the widest value and the @code{:min-width}. The
@code{:min-width} will be used if there is no indicator text (i.e.,
@code{:indicator-text-p} is NIL), or if the @code{:min-width} is greater
than the width of the widest value.

The slot @code{:scroll-p} is used to enable and disable the scrolling
feature of the scroll bar. When @code{:scroll-p} is set to NIL, the
trill boxes of the scroll bar become inactive and the background turns
white. This ability to disable scrolling is useful in applications
where the range of the scroll bar is not fixed. For example, in the
@code{scrolling-menu} gadget, the scroll bar is disabled there are not
enough items to fill the entire menu.

The font in which @code{:value} is reported in the indicator may be set
in the slot @code{:indicator-font}.


@section Sliders
@node Sliders
@anchor{sliders}
@cindex{v-slider}
@cindex{h-slider}
@cindex{sliders}

@example
(create-instance 'gg:V-Slider opal:aggregadget
   (:maybe-constant '(:left :top :height :shaft-width :scr-incr :page-incr :val-1 :val-2
                      :num-marks :scr-trill-p :page-trill-p :tic-marks-p :enumerate-p
                      :value-feedback-p :scroll-p :value-feedback-font :enum-font
                      :format-string :enum-format-string :visible))
   (:left 0)
   (:top 0)
   (:height 250)
   (:shaft-width 20)
   (:scr-incr 1)
   (:page-incr 5)
   (:val-1 0)
   (:val-2 100)
   (:num-marks 11)
   (:scr-trill-p T)
   (:page-trill-p T)
   (:tic-marks-p T)
   (:enumerate-p T)
   (:value-feedback-p T)
   (:scroll-p T)
   (:value-feedback-font opal:default-font)
   (:enum-font (create-instance NIL opal:font (:size :small)))
   (:format-string "~a")
   (:enum-format-string "~a")
   (:value (o-formula ...))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example
@sp 1

@example
(create-instance 'gg:H-Slider opal:aggregadget
   (:maybe-constant '(:left :top :width :shaft-height :scr-incr :page-incr :val-1 :val-2
                      :num-marks :tic-marks-p :enumerate-p :scr-trill-p :page-trill-p
                      :scroll-p :value-feedback-p :value-feedback-font :enum-font
                      :format-string :enum-format-string :visible))
   (:left 0)
   (:top 0)
   (:width 300)
   (:shaft-height 20)
   (:scr-incr 1)
   (:page-incr 5)
   (:val-1 0)
   (:val-2 100)
   (:num-marks 11)
   (:tic-marks-p T)
   (:enumerate-p T)
   (:scr-trill-p T)
   (:page-trill-p T)
   (:value-feedback-p T)
   (:scroll-p T)
   (:value-feedback-font opal:default-font)
   (:enum-font (create-instance NIL opal:font (:size :small)))
   (:format-string "~a")
   (:enum-format-string "~a")
   (:value (o-formula ...))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@center @image{slider-pix, 5.5in}

The loader file for the @code{v-slider} is "v-slider-loader".
The loader file for the @code{h-slider} is "h-slider-loader".
@sp 1

The @code{v-slider} and @code{h-slider} gadgets have the same
functionality as scroll bars, but they are used when the context
requires a different style. The slider is comprised of a shaft with
perpendicular tic-marks and an indicator which points to the current
chosen value. Optional trill boxes appear at each end of the slider,
and the indicator can be moved with the same mouse commands as the
scroll bar. The vertical slider has an optional feedback box above
the shaft where the current value is displayed (this box is to the
left of the horizontal slider). The value that appears in the
feedback box may be edited directly by the user by pressing in the
text box with the left mouse button and entering a new
number.@footnote{Backspace and several editing commands are provided
through Interactors. See "Text-Interactor" in the Interactors
Manual.}

The slots @code{:value}, @code{:val-1}, @code{:val-2}, @code{:scr-incr},
@code{:page-incr}, @code{:scr-trill-p}, and @code{:page-trill-p} all have
the same functionality as in scroll bars (see section @ref{scroll-bars}).

The designer may specify the number of tic-marks to appear on the
shaft in the slot @code{:num-marks}. This number includes the tic-marks
at each end of the shaft in addition to the internal tic-marks.
Tic-marks may be left out by setting the @code{:tic-marks-p} slot to
NIL. If the slot @code{:enumerate-p} is set to T, then each tic-mark
will be identified by its position in the range of allowed values.
Also, numbers may appear without tic-marks marks by setting
@code{:enumerate-p} to T and @code{:tic-marks-p} to NIL. The slot in
which to specify the font for the tic-mark numbers is @code{:enum-font}.

The slot @code{:shaft-width} in the vertical slider (analogously,
@code{:shaft-height} in the horizontal slider) is used to specify the
width of the trill boxes at the end of the shaft. This determines the
dimensions of the (invisible) bounding box for the interactors which
manipulate the indicator.

The slot @code{:scroll-p} is used to enable and disable the scrolling
feature of the sliders, just as in the scroll bars. When
@code{:scroll-p} is set to NIL, the trill boxes of the slider become
inactive, and the indicator ceases to move.

The font for the feedback of the current value (which appears at the
end of the shaft) may be specified in @code{:value-feedback-font}. The
value feedback may be left out completely by setting
@code{:value-feedback-p} to NIL.

The @code{:format-string} and @code{:enum-format-string} slots allow you to
control the formatting of the text strings, in case the standard formatting
is not appropriate. This is mainly useful for floating point numbers.
The slots should each contain a string that can be passed to the lisp function
@code{format}. The default string is @code{"~a"}.

@section Trill Device
@node Trill Device
@anchor{trill-device}
@cindex{trill-device}
@cindex{Number input}
@example
(create-instance 'gg:Trill-Device opal:aggregadget
   (:maybe-constant '(:left :top :min-frame-width :min-height :scr-incr :page-incr
                      :val-1 :val-2 :scr-trill-p :page-trill-p :scroll-p
                      :value-feedback-p :format-string :value-feedback-font :visible))
   (:left 0)
   (:top 0)
   (:min-frame-width 20)
   (:min-height 20)
   (:scr-incr 1)
   (:page-incr 5)
   (:val-1 0) (:val-2 100)
   (:scr-trill-p T)
   (:page-trill-p T)
   (:scroll-p T)
   (:value-feedback-p T)
   (:value-feedback-font opal:default-font)
   (:value 20)
   (:format-string "~a")
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@center @image{trill-pix, 5.5in}

The loader file for the @code{trill-device} is "trill-device-loader".

The @code{trill-device} is a compact gadget which allows a value to be
incremented and decremented over a range as in the scroll bars and
sliders, but with only the numerical value as feedback. All slots
function exactly as in horizontal sliders, but without the shaft and
tic-mark features. As with sliders, the feedback value may be edited
by the user.

A unique feature of the trill box is that either or both @code{:val-1}
or @code{:val-2} may be NIL, implying no lower or upper bound on the
input value, respectively. If numerical values for both slots are
supplied, then clipping of the input value into the specified range
occurs as usual. Otherwise, @code{:val-1} is assumed to be the minimum
value, and clipping will not occur at the NIL endpoints of the
interval.

The width of the trill device may be either static or dynamic. If
both @code{:val-1} and @code{:val-2} are specified, then the width of the
value frame is the maximum of the widest allowed value and the
@code{:min-frame-width}. Otherwise, the value frame will expand with
the width of the value, while never falling below
@code{:min-frame-width}.

The height of the trill device is the maximum of the greatest string
height of all values in the range and the value of the slot
@code{:min-height}. The @code{:min-height} will be used if there is no
indicator text or if the @code{:min-height} is greater than the height
of the tallest value.

@sp 1
The @code{:format-string} slot allows you to control the formatting of
the text string, in case the standard formatting is not appropriate.
This is mainly useful for floating point numbers. This slot takes a
string that can be passed to the lisp function @code{format}. The
default string is @code{"~a"}. For example:

@example
(create-instance 'TRILL garnet-gadgets:trill-device
   (:left 35)(:top 70)(:val-1 0.0)(:val-2 1.0)(:scr-incr 0.01)
   (:page-incr 0.1)(:format-string "~4,2F"))
@end example


@section Gauge
@node Gauge
@anchor{gauge}
@cindex{Circular gauge}

@center @image{gauge-pix, 5.5in}

@cindex{gauge}

@example
(create-instance 'gg:Gauge opal:aggregadget
   (:maybe-constant '(:left :top :width :polygon-needle-p :int-feedback-p
		      :title :title-font :value-font :enum-font :num-marks
		      :tic-marks-p :enumerate-p :value-feedback-p :text-offset
		      :val-1 :val-2 :visible))
   (:left 0)
   (:top 0)
   (:width 230)
   (:val-1 0)
   (:val-2 180)
   (:num-marks 10)
   (:tic-marks-p T)
   (:enumerate-p T)
   (:value-feedback-p T)
   (:polygon-needle-p T)
   (:int-feedback-p T)
   (:text-offset 5)
   (:title "Gauge")
   (:title-font opal:default-font)
   (:value-font opal:default-font)
   (:enum-font (create-instance NIL opal:font (:size :small)))
   (:value (o-formula ...))
   (:format-string "~a")       @emph{; How to print the feedback value}          
   (:enum-format-string "~a")  @emph{; How to print the tic-mark values}
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

The loader file for the @code{gauge} is "gauge-loader".

The @code{gauge} object is a semi-circular meter with tic-marks around
the perimeter. As with scroll bars and sliders, this object allows
the user to specify a value between minimum and maximum values. A
needle points to the currently chosen value, and may either be a bare
arrow or a thick, arrow-shaped polygon with a gray filling. The
needle may be rotated by dragging it with the left mouse button
pressed. Text below the gauge reports the current value to which the
needle is pointing.

If the slot @code{:polygon-needle-p} is T, then the needle will be thick
with a gray filling. If NIL, then the needle will be a bare arrow.

If @code{:int-feedback-p} is T, then the needle will not follow the
mouse directly, but instead a short line will appear and be rotated.
When the mouse button is released, the large needle will swing over to
rest at the new location. The needle will follow the mouse directly
if @code{:int-feedback-p} is set to NIL.

The slots @code{:num-marks}, @code{:tic-marks-p}, @code{:enumerate-p}, @code{:val-1},
@code{:val-2}, and @code{:enum-font} are implemented as in the sliders
(see section @ref{sliders}). The value in @code{:val-1} corresponds to
the right side of the gauge.

The title of the gauge is specified in @code{:title}. No title will
appear if @code{:title} is NIL. The fonts for the title of the gauge
and the current chosen value are specified in @code{:title-font} and
@code{:value-font}, respectively.

If @code{:value-feedback-p} is T, then numerical text will appear below the
gauge indicating the currently chosen value. The value in @code{:text-offset}
determines the distance between the gauge and the title string, and between
the title string and the value feedback.

The @code{:format-string} and @code{:enum-format-string} slots allow you to
control the formatting of the text strings, in case the standard formatting
is not appropriate. This is mainly useful for floating point numbers.
The slots should each contain a string that can be passed to the lisp function
@code{format}. The default string is @code{"~a"}.



@section Buttons
@node Buttons
@cindex{buttons}
@anchor{buttons}

The button objects in the Garnet Gadgets can be either a single
stand-alone button, or a panel of buttons. Each button in the set is
related to the others by common interactors and constraints on both
the sizes of the buttons and the text beside (or inside) the buttons.

The button objects all have several common features.

@enumerate
When used as a panel, the buttons are implemented
with aggrelists, so all slots that can be customized in an aggrelist
can be customized in the button panels.@footnote{See the Aggregadgets
manual for greater detail.}  These slots are:
@cindex{aggrelists}
@vtable @code
@code{:direction} --- @code{:vertical} or @code{:horizontal} (default @code{:vertical})

@code{:v-spacing} --- distance between buttons, if vertical orientation (default 5)

@code{:h-spacing} --- same, if horizontal orientation

@code{:fixed-width-p} --- whether all the buttons should have the width of
the value in @code{:fixed-width-size}, or the width of each button
should be determined by the width of the string associated with that
button (default T)

@code{:fixed-height-p} --- same, but with heights

@code{:fixed-width-size} --- width of all components (default is the width
of the widest button, as determined by the widest string)

@code{:fixed-height-size} --- same, but with heights

@code{:h-align} --- How to align buttons, if vertical orientation.
Allowed values are @code{:left}, @code{:center}, or @code{:right}. (default
@code{:right} for radio-buttons and x-buttons, @code{:center} for
text-buttons)

@code{:rank-margin} --- after this many buttons, a new row (or column)
will be started (default NIL)

@code{:pixel-margin} --- absolute position in pixels after which a new row
(or column) will be started (default NIL)

@code{:indent} --- amount to indent the new row (or column) in pixels
(default 0)
@end vtable

In the button and menu objects, the @code{:value} slot contains to the
string or atom of the currently selected item (in the
@code{x-button-panel} this value is a list of selected items). The
currently selected object is named in the @code{:value-obj} slot. In
order to set an item to be selected, either the @code{:value} slot of
the button panel must be set with the desired string or atom from the
@code{:items} list, or the @code{:value-obj} slot must be set with the
desired button object (see section @ref{sel-buttons} for examples of
selecting buttons).
@cindex{value slot}
@cindex{value-obj}

The @code{:width} of the buttons is determined by the width of the
longest item, and therefore cannot be specified by the designer.
However, the @code{:width} is computed internally and may be accessed
after the object is instantiated. (The :height is computed
similarly.)

The shadow below each button has the effect of simulating a floating
three-dimensional button. When the left mouse button is clicked on
one of the gadget buttons, the button frame moves onto the shadow and
appears to be depressed. The slot @code{:shadow-offset} specifies the
amount of shadow that appears under the button when it is not pressed.
A value of zero implies that no shadow will appear (i.e., no floating
effect).

There is a gray border in the frame of each of the buttons, the width
of which may be specified in the slot @code{:gray-width}.

The strings or atoms associated with each button are specified in the
@code{:items} slot. See section @ref{items-slot} for a discussion of
specifying items and item functions.
@cindex{items slot}
@cindex{item functions}

The font in which the button labels appear may be specified in the
@code{:font} slot.

Most of the buttons and button panels have a @code{:toggle-p} slot.
When the value of this slot is T, then the button will become
deselected if it is clicked a second time. Otherwise, after the
button is selected the first time, it is always selected (though its
@code{:selection-function} and associated item functions will continue
to be executed each time it is pressed.
@end enumerate

@float Figure, fig:ex2
@center @image{button-pix, 5.5in}
@caption{Text buttons, radio buttons, and x-buttons}
@anchor{button-pix}
@end float
@cindex{buttons}

@subsection Text Buttons
@node Text Buttons
@anchor{text-buttons}
@cindex{text-button}
@example
(create-instance 'gg:Text-Button opal:aggregadget
   (:maybe-constant '(:left :top :shadow-offset :text-offset :gray-width
		      :string :toggle-p :font :final-feedback-p :visible))
   (:left 0)
   (:top 0)
   (:shadow-offset 10)
   (:text-offset 5)
   (:gray-width 5)
   (:string "Text Button")
   (:toggle-p T)
   (:font opal:default-font)
   (:final-feedback-p T)
   (:value (o-formula (if (gvl :selected) (gvl :string))))
   (:selected (o-formula (gvl :value)))   ;@emph{ This slot is set by the interactor}
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example
@sp 1

@cindex{text-button-panel}
@example
(create-instance 'gg:Text-Button-Panel opal:aggregadget
   (:maybe-constant '(:left :top :direction :v-spacing :h-spacing :h-align
		      :fixed-width-p :fixed-width-size :fixed-height-p
		      :fixed-height-size :indent :rank-margin :pixel-margin
		      :shadow-offset :text-offset :gray-width :final-feedback-p
		      :toggle-p :font :items :visible))
   (:left 0)
   (:top 0)
   (:shadow-offset 10)
   (:text-offset 5)
   (:gray-width 5)
   (:final-feedback-p T)
   (:toggle-p NIL)
   (:font opal:default-font)
   (:items '("Text 1" "Text 2" "Text 3" "Text 4"))
   (:value-obj NIL)
   (:value (o-formula (gvl :value-obj :string)))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   <All customizable slots of an aggrelist>)
@end example

@sp 1
The loader file for the @code{text-button} and
@code{text-button-panel} is "text-buttons-loader".

The @code{text-button-panel} object is a set of rectangular buttons,
with the string or atom associated with each button centered inside.
When a button is pressed, the text of the button will appear in
inverse video if @code{:final-feedback-p} is T. The @code{text-button} is
just a single button.

The distance from the beginning of the longest label to the inside
edge of the button frame is specified in @code{:text-offset}. The value
in @code{:text-offset} will affect the height and width of every button
when specified.

@subsection X Buttons
@node X Buttons
@anchor{x-buttons}
@cindex{x-button}
@example
(create-instance 'gg:X-Button opal:aggregadget
   (:maybe-constant '(:left :top :button-width :button-height
		      :shadow-offset :text-offset :gray-width
		      :text-on-left-p :toggle-p :string :font :visible))
   (:left 0)
   (:top 0)
   (:button-width 20)
   (:button-height 20)
   (:shadow-offset 5)
   (:text-offset 5)
   (:gray-width 3)
   (:text-on-left-p T)
   (:string "X Button")
   (:toggle-p T)
   (:font opal:default-font)
   (:value (o-formula (if (gvl :selected) (gvl :string))))
   (:selected (o-formula (gvl :value))) @emph{; Set by interactor}
   (:selection-function NIL)            @emph{; (lambda (gadget value))}
   )
@end example
@sp 1

@cindex{x-button-panel}
@example
(create-instance 'gg:X-Button-Panel opal:aggregadget
   (:maybe-constant '(:left :top :direction :v-spacing :h-spacing :h-align
		      :fixed-width-p :fixed-width-size :fixed-height-p :fixed-height-size
                      :indent :rank-margin :pixel-margin :button-width :button-height
                      :shadow-offset :text-offset :gray-width :text-on-left-p
		      :font :items :visible))
   (:left 0)
   (:top 0)
   (:button-width 20)
   (:button-height 20)
   (:shadow-offset 5)
   (:text-offset 5)
   (:gray-width 3)
   (:text-on-left-p T)
   (:font opal:default-font)
   (:items '("X-label 1" "X-label 2" "X-label 3"))
   (:value-obj NIL)
   (:value (o-formula (mapcar #'(lambda (object)
				  (gv object :string))
			      (gvl :value-obj))))
   (:selection-function NIL)  @emph{; (lambda (gadget value))}
   <All customizable slots of an aggrelist>)
@end example

@sp 1
The loader file for the @code{x-button} and @code{x-button-panel} is
"x-buttons-loader".

The @code{x-button-panel} object is also a set of rectangular buttons,
but the item associated with each button appears either to the left or
to the right of the button. Any number of buttons may be selected at
one time, and clicking on a selected button de-selects it. Currently
selected buttons are graphically indicated by the presence of a large
"X" in the button frames. The @code{x-button} is just a single button.

Since the @code{x-button-panel} allows selection of several items at
once, the @code{:value} slot is a list of strings (or atoms), rather
than a single string. Similarly, @code{:value-obj} is a list of
objects.

The slot @code{:text-on-left-p} specifies whether the text will appear
on the right or left of the x-buttons. A NIL value indicates the text
should appear on the right. When text appears on the right, the designer
will probably want to set @code{:h-align} to @code{:left} in order to left-justify
the text against the buttons.

The distance from the labels to the buttons is specified in
@code{:text-offset}.

The slots @code{:button-width} and @code{:button-height} specify the width
and height of the x-buttons. The "X" will stretch to accommodate
these dimensions.

@subsection Radio Buttons
@node Radio Buttons
@anchor{radio-buttons}
@cindex{radio-button}
@example
(create-instance 'gg:Radio-Button opal:aggregadget
   (:maybe-constant '(:left :top :button-diameter :shadow-offset :text-offset
                      :gray-width :string :text-on-left-p :toggle-p :font :visible))
   (:left 0) (:top 0)
   (:button-diameter 23)
   (:shadow-offset 5) (:text-offset 5) (:gray-width 3)
   (:string "Radio button")
   (:toggle-p T)
   (:text-on-left-p T)
   (:font opal:default-font)
   (:value (o-formula (if (gvl :selected) (gvl :string))))
   (:selected (o-formula (gvl :value))) @emph{; Set by interactor}
   (:selection-function NIL)            @emph{; (lambda (gadget value))}
   )
@end example
@sp 1

@cindex{radio-button-panel}
@example
(create-instance 'gg:Radio-Button-Panel opal:aggregadget
   (:maybe-constant '(:left :top :direction :v-spacing :h-spacing :h-align
                      :fixed-width-p :fixed-width-size :fixed-height-p :fixed-height-size
                      :indent :rank-margin :pixel-margin :button-diameter :shadow-offset
                      :text-offset :gray-width :text-on-left-p :toggle-p :font
                      :items :visible))
   (:left 0)
   (:top 0)
   (:button-diameter 23)
   (:shadow-offset 5)
   (:text-offset 5)
   (:gray-width 3)
   (:text-on-left-p T)
   (:toggle-p T)
   (:font opal:default-font)
   (:items '("Radio-text 1" "Radio-text 2" "Radio-text 3" "Radio-text 4"))
   (:value-obj NIL)
   (:value (o-formula (gvl :value-obj :string)))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   <All customizable slots of an aggrelist>)
@end example

@sp 1
The loader file for the @code{radio-button} and @code{radio-button-panel} is
"radio-buttons-loader".

The @code{radio-button-panel} is a set of circular buttons with items
appearing to either the left or right of the buttons (implementation
of @code{:text-on-left-p} and @code{:text-offset} is identical to
x-buttons). Only one button may be selected at a time, with an
inverse circle indicating the currently selected button. A
@code{radio-button} is a single button.


@section Option Button
@node Option Button
@anchor{option-button}
@cindex{option-button}

@example
(create-instance 'gg:Option-Button opal:aggregadget
  (:maybe-constant '(:left :top :text-offset :label :button-offset :button-shadow-offset
                     :items :initial-item :button-font :label-font :button-fixed-width-p
                     :v-spacing :keep-menu-in-screen-p :menu-h-align))
  (:left 40) (:top 40)
  (:text-offset 4)
  (:label "Option button:")
  (:button-offset 10)
  (:button-shadow-offset 5)
  (:items '("Item 1" "Item 2" "Item 3" "Item 4"))
  (:initial-item (o-formula (first (gvl :items))))
  (:button-font opal:default-font)
  (:label-font (opal:get-standard-font NIL :bold NIL))
  (:value (o-formula (gvl :option-text-button :string)))
  (:button-fixed-width-p T)
  (:v-spacing 0)
  (:menu-h-align :left)
  (:keep-menu-in-screen-p T)
  (:selection-function NIL)   @emph{; (lambda (gadget value))}
  ...)
@end example

@float Figure, fig:ex2
@center @image{option-button-normal, 5.5in}

@center @image{option-button-pressed, 5.5in}


@caption{An option button in its normal state (left), and showing the
available options after the button is pressed (right).}
@anchor{option-button-tag}
@end float

The loader file for the @code{option-button} is "option-button-loader".

When the left mouse button
is clicked and held on an option button, a menu will pop up, from
which items can be selected by moving the pointer to the desired item
and releasing the mouse button.
Figure @ref{option-button-tag} shows an option button in its normal
state (on the left) and when the button is pressed.

The @code{:items} slot is a list of strings or Garnet objects, which will
appear in the menu. The @code{:initial-item} slot contains the initial item
that will appear in the button. This slot MUST be non-NIL, and should contain
either an element of the @code{:items} list, or a formula to calculate the same.

The @code{:text-offset} slot specifies how far from the frame the text should
begin. The slot @code{:button-offset} specifies how far from the label the
button should begin. The @code{:button-shadow-offset} contains the size of the
button's shadow.

The @code{:label} slot contains a string that appears before the option
button. If no label is desired, this slot can be set to the empty string, "".

The @code{:button-font} and @code{:label-font} slots specify the fonts to use
in the button and the label. The font of the items in the menu is the
same as the font in the @code{:button-font} slot.

The @code{:value} slot contains the currently selected item, which is the
same as the value in the @code{:string} slot of the button.

The @code{:button-fixed-width-p} slot specifies whether to keep the button's
width constant or not. If it is set to T, the button's width will be
the width of the longest string in the @code{:items} slot. If it is set to
NIL, the width of the button will be the width of the currently
selected item. 

The value in @code{:v-spacing} specifies the amount of space between each menu
item.

The @code{:menu-h-align} slot should be either @code{:left}, @code{:center}, or
@code{:right}, and specifies the justification of the menu items.

If the @code{:keep-menu-in-screen-p} slot is T, then the menu will never pop
out of the screen, i.e., the top of the menu will never be less than
the screen's top, and the bottom of the menu will never be greater
than the screen's bottom. If this slot is set to NIL, the menu may
pop out of the top or out of the bottom of the screen.
NOTE: If the number of items in the menu makes it so that both the top
of the menu and the bottom of the menu are out of the screen, this
slot will be disregarded.



@section Popup-Menu-Button
@node Popup-Menu-Button
@anchor{popup-menu-button}
@cindex{popup-menu-button}
@center @image{popupmenubutton, 5.5in}

@example
(create-instance 'gg:Popup-Menu-Button gg:text-button
  (:left 0)
  (:top 0)
  (:string gg:lines-bitmap)
  (:items '("Item 1" "Item 2" "Item 3" "Item 4"))
  (:v-spacing 0)
  (:h-align :LEFT)
  (:item-font opal:default-font)
  (:item-to-string-function
   #'(lambda (item)
       (if item
	   (if (or (stringp item) (schema-p item))
	       item
	       (string-capitalize (string-trim ":" item)))
	   "")))
  (:min-menu-width 0) 
  (:shadow-offset 2)
  (:text-offset 3)
  (:gray-width 2)
  (:selection-function NIL)   @emph{; (lambda (gadget value))}
  (:value (o-formula ...))
  (:position :below)
  (:keep-menu-in-screen-p T)
@end example

The loader file for the @code{popup-menu-button} is
@code{popup-menu-button-loader}, and you can see a demo by executing
@code{(gg:popup-menu-button-go)}. (Sorry, there isn't a Motif version
yet.)

This is a combination of a button and a popup menu. When you press on
the button, the menu is shown, and then you can select something from
the menu, and then the menu disappears. If you release outside of the
menu, the menu just goes away and keeps its current value. The button
itself can show a string or an arbitrary Garnet object (e.g., a
bitmap, as shown here).

The @code{:left} and @code{:top} determine when the button goes.

@cindex{lines-bitmap}
@cindex{downarrow-bitmap}
The @code{:string} slot determines what is shown in the button. It can
be a regular string (e.g., @code{"Value"}) or an arbitrary Garnet
object. The default value is the @code{gg:lines-bitmap} shown above.
Another bitmap provided is @code{gg:downarrow-bitmap} which looks like
@center @image{downarrowpopup, 5.5in}

The @code{:items} slot holds the items that are shown in the popup menu.
It can have the standard format for items (e.g., a list of strings,
objects, pairs of strings and functions, etc.). See section @ref{items-slot}
for more information.

The @code{:v-spacing, :h-align,} and @code{:item-font} control the display
of the menu items. See the Gadgets manual for menus for more information.

The @code{:min-menu-width} slot can contain a minimum width for the popup menu.
You might use this to make the menu line up with a text entry field.

The @code{:item-to-string-function} can be used to convert the values in
the @code{:items} list into strings.

The @code{:shadow-offset}, @code{:text-offset} and @code{:gray-width}
parameters control the appearance of the button itself.

When the user selects a menu item, the @code{:selection-function} is
called with parameters:@* @code{(lambda (gadget value))}, where the gadget is
the popup-menu-button and the value is the appropriate item from
@code{:items}. The @code{:value} slot will also be set with the
appropriate item.

The position of the menu with respect to the button is controlled by
the @code{:position} parameter. Legal options are:
@vtable @code
@code{:below} - the menu is below and left justified with the button
(the default).

@code{:left} - the menu will be centered vertically at the left of the button.

@code{:right} - the menu will be centered vertically at the right of the button.

a list of two numbers (x y) - the menu will be at this location. The
@code{:position} slot can contain a formula that calculates these
numbers.
@end vtable

If @code{:keep-menu-in-screen-p} is non-NIL, then the position computed
based on the @code{:position} argument will be adjusted so the menu
always stays in the screen. Otherwise, the menu might extend off the
screen edges.



@section Menu
@node Menu
@anchor{menu}
@cindex{Menu}
@example
(create-instance 'gg:Menu opal:aggregadget
   (:maybe-constant '(:left :top :v-spacing :h-align :shadow-offset
		      :text-offset :title :title-font :items :item-font
		      :item-to-string-function :visible))
   (:left 0)
   (:top 0) 
   (:v-spacing 0)
   (:h-align :left)
   (:shadow-offset 5)
   (:text-offset 4)
   (:min-menu-width 0)
   (:title NIL)
   (:title-font (create-instance NIL opal:font
                   (:family :serif)
		   (:size :large)
		   (:face :roman)))
   (:items '("Item 1" "Item 2" "Item 3" "Item 4"))
   (:item-font opal:default-font)
   (:item-to-string-function #'(lambda (item)
				 (if item
				     (if (or (stringp item) (schema-p item))
					 item
				       (string-capitalize (string-trim ":" item)))
				   "")))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   (:value-obj NIL)
   (:value (o-formula (gvl :value-obj :string))))
@end example


@center @image{menu-pix, 5.5in}

The loader file for the @code{menu} is "menu-loader".

The @code{menu} object is a set of text items surrounded by a
rectangular frame, with an optional title above the items in inverse
video. When an item is selected, a box is momentarily drawn around
the item and associated item functions and global functions are
executed.

The @code{:items} slot may be a list of strings, atoms, string/function
pairs or atom/function pairs, as with buttons (see section
@ref{buttons}). If this slot is @code{s-value}'d with a new list of items,
the components of the gadget will be adjusted automatically during the next
call to @code{opal:update}.

The amount of shadow that appears below the menu frame (the menu frame
is stationary) is specified in @code{:shadow-offset}. A value of zero
implies that no shadow will appear.

The slot @code{:h-align} determines how the menu items are justified in
the frame. Allowed values are @code{:left}, @code{:center} and
@code{:right}.

The slot @code{:text-offset} is the margin spacing -- the distance from
the frame to the longest string.

The slot @code{:item-font} determines the font in which the items will
appear.

A title for the menu may be specified as a string in the @code{:title}
slot. If @code{:title} is NIL, then no title will appear. The font in
which the title should appear is specified in @code{:title-font}.


@cindex{item-to-string-function} The @code{:items} slot may be a list of
any objects, including strings, atoms, schemas, string/function pairs,
etc. The default scrolling menu assumes that @code{:items} contains a
list as described in section @ref{buttons}, but this can be easily
changed by the designer. A function defined in
@code{:item-to-string-function} takes an item (or the first element of
an item pair) and returns a string corresponding to that item for
display in the menu. The default function for this slot is

@example
(lambda (item)
  (if item
      (if (stringp item)
	  item
	  (string-capitalize (string-trim ":" item)))
      ""))
@end example

This function takes an item and returns it if it is a string, or
coerces it into a string if it was an atom. See section @ref{sm-ex}
for an example where the @code{:items} list is composed of Garnet
schemas.

@section Scrolling Menu
@node Scrolling Menu
@anchor{scrolling-menu}
@cindex{Scrolling menu}
@center @image{scrolling-menu-pix, 5.5in}

@example

(create-instance 'gg:Scrolling-Menu opal:aggregadget
   (:maybe-constant '(:left :top :scroll-on-left-p :min-scroll-bar-width :scr-trill-p
                      :page-trill-p :indicator-text-p :scr-incr :page-incr
                      :int-scroll-feedback-p :indicator-font :min-frame-width :v-spacing
                      :h-align :multiple-p :items :item-to-string-function :item-font
                      :num-visible :int-menu-feedback-p :final-feedback-p :text-offset
                      :title :title-font :visible))
   (:left 0) (:top 0)

   @emph{;; Scroll bar slots}
   (:scroll-on-left-p T)
   (:min-scroll-bar-width 20)
   (:scr-trill-p T)
   (:page-trill-p T)
   (:indicator-text-p NIL)
   (:scr-incr 1)
   (:page-incr 5)
   (:int-scroll-feedback-p NIL)
   (:indicator-font (create-instance NIL opal:font (:size :small)))
   (:scroll-selection-function NIL)

   @emph{;; Menu slots}
   (:min-frame-width 0)
   (:v-spacing 6)
   (:h-align :left)
   (:multiple-p T)
   (:toggle-p T)
   (:items '("Item 1" "Item 2" "Item 3" ... "Item 20"))
   (:item-to-string-function
       #'(lambda (item)
           (if item
               (if (stringp item)
                   item
                   (string-capitalize (string-trim ":" item)))
               "")))
   (:item-font opal:default-font)
   (:num-visible 5)
   (:int-menu-feedback-p T)
   (:final-feedback-p T)
   (:text-offset 4)
   (:title NIL)
   (:title-font (create-instance NIL opal:font
		   (:family :serif)
		   (:size :large)
		   (:face :roman)))
   (:menu-selection-function NIL)
   (:selected-ranks NIL)
   (:value (o-formula ...)))
@end example

The loader file for the @code{scrolling-menu} gadget is "scrolling-menu-loader".

The @code{scrolling-menu} object is a combination of a vertical scroll
bar and a menu which allows the user to only see a subset of the
available choices in a menu at one time. The set of visible choices
is changed by moving the scroll bar, which causes the choices to
scroll up or down in the menu.

@subsection Scroll Bar Control
@node Scroll Bar ControlIf the slot @code{:scroll-on-left-p} is
T, then the scroll bar will appear on the left side of the menu.
Otherwise, the scroll bar will be on the right.

The slot @code{:min-scroll-bar-width} determines the minimum width of
the scroll bar. The scroll bar will be wider than this width only if
the indicator text is too wide to fit into this width.

The interim feedback of the scroll bar is controlled by the slot
@code{:int-scroll-feedback-p}. If this slot is set to T, then a
thick-lined box will follow the mouse when the user drags the
indicator. Otherwise, the indicator will follow the mouse directly.

A function may be specified in @code{:scroll-selection-function} to be
executed whenever the user changes the scroll bar, either by clicking
on the trill boxes or by dragging the indicator. The function takes
the same parameters as the usual selection function described in
section @ref{sel-fn}.

The slots @code{:scr-trill-p}, @code{:page-trill-p}, @code{:scr-incr},
@code{:page-incr}, @code{:indicator-text-p}, and @code{:indicator-font} are
all used for the scroll bar in the scrolling menu in the same way as
the vertical scroll bar described in section @ref{scroll-bars}.

@subsection Menu Control
@node Menu ControlThe minimum width of the scrolling menu
frame is determined by @code{:min-frame-width}. The scrolling menu will
appear wider than this value only if the title or the longest item
string will not fit in a menu of this width.

The @code{:v-spacing} slot determines the distance between each item in
the menu.

The justification of the items in the menu is determined by the slot
@code{:h-align} which may be either @code{:left}, @code{:center}, or
@code{:right}.

If the value of @code{:multiple-p} is T, then the user may make multiple
selections in the menu by clicking on items while holding down the
shift key. If this slot is NIL, then only single selections are
permitted.

The @code{:toggle-p} slot specifies whether to toggle the current selection when
it is clicked on again. If @code{:toggle-p} is NIL, then a selected item can
be clicked upon for any number of times and it will stay selected. If the
@code{:toggle-p} slot is set to T (the default), clicking on an already selected
item will cause the item to become unselected. NOTE: Clicking on a selected
item while doing multiple selections will always toggle the selection,
regardless of the value of the @code{:toggle-p} slot.

The @code{:item-to-string-function} slot is identical in operation to the one
described for the @code{gg:menu} in section @ref{menu}.
If the @code{:items} slot does not contain a list of the usual items or
item/function pairs, then this function should return the conversion of each
element into a valid item.
The default @code{:item-to-string-function} assumes that the @code{:items} list
is composed of the usual items or item/function pairs.

The slot @code{:num-visible} determines how many items should be visible
in the menu at one time.

A box will appear around the item being selected while the mouse
button is held down if the slot @code{:int-menu-feedback-p} is T.

Selected items will appear in inverse video if the slot
@code{:final-feedback-p} is set to T.

The slot @code{:text-offset} determines the distance from each string to
the menu frame.

A title will appear above the menu if a title string is specified in
@code{:title}. If @code{:title} is NIL, then no title will appear. The
font of the title is in @code{:title-font}.

The font of the items is in @code{:item-font}.

The @code{:selected-ranks} slot is used by the designer to select items
in the menu. The slot contains a list of indices which correspond to
the ranks of the selected items in the @code{:items} list. The ranks
are zero-based. For example, if the @code{:selected-ranks} slot
contained @code{'(0 3)}, then the first and fourth items (not
necessarily visible) in the scrolling menu will be selected.

A function defined in @code{:menu-selection-function} will be executed
whenever the user selects an item from the menu. This function takes
two parameters,
@example
(lambda (gadget scrolling-menu-item))
@end example
 where @emph{gadget} is the programmer's instance of
the @code{scrolling-menu} and @emph{scrolling-menu-item} is the object just
selected by the user. The item associated with the user's selection
can be obtained through the @code{:item} slot of the
@emph{scrolling-menu-item}:
@example
(gv scrolling-menu-item :item) @emph{--> The item just selected}
@end example


@section Menubar
@node Menubar
@anchor{menubar}
@cindex{pull-down menus}
@cindex{menubar}
@cindex{bar-item}
@cindex{submenu-item}

@example
(create-instance 'gg:Menubar opal:aggrelist
   (:left 0)(:top 0)
   (:items NIL)
   (:title-font (create-instance NIL opal:font (:size :large)))
   (:item-font (create-instance NIL opal:font (:face :italic)))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@float Figure, fig:ex2
@center @image{menubar-pix, 5.5in}
@caption{Picture of a pull-down menu (an instance of @code{menubar})}
@anchor{menubar-pix-1}
@end float

The @code{menubar} gadget is a set of pull down menus that is similar to
the Macintosh design. When the user clicks on an inverse bar item,
a submenu pops up and the user can then choose one of the displayed
items.

@b{NOTE:}  There is no @code{:value} slot in this gadget. The designer should
define functions in the @code{:selection-function} or @code{:items} slots to
propagate the user's selections to the rest of the interface (see below).

The complete @code{menubar} gadget is a collection of three objects.
In addition to the top-level @code{menubar} object, there are @code{bar-item}
and @code{submenu-item} objects. The @code{menubar} is an aggrelist of
@code{bar-item} objects, which are the inverse-video text objects that appear
horizontally at the top of the window. The @code{submenu-item} objects are
vertically arranged in an aggrelist within each @code{bar-item}. 

The programmer may approach the @code{menubar} from two perspectives:  the
traditional Garnet way which involves setting the @code{:items} slot and allowing
the gadget to maintain its own components, or from a bottom-up approach which
involves creating the sub-objects and manually adding (and removing) them
from the @code{menubar} instance.

Programmers who choose the Garnet approach can ignore most of the functions
described below, since interaction with the @code{menubar} will
almost exclusively involve setting the @code{:items} slot. The other approach
requires creating instances of @code{bar-item} and @code{submenu-item} gadgets
and adding them as components to a @code{menubar} using the support functions.


@subsection Item Selection Functions
@node Item Selection Functions
@anchor{item-selection-functions}

There are three levels of functions in the @code{menubar} gadget that may be
called when the user makes a selection. Functions
can be attached to individual submenu-items, whole submenus, or the top-level
@code{menubar}. All three types of functions take the parameters
@code{(lambda (gadget menu-item submenu-item))}

When a function is supplied in the @code{:selection-function} slot of the
@code{menubar}, it will be executed whenever any item is selected from any
of the submenus. If a function is attached to a submenu (e.g., it is the
value for @emph{m1func} in the @code{:items} syntax of section
@ref{garnet-menubar-programming}), then it is executed when any item is
chosen from that submenu. If a function is attached to a submenu-item
(e.g., @emph{mX,Yfunc}), then it is executed only when that submenu-item is
selected.

The order for calling these functions is:  first, the submenu function is
called, then the submenu-item function is called, and finally the
@code{:selection-function} is called.



@subsection Programming the Menubar in the Traditional Garnet Way
@node Programming the Menubar in the Traditional Garnet Way
@anchor{garnet-menubar-programming}

The @code{:items} slot of the @code{menubar} is a complicated list with the
following format:
@example
(:items '(("m1" m1func (("m1,1" [m1,1func])...("m1,N" [m1,Nfunc])))
          ("m2" m2func (("m2,1" [m2,1func])...("m2,N" [m2,Nfunc])))
          ...))
@end example
where @emph{"mN"} is a string or atom that is the title of a menu (atoms 
appear as capitalized strings in the submenu titles),
@emph{"mX,Y"}
is a string or atom in menu X, row Y, @emph{mNfunc} is executed when any item in
menu N is selected, and @emph{mX,Yfunc} is executed when item @emph{"mX,Y"} is
selected. See section @ref{item-selection-functions} for the parameters of
these functions. NOTE:  the syntax above requires that the submenu-items be
described with lists, even when no submenu-item functions are supplied (i.e.,
the list @code{("m1,1")} is required instead of just the string @code{"m1,1"}).

In order to maintain the syntax of the sublists, the submenu functions
(@emph{m1func} and @emph{m2func} above) must always be supplied.
Thus, NIL should be placed in this position if no function is
to be executed for the submenu. The submenu-item functions (@emph{m1,1func} etc.
above) are optional and may be omitted.

The @code{:title-font} is the font for the @code{bar-item} objects which appear
in inverse video, and the @code{:item-font} is the font for the
@code{submenu-item} objects arranged vertically in the pop-up menus.


@subsection An example
@node An example

@float Figure, fig:ex2
@example

(create-instance 'WIN inter:interactor-window
   (:left 750)(:top 80)(:width 200)(:height 200)
   (:title "Menubar Example"))
(s-value WIN :aggregate (create-instance 'TOP-AGG opal:aggregate))
(opal:update win)

(defun Fixed-Fn (gadget menu-item submenu-item)
  (format t "Calling Fixed-Fn with ~S ~S ~S.~%" gadget menu-item submenu-item))

(defun Face-Fn (gadget menu-item submenu-item)
  (format t "Calling Face-Fn with ~S ~S ~S.~%" gadget menu-item submenu-item))

(create-instance 'DEMO-MENUBAR garnet-gadgets:menubar
   (:items
    '(("family" NIL
       (("fixed" Fixed-Fn)("serif")("sans-serif")))
      ("face" Face-Fn
       (("roman")("bold")("italic")("bold-italic")))
      ("size" NIL
       (("small")("medium")("large")("very-large"))))))

(opal:add-component TOP-AGG DEMO-MENUBAR)
(opal:update win)

@end example
@caption{The code to generate the picture in Figure @ref{menubar-pix-1}}
@anchor{menubar-code-1}
@end float

The code in Figure @ref{menubar-code-1} creates the @code{menubar} picture
shown in Figure @ref{menubar-pix-1}. It illustrates the Garnet method for
handling the @code{menubar} gadget.

@subsection Adding items to the menubar
@node Adding items to the menubar
@cindex{Add-item", Secondary="Menubar}
@cindex{add-submenu-item}

There are two types of items that can be added to a @code{menubar}:  an entire
submenu can be added to the top-level @code{menubar}, or single submenu-item can
be added to a submenu.

The @code{add-item} method for the @code{menubar} can be used to add submenus --
@code{opal:Add-Item @i{menubar submenu} [[:where] @i{position [locator]} [:key @i{index-function}]]@ref{method}}
Using the standard Garnet method, the @emph{submenu}
parameter should be a sublist of a top-level items list,
@* (e.g., @code{'("underline" NIL (("none") ("single") ("double")))}.
The remaining
optional parameters follow the standard @code{add-item} definition described in
the Aggregadgets manual, and refer to the placement of the new submenu among
the existing submenus. @emph{Locator} should be some element of the current
@emph{:items} list, or may be the title of a submenu when the @emph{index-function}
is @code{#'car} (see examples below).

For example, each of the following lines will add a new submenu to
DEMO-MENUBAR in Figure @ref{menubar-code-1}:
@example
(opal:add-item DEMO-MENUBAR '("font-name" NIL (("courier") ("times") ("geneva"))))
(opal:add-item DEMO-MENUBAR
               '("other-fonts" NIL (("helvetica") ("chicago")))
	       :after '("family" NIL (("fixed" Fixed-Fn)("serif")("sans-serif"))))
(opal:add-item DEMO-MENUBAR
               '("symbols" NIL (("mathematical") ("greek")))
	       :before "face" :key #'car)
@end example

Individual submenu-items can be added to a @code{menubar} with the following
function:
@example
add-submenu-item @i{menubar submenu-title submenu-item} [[:where] @i{position [locator]} [:key @i{index-function}]])
@end example
This function adds the new @emph{submenu-item} to the menubar, and places it in
the submenu named by @emph{submenu-title}. The new @emph{submenu-item} description
should be a list containing a string (or atom) and an optional function
(e.g., @code{'("italic")} or @code{'("italic" italic-fn)}).

For example, the following lines will add new submenu-items to the
DEMO-MENUBAR in Figure @ref{menubar-code-1}:
@example
(garnet-gadgets:add-submenu-item DEMO-MENUBAR "face" '("outline"))
(garnet-gadgets:add-submenu-item DEMO-MENUBAR "size" '("very small")
                                              :before "small" :key #'car)
@end example
As shown in the second example, the @emph{position} and @emph{locator} parameters
should correspond to existing submenu items.


@subsection Removing items from the menubar
@node Removing items from the menubar
@cindex{remove-item}
@cindex{remove-submenu-item}

Just as submenus and submenu-items can be added to the @code{menubar}, these
two types of items can be removed. 

@code{opal:Remove-Item @i{menubar submenu}@ref{method}}
This function removes the @emph{submenu} from @emph{menubar}. For traditional
Garnet programming, the @emph{submenu} should be a sublist of the top-level
@code{:items} list, or just the title of a submenu (a string or atom).

For example, the following lines will remove an item from the DEMO-MENUBAR
in Figure @ref{menubar-code-1}:
@example
(opal:remove-item DEMO-MENUBAR
                  '("face" Face-Fn (("roman")("bold")("italic")("bold-italic"))))
(opal:remove-item DEMO-MENUBAR "size")
@end example

The following function is used to remove submenu-items from a @code{menubar}:

@code{gg:Remove-Submenu-Item @i{menubar submenu-title submenu-item}@ref{function}}
@emph{Submenu-item} may either be the list description of the submenu-item
(i.e., @code{("italic")}) or just the string (or atom) of the submenu-item
(i.e., @code{"italic"}).

For example,
@code{(garnet-gadgets:remove-submenu-item DEMO-MENUBAR "size" "small")}


@subsection Programming the Menubar with Components
@node Programming the Menubar with Components

In the bottom-up approach to programming the @code{menubar}, the user must
create components of the @code{menubar} (i.e., instances of @code{bar-item} and
@code{submenu-item} gadgets) and attach them piece-by-piece. This design is
loosely based on the interface to the Macintosh menubar in Macintosh Common
Lisp. The functions
for creating the components are described in section
@ref{creating-menubar-components}. Section
@ref{adding-menubar-components} explains how to attach these components to
the @code{menubar}.


@subsection An example
@node An example

@float Figure, fig:ex2
@example

(create-instance 'WIN inter:interactor-window
   (:left 750)(:top 80)(:width 200)(:height 200)
   (:title "Menubar Example"))
(s-value WIN :aggregate (create-instance 'TOP-AGG opal:aggregate))
(opal:update win)

@emph{; Create the menubar and the bar-item}
(setf demo-menubar (garnet-gadgets:make-menubar))
(setf mac-bar (garnet-gadgets:make-bar-item :title "Mac Fonts"))

@emph{; Create submenu-items}
(setf sub-1 (garnet-gadgets:make-submenu-item :desc '("Gothic")))
(setf sub-2 (garnet-gadgets:make-submenu-item :desc '("Venice")))
(setf sub-3 (garnet-gadgets:make-submenu-item :desc '("Old English")))

@emph{; Add the submenu-items to the bar-item}
(opal:add-item mac-bar sub-1)
(opal:add-item mac-bar sub-2 :before sub-1)
(opal:add-item mac-bar sub-3 :after "Venice" :key #'car)
	
@emph{; Add the menubar to the top-level aggregate}
(opal:add-component TOP-AGG demo-menubar)

@emph{; Add the bar-item to the menubar and update the window}
(opal:add-item demo-menubar mac-bar)
(opal:update win)

@end example
@caption{The creation of a menubar and its components}
@anchor{menubar-code-2}
@end float

The code in Figure @ref{menubar-code-2} creates a @code{menubar} and several
component pieces, and then attaches the components to the @code{menubar}. This
illustrates the bottom-up approach to programming the @code{menubar}.

Notice that the @code{menubar} instance must be added to the top-level aggregate
before any bar-items are attached. This ensures that the @code{menubar} will
be initialized with the proper main window before new submenu windows are
added.


@subsection Creating components of the menubar
@node Creating components of the menubar
@anchor{creating-menubar-components}

The functions in this section are used to create the three types of components
that comprise a pull-down menu -- the @code{menubar} (the top-level part),
the @code{bar-item} (which contains a submenu), and the @code{submenu-item}.
Once the parts of the pull-down menu are created, they are attached using
the functions of section @ref{adding-menubar-components}. Please see section
@ref{adding-menubar-components} for examples of the creation functions
and attachment functions together.


@defun gg:make-menubar

Returns an instance of @code{menubar}.
@end defun

@cindex{make-bar-item}
@defun gg:make-bar-item &key desc font title
this function returns an instance of @code{bar-item}. If any of the keys are
supplied, then the corresponding slots of the @code{bar-item} instance are
set with those values. The @emph{desc} parameter is the description of a
submenu (e.g., @code{'("underline" NIL (("none")("single")("double")))}).
The @emph{font} is the font of the submenu-items within the submenu, and @emph{title}
is a string or atom that will be the heading of the submenu. If the title was
already specified in the @emph{desc} parameter, then no @emph{title} parameter should
be supplied.
@end defun

@cindex{make-submenu-item}
@defun gg:make-submenu-item &key desc enabled
this function returns an instance of @code{submenu-item}. If any of the
keys are supplied, then the corresponding slots of the @code{submenu-item}
instance are set with those values. The @emph{desc} parameter is the description
of a submenu-item (e.g., @code{'("italic")} or @code{'("italic" italic-fn)}).
The default for @emph{enabled} is T.

@end defun

@subsection Adding components to the menubar
@node Adding components to the menubar
@anchor{adding-menubar-components}

Just as with the traditional Garnet approach, the two types of components
that can be added to the @code{menubar} gadget are instances of the @code{bar-item}
gadget and instances of
the @code{submenu-item} gadget. The @code{add-item} method can be used to add
new bar-items to a menubar, or to add new submenu-items to existing bar-items.
Also, the following @code{Set-...} functions can be used to install a collection
of components all at once.

@cindex{set-menubar}

@defun gg:set-menubar menubar new-bar-items
Removes all current bar-items from @emph{menubar} and installs the
@emph{new-bar-items}. The @emph{new-bar-items} should be a list of @code{bar-item}
instances.
@end defun

@cindex{set-submenu}
@defun gg:Set-Submenu bar-item submenu-items
Sets @emph{bar-item} to have @emph{submenu-items} in its submenu.
@var{Submenu-items} is a list of @code{submenu-item} instances.
@end defun

@cindex{add-item, menubar}

@defmethod opal:add-item menubar bar-item [[:where] position [locator] [:key index-function]]
@defmethodx opal:add-item bar-item submenu-item [[:where] position [locator] [:key index-function]]


The @emph{menubar}, @emph{bar-item}, and @emph{submenu-item} parameters above should be
supplied with objects created by the functions in section
@ref{creating-menubar-components}. The optional parameters follow the
standard @code{add-item} definition described in the Aggregadgets manual, and
refer to the placement of the new @code{bar-item} among the existing bar-items.
@emph{Locator} may be either an existing @code{menubar} component,
or some element of the @code{:items} list (like a submenu-title) used together
with the @emph{index-function} (see below).

After creating three @code{bar-item} instances, the example below shows how
the bar-items can be attached as components to a @code{menubar}.

@example
(setf bar1 (garnet-gadgets:make-bar-item
             :desc '("font-name" NIL (("courier") ("times") ("geneva")))))
(setf bar2 (garnet-gadgets:make-bar-item
             :desc '("other-fonts" NIL (("helvetica") ("chicago")))))
(setf bar3 (garnet-gadgets:make-bar-item
             :desc '("symbols" NIL (("mathematical") ("greek")))))
(opal:add-item DEMO-MENUBAR bar1)
(opal:add-item DEMO-MENUBAR bar2 :after "family" :key #'car)
(opal:add-item DEMO-MENUBAR bar3 :after bar2)
@end example

The following instructions show how submenu-items can be attached to
oa @code{bar-item}. A @code{bar-item} object is first created, and then several
submenu-items are attached to it using @code{add-item}:
@example
(setf mac-bar (garnet-gadgets:make-bar-item :title "Mac Fonts"))
(setf sub-1 (garnet-gadgets:make-submenu-item :desc '("Gothic")))
(setf sub-2 (garnet-gadgets:make-submenu-item :desc '("Venice")))
(setf sub-3 (garnet-gadgets:make-submenu-item :desc '("Old English")))
(opal:add-item mac-bar sub-1)
(opal:add-item mac-bar sub-2 :before sub-1)
(opal:add-item mac-bar sub-3 :after "Venice" :key #'car)
@end example
@end defmethod

@subsection Removing components from the menubar
@node Removing components from the menubar
@cindex{remove-item}

The @code{bar-item} and @code{submenu-item} components can be removed from the
@code{menubar} with the @code{remove-item} method:

@defmethod opal:remove-item menubar bar-item
@defmethodx opal:remove-item bar-item submenu-item

For example, if we have already created a @code{bar-item} called BAR-1 and added
it to DEMO-MENUBAR, then the following line will remove that item:
@code{(opal:remove-item DEMO-MENUBAR bar1)}

The @code{remove-item} method can also be used to remove submenu-items from
bar-items. In order to remove a submenu item from the @code{bar-item}
instance MAC-BAR, the following line can be used (provided SUB-1 is an
existing @code{submenu-item} that was added to MAC-BAR):
@code{(opal:remove-item mac-bar sub-1)}
@end defmethod


@subsection Finding Components of the Menubar
@node Finding Components of the Menubar


@defun gg:Menubar-Components menubar
@defunx gg:submenu-components bar-item

returns a list of @code{submenu-item} instances that are installed in
@emph{bar-item}'s submenu.
@end defun

@defun gg:get-bar-component menubar item
returns the first @code{bar-item} object in @emph{menubar} that corresponds to
@emph{item}. The @emph{item} parameter may be a string or an atom, or one of the
sublists of the @emph{menubar}'s @code{:items} list.
@end defun

@cindex{get-submenu-component}
@defun gg:get-submenu-component bar-item item
returns the first @code{submenu-item} object in @emph{bar-item} that corresponds to
@emph{item}. The @emph{item} parameter may be a string or an atom, or a
string/function pair that describes a @code{submenu-item}.

@end defun

@cindex{find-submenu-component}
@defun gg:find-submenu-component menubar submenu-title submenu-item
similar to @code{get-submenu-component}, except that @code{find-submenu-component}
finds the appropriate @code{bar-item} instance in the given @emph{menubar}.
Returns the @code{submenu-item} object that corresponds to @emph{submenu-item}.
The parameter @emph{submenu-title} should be the string or atom that is the
title of some submenu. @emph{Submenu-item} should be a string or atom, or a
string/function pair that describes a @code{submenu-item} already installed
in @emph{submenu-title}.

@end defun

@subsection Enabling and Disabling Components
@node Enabling and Disabling Components

@cindex{menubar-disable-component}
@defun gg:menubar-disable-component menubar-component
disables @emph{menubar-component}'s interactors and makes its label grayed-out.
The user will not be able to select @emph{menubar-component} while it is
disabled. @emph{Menubar-component} is an instance of @code{bar-item} or
@code{submenu-item}.

@end defun

@cindex{menubar-enable-component}
@defun gg:menubar-enable-component menubar-component
enables @emph{menubar-component}'s interactors and returns its label to solid
text. @emph{Menubar-component} is an instance of @code{bar-item} or
@code{submenu-item}.
@end defun

@cindex{menubar-enabled-p}
@defun gg:menubar-enabled-p menubar-component
Returns T if the @emph{menubar-component} is enabled. @emph{Menubar-component} is
an instance of @code{bar-item} or @code{submenu-item}.
@end defun

@subsection Other Menubar Functions
@node Other Menubar Functions

@cindex{menubar-get-title}
@defun gg:menubar-get-title menubar-component
returns the string or atom associated with @emph{menubar-component}.
The @emph{menubar-component} must be an instance of a @code{bar-item} or
@code{submenu-item} gadget.
@end defun 

@cindex{menubar-set-title}
@defun gg:menubar-set-title menubar-component string
changes the title of @emph{menubar-component} to @emph{string} and, if
@emph{menubar-component} is
installed in a @code{menubar}, sets the @code{:items} slot of the @code{menubar}
appropriately. @emph{Menubar-component} can be either an instance of
@code{bar-item} or @code{submenu-item}. @emph{String} is a string or an
atom, suitable for putting in the @code{:items} slot. Returns @emph{string}.
@end defun

@defun gg:menubar-installed-p menubar-component
Returns NIL if @emph{menubar-component} is not attached to a @code{menubar};
otherwise returns the object it is installed in (either a @code{menubar} or
a @code{bar-item}.
@end defun 


@section Labeled Box
@node Labeled Box
@anchor{labeled-box}
@cindex{Box}
@cindex{Labeled box}
@cindex{String input}
@center @image{labeled-box-pix, 5.5in}

@example
(create-instance 'gg:Labeled-Box opal:aggregadget
   (:maybe-constant '(:left :top :label-offset :field-offset :min-frame-width
                      :label-string :field-font :label-font :visible))
   (:left 0)
   (:top 0)
   (:min-frame-width 10)
   (:label-offset 5)
   (:field-offset 6)
   (:label-string "Label:")
   (:value "Field")
   (:field-font opal:default-font)
   (:label-font (create-instance NIL opal:font (:face :bold)))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

The loader file for the @code{labeled-box} is "labeled-box-loader".

The @code{labeled-box} gadget is comprised of a dynamic box with text
both inside and to the left of the box. The text to the left of the
box is a permanent label and may not be changed by the user. The text
inside the box may be edited, however, and the width of the box will
grow with the width of the string. As always, the current string
inside the box may be accessed by the top level @code{:value} slot.

The width of the text frame will not fall below @code{:min-frame-width}.

The label to appear beside the box is in @code{:label-string}. The
distance from the label to the left side of the box is specified in
@code{:label-offset}, and the font of the label is in @code{:label-font}.

The distance from the box to the inner text is in @code{:field-offset},
and the font of the inner text is in @code{:field-font}.

@section Scrolling-Input-String
@node Scrolling-Input-String
@anchor{scrolling-input-string}
@cindex{Scrolling-Input-String}

@example
(create-instance 'gg:Scrolling-Input-String opal:aggregadget
   (:maybe-constant '(:left :top :width :font :line-style :visible))
   (:left 0)
   (:top 0)
   (:width 100) ;@i{ The width of the string area in pixels.}
   (:value "Type here") ;@i{The string that will originally appear in the}
			;@i{  box and that will be changed.}
   (:selection-function NIL) ; @i{Function to be executed after editing text}
   (:font opal:default-font) ; @i{**Must be fixed width**}
   (:line-style opal:default-line-style)) ;@emph{line style can be used to set the color of the string}
@end example

@center @image{scrolling-input, 5.5in}

The loader file for the @code{scrolling-input-string} gadget is
"scrolling-input-string-loader".
@cindex{Scrolling-Input-String-loader}

This allows the user to enter a one-line edited string of arbitrary
length, but only requires a fixed area on the screen since if the
string gets too long, it is automatically scrolled left and right as
needed. Three little dots (an ellipsis) are displayed on either side
of the string if any text is not visible on that side.

The user interface is as follows: To start editing, click with the
left mouse button on the string. To stop, hit @code{return}. To abort, hit
@code{^g}. If the string gets to be too large to fit into the
specified width, then the string inside is scrolled left and right so
the cursor is always visible. The cursor can be moved and text
deleted with the usual editing commands (see the Interactors manual,
page 170).

The top level @code{:value} slot is set with the final value of the
string appearing inside the box. This slot may be set directly to
change the initial value, and formulas may depend on it. A function
may be specified in the @code{:selection-function} slot to be executed
after the field text has changed (i.e., after the carriage return).
Room is left on both sides of the string for a "..." symbol which
shows whether the string has been scrolled or not. Therefore, the
string will not appear exactly at the @code{:left} or extend the full
@code{:width} (since room is left for the ...'s even when they are not
needed).

@section Scrolling-Labeled-Box
@node Scrolling-Labeled-Box
@anchor{scrolling-labeled-box}
@cindex{Scrolling-Labeled-Box}

@example
(create-instance 'gg:Scrolling-Labeled-Box opal:aggregadget
   (:maybe-constant '(:left :top :width :label-offset :field-offset
		      :label-string :field-font :label-font :visible))
   (:left 0) (:top 0)
   (:width 130) ;@emph{The width of the entire area in pixels.}  @emph{This must be big enough}
 	        ;@emph{for the label and at least a few characters of the string!}
   (:value "Field") ;@i{The string that will originally appear in the}
		    ;@i{  box and that will be changed.}
   (:selection-function NIL) ; @i{Function to be executed after editing text}
   (:field-font opal:default-font) ;@emph{**Must be fixed width**}

   (:label-string "Label:") ; @emph{The string that will appear beside the box}
   (:label-offset 5) ; @i{The distance between the label and the box}
   (:field-offset 2) ; @i{The distance between the field text and the box}
   (:label-font (create-instance NIL opal:default-font (:face :bold))))
		     ; @i{The font of the string beside the box, can be variable-width}
@end example

@center @image{scrolling-labeled-box, 5.5in}

The loader file for the @code{scrolling-labeled-box} gadget is
"scrolling-labeled-box-loader".
@cindex{Scrolling-labeled-box-loader}

This is a combination of the @code{scrolling-input} gadget and the
@code{labeled-box} gadget. It has a label and a box around the text. It
operates just like the @code{scrolling-input-string}.


@section Graphics-Selection
@node Graphics-Selection
@anchor{graphics-selection}
@cindex{graphics selection}
@cindex{Selection}

@example
(create-instance 'gg:Graphics-Selection opal:aggregadget
   (:start-where NIL)
   (:start-event :leftdown)
   (:running-where T)
   (:modify-function NIL)
   (:check-line T)
   (:movegrow-boxes-p T)
   (:movegrow-lines-p T)
   (:value NIL)
   (:active-p T)
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@float Figure, fig:ex2
@center @image{select-rect-pix, 5.5in}
@center @image{select-line-pix, 5.5in}
@caption{Selection of a rectangle and a line with
@code{graphics-selection}}
@anchor{selection-fig}
@end float

@sp 1

The loader file for @code{graphics-selection} is "graphics-loader".

The @code{graphics-selection} object is used to move and change the size of other
graphical objects. (The @code{multi-graphics-selection} can select and
move multiple objects -- see section @ref{multi-gs}.)  When the user
clicks on a graphical object (from a 
set of objects chosen by the designer), the object becomes selected
and small selection squares appear around the perimeter of the object.
The user can then drag the white squares to move the object or drag
the black boxes to change the size of the object. Pressing in the
background (i.e., on no object) causes the currently selected object
to become unselected. Clicking on an object also causes the
previously selected object to become unselected since only one object
may be selected at a time. While moving and growing, if the mouse
goes outside of @code{:running-where} or if the @code{^g} key is pressed,
the operation aborts.

The @code{graphics-selection} gadget should be added as a component to
some aggregate or aggregadget of the larger interface, just like any
other gadget. The objects in the interface that will be affected by the
@code{graphics-selection} gadget are determined by the slots
@code{:start-where} and @code{:running-where}.

The @code{graphics-selection} gadget sets the @code{:box} slot of the object
being moved or grown. This is consistent with the behavior of the
@code{move-grow-interactor}, discussed in the Interactors manual. Therefore,
you should create your objects with @code{:left}, @code{:top}, @code{:width}, and
@code{:height} formulas that reference the @code{:box} slot.

The @code{:start-where} slot must be given a value to pass to an
interactor to determine which items may be selected. The value must
be one of the valid @code{...-or-none} forms for the interactors
@code{:start-where} slot (see the Interactors Manual for a list of
allowable values).

The @code{:start-event} slot specifies the event that will cause an object
to be selected. The default is @code{:leftdown}, so if the left mouse button
is clicked over an object in the @code{:start-where}, that object will
become selected.

The @code{:running-where} slot is the area in which the objects can move
and grow (see the Interactors Manual for allowable values).

If the @code{:check-line} slot is non-NIL, then the
@code{graphics-selection} gadget will check the @code{:line-p} slot in the
selected object, and if it is non-NIL then the interactor will select
and change the object as a line. Instances of @code{opal:line} and
@code{gg:arrow-line} already have their @code{:line-p} slots set to T.
For other objects that should be selected as lines, the designer must set the
@code{:line-p} slots explicitly (e.g., a composite object like an
@code{arrow-line} is not really a line, though it should be treated like one).

If @code{:movegrow-lines-p} is NIL, then the @code{graphics-selection}
object will not allow a user to drag the selection squares of a line,
and a beep will be issued if the user clicks on a selection square of
a line.

If @code{:movegrow-boxes-p} is NIL, then the @code{graphics-selection
object} will not allow a user to drag the selection squares of a
non-line, and a beep will be issued if the user clicks on a selection
square of a non-line.

The @code{graphics-selection} gadget will be active when the value of its
@code{:active-p} slot is T. To turn off the gadget, set this slot to NIL.

The @code{:selection-function} slot specifies a function to be executed
upon the selection of any object by the user. This function must take
the parameters:
@example
(lambda (gadget-object new-selection))
@end example
The @code{new-selection} parameter may be NIL if no
objects are selected (i.e., the user clicks in the background).

The designer can supply a @code{:modify-function} that will be called
after an object is modified. It takes these parameters:
@example
(lambda (gadget-object selected-object new-points))
@end example
The @code{new-points} will be a list of 4 numbers,
either @code{left,top,width,height} or @code{x1,y1,x2,y2}.


@section Multi-Graphics-Selection
@node Multi-Graphics-Selection
@anchor{multi-gs}
@cindex{multi-graphics-selection}

@example
(create-instance 'gg:Multi-Graphics-Selection opal:aggregadget
  @emph{;; programmer-settable slots}
   (:active-p T)      @emph{;; whether objects can be selected with the gadget}
   (:start-where NIL) @emph{;; supply a valid start-where here}
   (:running-where T) @emph{;; if supplied, then this is the area in which the}
	              @emph{;; objects can move and grow}
   (:selection-function NIL) @emph{;; this is called when the selection changes}
   (:modify-function NIL) @emph{;; called when an object is changed size or position}
   (:check-line T)        @emph{;; whether to check for :line-p in objects}
   (:check-polygon T)     @emph{;; whether to check for :polygon-p in objects}
   (:check-group T)       @emph{;; whether to check for :group-p in objects}
   (:check-grow-p NIL)    @emph{;; whether to check for :grow-p in objects}
   (:check-move-p NIL)    @emph{;; whether to check for :move-p in objects}
   (:move-multiple-p T)   @emph{;; whether to move multiple objects as a group}
   (:grow-multiple-p T)   @emph{;; whether to grow multiple objects as a group}
   (:input-filter NIL)    @emph{;; used by the move-grow-interactor for gridding, etc.}
   (:want-undo NIL)       @emph{;; whether to save information to allow undo}
   (:multiple-select-p T) @emph{;; if T, then multiple objects can be selected.}

   (:other-multi-graphics-selection NIL]  @emph{;; Used when several multi-selection gadgets in}
                                          @emph{;; different windows are working in conjunction.}

   (:allow-component-select NIL)      @emph{;; if T, then pressing with @code{control} will select}
                                      @emph{;; the component under the selected object.}
   (:down-to-component-function gg::Point-To-Comp)  @emph{;; a function that gets the}
                                                    @emph{;; appropriate component out}
                                                    @emph{;; of the object under the mouse.}

  @emph{;; slots the programmer can access}
   (:current-selected-object NIL) @emph{;; set with new selection or object to be moved}
				  @emph{;; or grown before other slots are set.}
   (:value NIL))  @emph{;; current object or objects selected **DO NOT SET**}
@end example

@center @image{multi-selection-pix1, 5.5in}
@center @image{multi-selection-pix2, 5.5in}
@center @image{multi-selection-pix2, 5.5in}

@cindex{multi-selection-loader}
The loader file for @code{multi-graphics-selection} is "multi-selection-loader".

The @code{multi-selection} gadget is somewhat like the @code{graphics-selection}.
The major difference is that multiple objects can be selected and
manipulated by the user, and that the programmer must use a function to set
the @code{:value} slot. Another difference is the way that the gadget
checks whether move and grow is allowed.

This gadget exhibits the following features:

@itemize
   Given a list of graphical objects, the @code{multi-graphics-selection}
   aggregadget will cause selection squares to appear on the
   bounding box of selected objects.

   One or more objects may be selected at a time, even when the
   objects are in different windows.

   A built-in interactor displays the selection squares around an
   object at the time of a specified event (such as clicking a mouse
   button on the object).

   Each selection square allows the user to move or grow the object
   by dragging the selection square.

   The user can move and grow several objects simultaneously.

   All of the objects inside a region (drawn by dragging the mouse) can
   be selected.
@end itemize


@subsection Programming Interface
@node Programming Interface

Create an instance of the @code{gg:multi-graphics-selection} gadget
and supply the @code{:start-where} slot with a valid list that can be passed to
an interactor. This @code{:start-where} must return the items to be selected.
It should be an @code{...-or-none} form, such as @code{:element-of-or-none}. An
example of the parameter to @code{:start-where} is:
@code{(list :element-of-or-none MYAGG)}

The @code{:value} slot of the @code{multi-graphics-selection} object supplies
the object(s) the user selects. If @code{:multiple-select-p} is NIL
(the default), then it is a single object or NIL. If @code{:multiple-select-p}
is T, then will always be a list or NIL (even if only one object is
selected). Also, a @code{:selection-function} can be
supplied and will be called each time the selection changes. It takes
the parameters

@code{(lambda (gadget new-selection)}
where @var{new-selection} is the new value of @code{:value}.

When your interface contains selectable objects in several windows,
you can put a multi-selection gadget in each window and coordinate
them all. Each gadget's @code{:other-multi-graphics-selection} slot
should contain a list of ALL the multi-selection gadgets. Then, each
gadget's @code{:value} will reflect selections in all windows. A known
bug is that the selection order is NOT preserved across multiple
windows (you can't tell which object was selected first or last).
Also, you cannot drag objects from one window to another.

The user can change the size and/or position of the objects by
pressing on the selection handles (see below). If the
@code{:check-line} slot is non-NIL, then the @code{:line-p} slot in the object
returned by @code{:start-where} will be gvd, and if it is non-NIL then the
interactor will change the object as a line. Note that instances of
@code{opal:line} and @code{gg:arrow-line} have their @code{:line-p} slot set
to T by default. For other objects, the programmer must
set the @code{:line-p} slots explicitly. There is analogous interaction
between the @code{:check-group} and @code{:check-polygon} slots of the
gadget and the @code{:group-p} and @code{:polygon-p} slots of the selected objects.

The programmer can supply a @code{:modify-function} that will
be called after an object is modified. It takes these
parameters: @code{(gadget selected-object new-points)}
The @emph{new-points} will be a list of 4 numbers, either
@code{left,top,width,height} or @code{x1,y1,x2,y2}.



@b{Programmer-settable slots:}

In summary, public slots of the @code{multi-graphics-selection} gadget are:

@vtable @code
   @code{:active-p} - If T, then the gadget will operate. If NIL, then
                    none of the interactors will work. Setting to NIL does
                    @b{not} clear the selection, however.

   @code{:start-where} - Supply a valid start-where here.

   @code{:running-where} - If supplied, then this is the area in which the
 			 objects can move and grow.

   @code{:selection-function} - This is called when the selection changes.

   @code{:modify-function} - This is called when an object is changed size or
                           position.

   @code{:check-line} - If T, the objects are checked for their @code{:line-p} slot
                      and if that is non-NIL, then move or grown as a line.

   @code{:check-polygon} - If T, the objects are checked for their
                         @code{:polygon-p} slot and if that is non-NIL, then
                         they are moved or grown as a polygon (by changing
                         their @code{:point-list} slot).

   @code{:check-group} - If T, the objects are checked for their @code{:group-p}
                       slot and if that is non-NIL, then the individual
                       components of the group are modified.

   @code{:check-grow-p} - If T, then checks in each object to see if @code{:grow-p}
                        is T, and if so, then will grow, else won't.
                        If NIL, then everything can grow. Default NIL.

   @code{:check-move-p} - If T, then checks in each object to see if @code{:move-p}
                        is T, and if so, then will move, else won't. If NIL,
                        then everything can move. Default NIL.

   @code{:move-multiple-p} - If T, then if multiple items are selected and you
 			press on a move box, then moves all of the objects.
 			If NIL, then just moves the object you point to.
 			Default=T.

   @code{:grow-multiple-p} - If T, then when multiple items are selected, grow
                           boxes appear at the corners of the whole selection,
                           and pressing there will grow all the objects.
                           If NIL, then those handles don't appear.

   @code{:input-filter} - This is used by the move-grow-interactor for gridding.
                        Consult the Interactors manual for a list of allowed
                        values.

   @code{:want-undo} - If T, then saves information (conses) so that you can call
                     @code{undo-last-move-grow}.

   @code{:allow-component-select} - Whether to allow selection of components
                                  (see below). Default=NIL.

   @code{:down-to-component-function} - A function that determines which
                        component of an object has just been selected
                        (see below). Default=NIL.

   @code{:multiple-select-p} - If T, then multiple objects can be selected.
                             Default=NIL.

@end vtable

 
@b{Slots that can be accessed:}

@vtable @code
   @code{:value} - set with list of the current selections, in reverse order
                 the user selected the objects (first selected object is
                 last in the list). @b{Do not set this slot.}  Instead,
                 use the function @code{Set-Selection} (see below).

   @code{:current-selected-object} - set with new selection before other
                                   slots are set.
@end vtable



@b{Selecting components of the currently selected object:}

You can enable the selecting of the components of the selected
objects by setting @code{:allow-component-select} to T.
For example, if the @code{:start-where} lists a set of
objects, this feature can allow the selection of the @emph{parts} of
those objects. When component selection is enabled, then by pressing
the @code{control-left} mouse button over a selected object,
that object will be deselected, and its component will be selected
instead. Similarly, if the @code{control-middle} mouse button or the
@code{control-shift-left} mouse button is hit
over a selected object, then that object is de-selected, and the
object underneath is added to the selection set. The slot
@code{:down-to-component-function} should contain a function to get the
appropriate component out of the object under the mouse. This
function might call a method in the selected object. Parameters are
@code{(lambda obj x y)}. It should return the object to be selected, or
NIL. The default function calls @code{opal:point-to-component} directly.


@b{Slots of the objects that can be selected are:}

@vtable @code
   @code{:line-p} - this should be T if the object should be moved as a line,
                  and NIL if as a rectangle

   @code{:group-p} - this should be T if the object is some instance of
                   opal:aggregate and all its components should be moved as
                   a group 

   @code{:polygon-p} - this should be T if the object is a polyline and it should
                     be moved by changing its @code{:point-list} slot

   @code{:points} - if @code{:line-p} is T, then the @code{:points} slot of the
                  object is changed as the object is moved or grown.

   @code{:box} - if @code{:line-p} is NIL, then the @code{:box} slot of the object is
               changed as the object is moved or grown.

   @code{:grow-p} - if this object can be changed size

   @code{:move-p} - if this object can be moved
@end vtable

@b{Useful Functions:}

@defun gg:set-selection gadget new-selection

@var{Gadget} should be a @code{multi-graphics-selection} gadget, and
@var{new-selection} is a list of objects that should be selected, or a single
object to be selected, or @code{nil} to turn off all selections. The list passed
in is not damaged.
@end defun


@defun gg:undo-last-move-grow multi-graphics-selection-gadget

When @code{:want-undo} is non-NIL (default is NIL), then calling this function
will undo the last move or grow and the selection will return to whatever it
was when the objects were moved or grown. If you call @code{undo-last-move-grow}
again, it undoes the undo (one-level undo). It is
your responsibility to make sure that no objects were deleted or
whatever between the grow and the call to undo.

@cindex{undo}
@emph{Garnet does not yet have a general mechanism for Undo, so you
should use this feature with care. It is currently your
responsibility to keep track of what the last operation was and undo it.}
@end defun


@subsection End User Operation
@node End User Operation

The user can press on any object with the left button, and it will
become selected. Pressing on the background, causes no object to be
selected (the current object becomes de-selected). Selecting an object
with the left button causes the previous object to be de-selected.
If the application allows multiple selection, then clicking with
shift-left or middle on an object toggles it in the selection set.

Once an object is selected, it can be grown by pressing with the left
button on one of the black boxes or moved by pressing on a white box.
While moving and growing, if the mouse goes outside of :running-where
or if @code{^g} is pressed, the operation aborts.

The gadget also allows the user to change the size of several objects
at once. When multiple objects are selected, outline handles
appear around each object, and the whole set can be moved by
pressing on any of these handles. Additionally, when @code{:grow-multiple-p}
is non-NIL, black handles appear at the four corners of the collection of objects, and these can be used to scale the entire group. 

@cindex{selecting objects in a region}
The gadget also allows objects to be selected in a region.
If you press down and drag before releasing, then
only the objects fully inside the dragged rectangle will become
selected. If you do this with the left button, then they will be
selected. If you do this with shift-left or the middle button, then
all objects inside the rectangle will be toggled in the selection set
(added if not there, removed if there).


@section Scrolling-Windows
@node Scrolling-Windows
@anchor{scrolling-windows}

There are two scrolling-window gadgets which have the standard Garnet
look and feel, and two other scrolling-window gadgets that have the
Motif look and feel (see section @ref{motif-scrolling-window}). 
These windows are based on the design from Roderick J. Williams at
the University of Leeds for the Garnet contest. The
@code{scrolling-window} gadget allows you to do your own scrolling. The
@code{scrolling-window-with-bars} gadget comes with a horizontal and
vertical scroll bar, which you can have on either side (and can turn
off explicitly). Each scroll bar will go blank if the entire area to
be scrolled in is visible in the window.

@center @image{scrolling-window-gadget, 5.5in}

@example
(create-instance 'gg:Scrolling-Window opal:aggregadget
   (:maybe-constant '(:title :parent-window))
   (:left 0)  ; @emph{left, top, width and height of window}
   (:top 0)
   (:position-by-hand NIL) ; @emph{if T, then left,top ignored and user asked for window position}
   (:width 150) ;@i{width and height of inside of outer window}
   (:height 150)
   (:border-width 2) ; @emph{of window}
   (:parent-window NIL) ; @emph{window this scrolling-window is inside of, or NIL if top level}
   (:double-buffered-p NIL)
   (:omit-title-bar-p NIL)
   (:title "Scrolling-Window")
   (:icon-title (o-formula (gvl :title))) ;@emph{Default is the same as the title}
   (:total-width 200)   ; @emph{total size of the scrollable area inside}
   (:total-height 200)   
   (:X-Offset 0)  ; @emph{offset in of the scrollable area}
   (:Y-Offset 0)
   (:visible T)  ; @emph{whether the entire window is visible (mapped)}

   ;; @emph{ Read-Only slots}
   (:Inner-Window NIL)  ; @emph{these are created by the update method}
   (:inner-aggregate NIL) ; @emph{add your objects to this aggregate (but have to update first)}
   (:outer-window NIL) ; @emph{call Opal:Update on this window (or on gadget itself)}
@end example

@example
@cindex{scrolling-window-with-bars}
(create-instance 'gg:Scrolling-Window-With-Bars opal:aggregadget
   (:maybe-constant '(:left :top :width :height :border-width :title
                      :total-width :total-height :h-scroll-bar-p :v-scroll-bar-p
		      :h-scroll-on-top-p :v-scroll-on-left-p :min-scroll-bar-width
                      :scr-trill-p :page-trill-p :indicator-text-p :h-scr-incr 
                      :h-page-incr :v-scr-incr :v-page-incr :int-feedback-p
                      :indicator-font :parent-window :icon-title :visible))
   ;; @emph{Window slots}
   (:left 0)  ; @emph{left, top, width and height of outermost window}
   (:top 0)
   (:position-by-hand NIL) ; @emph{if T, then left,top ignored and user asked for window position}
   (:width 150) ;@i{width and height of inside of outer window}
   (:height 150)
   (:border-width 2) ; @emph{of outer window}
   (:parent-window NIL) ; @emph{window this scrolling-window is inside of, or NIL if top level}
   (:double-buffered-p NIL)
   (:omit-title-bar-p NIL)
   (:title "Scrolling-Window")
   (:icon-title (o-formula (gvl :title))) ;@emph{Default is the same as the title}
   (:total-width 200)   ; @emph{total size of the scrollable area inside}
   (:total-height 200)   
   (:X-Offset 0)  ; @emph{x offset in of the scrollable area. CANNOT BE A FORMULA}
   (:Y-Offset 0)  ; @emph{CANNOT BE A FORMULA}
   (:visible T)  ; @emph{whether the window and bars are visible (mapped)}

   (:h-scroll-bar-p T)  ; @emph{Is there a horizontal scroll bar?}
   (:v-scroll-bar-p T)  ; @emph{Is there a vertical scroll bar?}

   ;; @emph{Scroll Bar slots}
   (:h-scroll-on-top-p NIL)  ; @emph{whether horiz scroll bar is on top or bottom}
   (:v-scroll-on-left-p T)   ; @emph{whether vert scroll bar is on left or right}
   (:min-scroll-bar-width 20) ; @emph{these control both scroll bars}
   (:scr-trill-p T)  ;@emph{single-line increment arrow buttons visible?}
   (:page-trill-p T) ;@emph{page jump arrow buttons visible?}
   (:h-scr-incr 10)  ; @emph{in pixels}
   (:h-page-incr (o-formula (- (gvl :width) 10))) ; @emph{default jumps one page minus 10 pixels}
   (:v-scr-incr 10)  ; @emph{in pixels}
   (:v-page-incr (o-formula (- (gvl :height) 10))) ; @emph{default jumps one page minus 10 pixels}
   (:int-feedback-p T) ; @emph{use NIL to have contents move continuously}
   (:indicator-text-p NIL) ; @emph{Whether the pixel position is shown in the bars}
   (:indicator-font (create-instance NIL opal:font (:size :small)))

   ;; @emph{Read-Only slots}
   (:Inner-Window NIL)  ; @emph{these are created by the update method}
   (:inner-aggregate NIL) ; @emph{add your objects to this aggregate (but have to update first)}
   (:outer-window NIL) ; @emph{call Opal:Update on this window (or on gadget itself)}
   (:clip-window NIL)

@end example


The loader file for both scrolling-window gadgets is
"scrolling-window-loader".
@cindex{scrolling-window-loader}

@b{Caveats:}
@itemize
If the scrolling-window has a @code{:parent-window}, update the parent
window before instantiating the scrolling-window.

Update the scrolling-window gadget before referring to its inner/outer
windows and aggregates.

The instance of the scrolling-window should @b{not} be added to an aggregate.
@end itemize

These gadgets supply a scrollable region using the X window manager's
ability to have subwindows bigger than the parent window. Garnet
moves the subwindow around inside the parent window and X handles the
clipping. All the objects in the window are instantiated (and
therefore take up memory), but they will not be drawn if outside. You
must specify the total area to be scrolled in using the
@code{:total-width} and @code{:total-height} fields. (Therefore, the
scrolling window gadgets do not support semi-infinite planes--you must
pick a size for the user to scroll around in.)  Often, you can compute
the size based on the contents to be displayed in the window. There
can be a formula in the @code{:total-*} fields, but it should have an
initial value. @emph{Note: It is illegal to have windows with a zero or
negative width and height, so the
@code{:total-width} and @code{:total-height} should always be greater than
zero.}

The width and height specified for the window is the inside of the
outer window, not counting the scroll bars. For
@code{scrolling-windows}, this will usually be the same as the size of
the visible region. For @code{Scrolling-Window-With-Bars}, the visible
portion is smaller by the size of the scroll bars, which is usually
the value of the @code{:min-scroll-bar-width} slot (unless you turn on
indicator text).

Each of these gadgets is special in that they add themselves to the
windows that they create. Since windows are not like other Gadgets,
you need to follow special rules with scrolling windows.

First, @i{do not add scrolling-window or scrolling-window-with-bars
gadgets to any aggregates or include them in aggregadgets}. If you
want a scrolling window to be inside another window, you must use the
@code{:parent-window} slot instead.

Second, @i{you must call @code{opal:update} on a scrolling window gadget
immediately after creating it, and before adding anything to the
windows.} The update method causes the windows to be created. If you
want to create a prototype of a scrolling window (and specify special
values for some of the fields), you can skip the update call, but then
you cannot add any contents to the window.

The aggregate to add the contents to is provided in the slot
@code{:inner-aggregate} of the gadget after the update call. To make
the scrolling-window a subwindow of another window, specify the
@code{:parent-window} of the scrolling-window. If you want to put a
sub-window inside a scrolling-window, use the window in the
@code{:inner-window} slot of the scrolling window as the @code{:parent} of
the newly created window.

As an example:
@example
(create-instance 'MYSCROLL garnet-gadgets:scrolling-window-with-bars
   (:left 650)(:top 10)(:width 300)(:height 400)
   @emph{;;note that the next two formulas must have initial values}
   (:total-width (o-formula (gvl :inner-aggregate :width) 200))
   (:total-height (o-formula (gvl :inner-aggregate :height) 200)))
(opal:update MYSCROLL) ;@emph{Must update scrolling windows before using them.}
(opal:add-components (gv MYSCROLL :inner-aggregate)
	    @emph{all the objects to be added to the scrolling window}
	    )
;;;@emph{create a scrolling window inside the other scrolling window, just for fun}
(create-instance 'SUB-SCROLLING-WINDOW garnet-gadgets:scrolling-window-with-bars
   (:left 15)(:top 15)(:width 150)(:height 150)
   (:parent-window (gv MYSCROLL :inner-window)))
@end example
 
With @code{Scrolling-Windows}, but @emph{not} @code{Scrolling-windows-with-Bars},
you can explicitly set the @code{:X-offset} and
@code{:Y-Offset} fields using @code{s-value} to adjust the position of the
contents. For @code{Scrolling-windows-with-Bars}, you must use the following
procedures to have your application program scroll the window. This
is necessary to get the scroll bars to be updated correctly to show the
window position. These procedures also work with @code{Scrolling-Windows}.

@b{Useful functions:}

@defun gg:scroll-win-inc scroll-win-gadget xinc yinc

This function scrolls a window by adding the specified values, which can be
negative. Note that @emph{xinc} and @emph{yinc} are usually zero or negative
numbers, since they are the offset top-left corner of the inner window
from the top-left of the clipping window, so to see down in the
document, the inner window must be moved up.
@end defun


@defun gg:scroll-win-to scroll-win-gadget x y


This function scrolls a window by putting the specified coordinate at the
upper left corner of the clip window.
@end defun

@defun gg:show-box scroll-win left top right bottom

This function causes the scrolling-window @emph{scroll-win} to scroll so that
the region specified by @emph{left}, @emph{top}, @emph{right} and @emph{bottom} is
visible. If the box is already visible, it will not cause the window to
scroll. This can be used to cause the cursor in a text window, for
example, or a "current item" to be visible. It is also used by the
@code{focus-multifont} interactor.

If the box is larger than the visible region of the scrolling-window, the
bottom and/or the rightmost parts of the box may remain hidden.
@end defun



@section Arrow-line and Double-Arrow-Line
@node Arrow-line and Double-Arrow-Line
@cindex{arrow-line}
@cindex{double-arrow-line}
@center @image{arrow-pix, 5.5in}

The @code{arrow-line} and @code{double-arrow-line} objects are comprised
of a line and one or more arrowheads, effectively forming a single- or
double-headed arrow. These objects are provided since the standard
@code{opal:arrowhead} does not have an attached line.

@subsection Arrow-Line
@node Arrow-Line
@anchor{arrow-line}
@example
(create-instance 'gg:Arrow-Line opal:aggregadget
   (:maybe-constant '(:x1 :y1 :x2 :y2 :line-style :open-p :filling-style :visible))
   (:X1 0) (:Y1 0)
   (:X2 20) (:Y2 20)
   (:line-style opal:default-line-style)
   (:filling-style NIL)
   (:open-p T))
@end example

The loader file for the @code{arrow-line} is "arrow-line-loader".

The origin (or tail) of the @code{arrow-line} is the point
@code{(:x1,y1)}, and the tip is at @code{(:x2,y2)}. The values for these
slots may be formulas that depend on the value of slots in other
Garnet objects. For example, if @code{:x2} and @code{:y2} depended on the
@code{:left} and @code{:top} coordinates of some rectangle, then the arrow
would point to the top, left corner of the rectangle regardless of the
movement of the rectangle.@footnote{See the KR manual for a detailed
discussion of constraints and formulas.}

The appearance of the arrowheads themselves may also be customized.
The @code{:line-style} slot contains a value indicating the thickness of
all lines in the @code{arrow-line} object. Opal exports a set of
pre-defined line styles, which must be preceded by the Opal package
name, as in @code{opal:line-0}. Available line style classes are:
@code{no-line, thin-line, line-0, line-1, line-2, line-4, line-8,
dotted-line} and @code{dashed-line}. Other line style classes may also
be defined (see the Opal Manual).

The slot @code{:filling-style} determines the shade of gray that will
appear inside the arrowheads. Pre-defined filling styles are exported
from Opal, and must again be preceded by the Opal package name.
Available filling styles are @code{no-fill, black-fill, white-fill,
gray-fill, light-gray-fill, dark-gray-fill,} and @code{diamond-fill}.
The Opal function @code{halftone} may also be used to generate a filling
style, as in @code{(:filling-style (opal:halftone 50))}, which is
half-way between black and white fill.

The slot @code{:open-p} determines whether a line is drawn across the
base of the arrowhead.

@sp 1
Additional features of the arrowhead may be customized
by accessing the slot @code{:arrowhead} of the @code{arrow-line}. For
example, the following instruction would set the @code{:diameter} of an
@code{arrow-line} arrowhead to 20:
@example
(s-value (gv MY-ARROW-LINE :arrowhead) :diameter 20)
@end example

The same customization may also be implemented when the instance is created:
@example
(create-instance 'MY-ARROW-LINE garnet-gadgets:arrow-line
   (:parts `(:line (:arrowhead :modify
                               (:diameter 20)))))
@end example


@subsection Double-Arrow-Line
@node Double-Arrow-Line
@anchor{double-arrow-line}
@example
(create-instance 'gg:Double-Arrow-Line opal:aggregadget
   (:maybe-constant '(:x1 :y1 :x2 :y2 :line-style :open-p :filling-style
		      :arrowhead-p :visible))
   (:X1 0) (:Y1 0)
   (:X2 40) (:Y2 40)
   (:line-style opal:default-line-style)
   (:filling-style NIL)
   (:open-p T)
   (:arrowhead-p :both))
@end example

The loader file for the @code{double-arrow-line} is "arrow-line-loader".

The endpoints of the @code{double-arrow-line} are at points
@code{(:x1,:y1)} and @code{(:x2,:y2)}. The slots @code{:line-style},
@code{:filling-style}, and @code{:open-p} are used exactly as in the
@code{arrow-line}, with both arrowheads taking identical properties.

@sp 1
The additional slot @code{:arrowhead-p} designates which
end(s) of the line will have arrowheads. Allowed values are:

@vtable @code
@code{0} or @code{NIL} - No arrowheads

@code{1} - Arrowhead at coordinate @code{(:x1,:y1)}

@code{2} - Arrowhead at coordinate @code{(:x2,:y2)}

@code{3} or @code{:both} - Arrowheads at both ends
@end vtable

The arrowheads may be further customized as in the @code{arrow-line}
object. The arrowheads are available in the slots @code{:arrowhead1}
and @code{:arrowhead2}.

@section Browser Gadget
@node Browser Gadget
@anchor{browser-gadget}
@cindex{browser gadget}

@example
(create-instance 'gg:Browser-Gadget opal:aggregadget
   (:maybe-constant '(:left :top :num-menus :num-rows :menu-items-generating-function
                      :menu-function :item-to-string-function :additional-selection-p
		      :item-font :title-font :visible))

   @emph{;; Browser parameters}
   (:left 0)
   (:top 0)
   (:num-menus 3)
   (:num-rows 5)
   (:menu-items-generating-function NIL)
   (:item-to-string-function #'(lambda (item) item))  @emph{;; assume item is a string}

   @emph{;; Additional-selection parameters}
   (:additional-selection-p T)
   (:additional-selection (o-formula ... ))
   (:additional-selection-function NIL)
   (:additional-selection-coordinate NIL)

   @emph{;; Scrolling-Menu parameters}
   (:item-font opal:default-font)
   (:title-font (create-instance NIL opal:font (:face :italic)))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@center @image{browser-gadget-pix, 5.5in}

The loader file for the @code{browser-gadget} is "browser-gadget-loader".
@cindex{browser-gadget-loader}

The @code{browser-gadget} is a sophisticated interface device which may
be used to examine hierarchical structures, such as Garnet object
networks and directory trees. The gadget is composed of a set of
scrolling menus, where the selections in each scrolling menu
correspond to the children of the item appearing in the title.
Clicking on one of the menu selections causes that selection to appear
as the title of the next scrolling menu, with all of its children
appearing as choices in the new menu. Additionally, clicking the
middle mouse button over a menu selection causes a gray feedback box
to appear, indicating a secondary selection.

@cindex{demo-schema-browser}
@cindex{demo-file-browser} Two demos, named "demo-schema-browser" and
"demo-file-browser", are included in the Garnet @code{demos}
sub-directory as examples of how the @code{browser-gadget} is used in an
interface. With the schema browser, the user may examine the
inheritance and aggregate hierarchies of Garnet, while the file
browser can be used to examine the file hierarchy of Unix directories.

@subsection User Interface
@node User InterfaceAn instance of the @code{browser-gadget} may
initially appear in a window with an item already displayed in the
first menu. (Alternatively, the designer may provide a mechanism such
as a @code{labeled-box} gadget through which the user initializes a
fresh browser with the first item.)  The selections in the first menu
are derived from the item in the title through a specified function.
When the user clicks the left mouse button on one of the menu choices,
that selection will appear in the title of the next menu, with all of
that item's "children" appearing as choices. If the item that the
user selects does not generate any children, then a new menu is not
generated.

The user may also click on a menu selection with the middle mouse
button, causing the selection to be bordered by a gray rectangle.
This selection is called the "additional selection", and there is only
one for all of the menus in the @code{browser-gadget}.

The choices that are visible in each menu are controlled by the scroll
bars appearing on the sides of the menus. If there are more menu
selections derived from the title item than can be shown in a menu,
then the background of the scroll bar will be gray and a white
indicator box will appear. Clicking the left mouse button on the
trill boxes at the top and bottom of the scroll bars will "scroll"
more selections into the menu. Clicking on the single arrow trill
boxes causes the visible selections to scroll one at a time, and
clicking on the double arrow trill boxes will cause an entire "page"
of new selections to appear (one page is equal to the number of items
visible in the menu). The user may also drag the indicator of a
scrolling menu scroll bar to adjust the visible selections.

Analogously, the horizontal scroll bar appearing below the menus may
be adjusted to change which menus are displayed. When there are more
menus to show than are allowed at one time, then the trill boxes can
be clicked to scroll either one menu at a time or a whole "screen" of
menus. Dragging the indicator in this scroll bar will cause a black
rectangle to follow the mouse, rather than the indicator box itself.
When the user releases the black rectangle, the indicator will jump to
the position where it was released.

@subsection Programming Interface
@node Programming Interface

@subsection Overview
@node Overview
It is important to note that the programming
interface to the @code{browser-gadget} is different than in other Garnet
gadgets. Due to the complexity of the gadget, this section is
provided as a guide to the essential elements of the
@code{browser-gadget} so that the designer can create and use an
instance immediately. Subsequent sections describe in greater detail
the slots and functions mentioned in this section.

When creating an instance of the @code{browser-gadget}, there is one
slot that @b{must} be set. The slot
@code{:menu-items-generating-function} must be provided with a function
that generates children from the items that are to be shown in the
titles of the menus. This function takes an item and returns a list
of items that correspond to menu selections. These items can be of
any type, but if they are not strings, then the slot
@code{:item-to-string-function} must @b{also} be set with a function to
derive strings from the items (its default value is the identity
function). These functions are discussed further in section
@ref{gen-fns}.

The @code{:items} slot adheres to the convention that if an element of this
list is a list, then the second element is an item-function.
The @code{:item-to-string-function} (described below) is applied to the first
element of the item list to get a label for a menu selection. If data is to
be stored in the elements of the @code{:items} list, it should be included as
the third or greater elements in the item lists (see section @ref{items-slot}).

To install an item in a @code{browser-gadget} instance, the function
@b{@code{set-first-item}} should be called with the parameters of the
name of the browser instance and the new item. A subsequent update of
the window containing the instance will show the item appearing in the
first menu with all of its children. Other functions used to
manipulate the @code{browser-gadget} are discussed in section
@ref{manipulating}.

@subsection An example
@node An example
@anchor{browser1-example} Suppose that we want to define an instance of
the @code{browser-gadget} to look at the inheritance hierarchy of Garnet
schemas. First, create an instance called BROWSER-1 with the
appropriate generating functions (these particular lambda-expressions
are analyzed in @ref{gen-fns}).
@example
(create-instance 'BROWSER-1 garnet-gadgets:browser-gadget
   (:menu-items-generating-function #'(lambda (item)
					(gv item :is-a-inv)))
   (:item-to-string-function #'(lambda (item)
				 (if item
				     (string-capitalize (kr:name-for-schema item))
				     ""))))
@end example
The BROWSER-1 schema can be added to a Garnet window in the usual way:
@example
(create-instance 'WIN inter:interactor-window
   (:width 600) (:height 200)
   (:aggregate (create-instance 'AGG opal:aggregate)))
(opal:add-component AGG BROWSER-1)
(opal:update win)
@end example

Now, we can initialize the BROWSER-1 object with a Garnet schema, such
as the @code{opal:rectangle} schema:
@cindex{set-first-item}
@example
(garnet-gadgets:set-first-item BROWSER-1 opal:rectangle)
(opal:update win)
@end example
All instances of @code{opal:rectangle} that currently exist
will be shown in the first menu. Clicking on one of the selections in
this menu will cause that selection to appear in the title of the
second menu, with all of its instances as selections.

Since @code{opal:rectangle} is an instance of the @code{opal:graphical-object}
schema, we can use the
@b{@code{push-first-item}} (described in section @ref{manipulating}) to
show all of the objects that are instances of @code{opal:graphical-object}.
If we call
@example
(garnet-gadgets:push-first-item BROWSER-1 opal:graphical-object)
@end example
then the "Rectangle" title will be moved into the
second menu along with all of its selections, and the
"Graphical-Object" item will be displayed in the first menu with all
of its instances. The "Rectangle" selection under the
"Graphical-Object" title will be highlighted, since it was matched
with the title of the second menu.


@subsection Generating Functions for Items and Strings
@node Generating Functions for Items and Strings
@anchor{gen-fns}

@cindex{menu-items-generating-function} The slot
@code{:menu-items-generating-function} contains a function which
generates menu selections from each item in the scrolling menu titles.
The function takes an @emph{item} as a parameter, and returns a list of
menu items which correspond to the selections in the scrolling menus.
For example, if a @code{browser-gadget} instance is to be initialized
with a Garnet schema, and the menus should display all of the
instances of each item, then the @code{:menu-items-generating-function}
appearing in the example of section @ref{browser1-example} is
appropriate. It should be noted that this function does not need to
return a list of strings, but that eventually strings will be
generated from the items that it returns (via the function in
@code{:item-to-string-function}).

@cindex{item-to-string-function} The function in the slot
@code{:item-to-string-function} is used to generate strings from
arbitrary items obtained from the
@code{:menu-items-generating-function}. If the generated items are
strings themselves, then the @code{:item-to-string-function} may retain
its default value. The strings returned by the
@code{:item-to-string-function} will be displayed as the titles and
selections of the scrolling menus. In the example of section
@ref{browser1-example}, the @code{:menu-items-generating-function}
returns a list of Garnet schemas. So the supplied
@code{:item-to-string-function} takes a schema as a parameter and
returns the string name of the schema. Notice that when there are
fewer items than there are menus, this function will generate empty
strings for the titles of the blank menus.



@subsection Other Browser-Gadget Slots
@node Other Browser-Gadget Slots
The number of menus to be
displayed horizontally in the @code{browser-gadget} is determined by the
slot @code{:num-menus}. Since the set of menus in the gadget is
implemented with an aggrelist, the menu objects will be adjusted automatically
to correspond with the new value during the next call to @code{opal:update}.
Analogously, the slot @code{:num-rows} determines the number of vertical
selections to appear at one time in each scrolling menu.

The slots @code{:title-font} and @code{:item-font} control the fonts for
the titles of the menus and the menu selections, respectively.

The function specified in @code{:selection-function} is executed when
the user selects an item from one of the scrolling menus. The
parameters of this function are
@example
(lambda (browser-instance item))
@end example
where the @emph{item} is an object generated by the
function specified in @code{:menu-items-generating-function}. This
function is executed after some internal bookkeeping is performed to
update the @code{browser-gadget}.


@subsection The Additional Selection
@node The Additional Selection
@anchor{additional}
@cindex{gray feedback object}
@cindex{additional-selection} When the user presses the middle mouse
button over one of the scrolling menu selections, the outline of a
gray rectangle will appear over the selection. The item chosen in
this manner is called an "additional selection".

Whether this feature is active is determined by the value of the slot
@code{:additional-selection-p}.

The item identified by the additional selection may be accessed
through the slot @code{:additional-selection}. The value in this slot
will correspond to some item returned by the function specified in
@code{:menu-items-generating-function}. @b{Note:} this slot cannot be
set directly to move the gray feedback box. Instead, the
@code{:additional-selection-coordinate} slot must be set.

Since items may frequently be scrolled off to the side of the browser,
it may not be possible to name explicitly the item which the gray
feedback object should appear over. However, the "coordinate" of the
additional selection can always be named in the slot
@code{:additional-selection-coordinate}. This slot is set when the user
selects the additional selection, and it may be set directly by the
programmer. The @code{:additional-selection-coordinate} slot contains a
list of two values -- the first is the rank of the menu which the
selection appears in, and the second is the rank of the selection
within the menu. Both ranks are zero-based, and are relative to the
full lengths of the two item lists, not just the items currently
visible.

The function specified in the slot @code{:additional-selection-function}
will be executed when the user chooses the additional selection. The
parameters are
@example
(lambda (browser-instance item))
@end example
where @emph{item} was just selected by the user. If
the user presses over the previous additional selection, it will
become deselected, and the
@code{:additional-selection-function} will be called with NIL as the
@emph{item} parameter.

@subsection Manipulating the browser-gadget
@node Manipulating the browser-gadget
@anchor{manipulating}

@cindex{set-first-item} Once an instance of the @code{browser-gadget} has
been created, an item can be installed in the instance as starting
object by calling @b{@code{set-first-item}} with the parameters

@defun gg:Set-First-Item browser-instance new-item

The effect of calling this function is to install
the @emph{new-item} in the @code{:items} slot of the instance, and to
initialize the bookkeeping slots of the instance.

@cindex{push-first-item} The function @b{@code{push-first-item}} is used
to add an item to the front of a @code{browser-gadget} instance. It
takes the parameters

@end defun

@defun gg:push-first-item browser-instance new-item

and adds the @emph{new-item} to the front of the
@emph{browser-instance}'s @code{:items} list and adjusts the bookkeeping
slots of the instance appropriately. A selection in the first menu is
highlighted only if a match is found with the title of the second menu
(which causes the browser to appear as though the second menu was
actually generated from clicking on the selection in the first menu).

@cindex{promote-item} The function @b{@code{promote-item}} is used to
install a new first item in an instance when the desired item already
appears as a selection in one of the scrolling menus. The function is
given the parameters
@end defun

@defun gg:promote-item browser-instance coordinate

where @emph{coordinate} is a list of two numbers
corresponding to the location of the desired item in the
@emph{browser-instance}. The syntax of the coordinate list is defined in
section @ref{additional}. If the item whose coordinate is passed is
highlighted, then all of the menus to the right of the selection are
retained; otherwise, the item becomes the only item in the instance.
@end defun

@section Polyline-Creator
@node Polyline-Creator
@anchor{polyline-creator}
@cindex{Polyline-Creator}
@cindex{polyline editing}

@center @image{polyline-creator, 5.5in}

@example
(create-instance 'gg:Polyline-Creator opal:aggregadget

    (:selection-function NIL) @i{; called when have full poly-line}
    (:start-event :leftdown)  @emph{; the event to start the whole process on}
    (:start-where NIL)        @i{; where the mouse should be when the start-event happens}
    (:running-where T)
    (:close-enough-value 3)   @i{; how close a point should be to the first point to stop the interaction}
    (:input-filter NIL)

    @emph{; Editing parameters}
    (:mover-start-event :leftdown)      @emph{; event to start moving a point}
    (:mover-stop-event :leftup)         @emph{; event to stop moving a point}
    (:adder-start-event :leftdown)      @emph{; event to add a point}
    (:deleter-start-event :middledown)  @emph{; event to delete a point}
    (:threshold 3)                      @emph{; how close to line to add a point}
    (:polyline-being-edited NIL)        @emph{; read-only slot}

    @emph{; Return value}
    (:value NIL) ;@emph{set with final point list}
@end example

The loader file for the @code{polyline-creator} gadget is
"polyline-creator-loader".
Examples of creating and editing polylines are in the GarnetDraw demo and the
small @code{(gg:polyline-creator-demo-go)} which is loaded by default with
the @code{polyline-creator}.

@cindex{polyline-creator-loader}

This gadget allows the user to enter new polylines (lists of points), while
providing feedback. It also supports polyline editing, meaning that
you can add, remove, and move points of a polyline with the mouse.

@subsection Creating New Polylines
@node Creating New Polylines

The user interface for creating polylines is as follows:  The user presses a
button (specified in
the @code{:start-event} slot) to start the interaction. Each subsequent button
press causes a new segment to be added to the line. Feedback is provided
to the user. The Polyline stops when:
@itemize
the new point is close enough (within @code{:close-enough-value} pixels) to
the first point of the polyline (in which case the polyline is closed).

a button pressed is different from the start event (in which case the
polyline is open).

the application calls the function @code{Stop-Polyline-Creator} (see below).
@end itemize

The gadget can also be aborted if the user types @code{^g} or the
application calls @code{abort-polyline-creator}.

The function in the @code{:selection-function} is called to create the new
polyline. This function should not destructively modify the point-list,
but should instead @emph{copy} the point-list if it will be changed. This
functions is called with the parameters
@example
(lambda (gadget new-point-list)
@end example
where @emph{new-point-list} is of the form: @code{(x1 y1 x2 y2 x3 y3 ...)}.

The @code{:input-filter} slot is used just as in the @code{move-grow-interactor}
and the @code{two-point-interactor}, described in the Interactors manual.

The @code{:value} slot is also set by the gadget with the final point-list.
Applications are not allowed to set this directly (there can be no default
value for this gadget).


@subsection Editing Existing Polylines
@node Editing Existing Polylines


@cindex{toggle-polyline-handles}
@code{gg:Toggle-Polyline-Handles @emph{polyline-creator-gadget  polyline} @ref{function}}

This function is used to display square "selection handles" on each point in
the polyline to enable editing. The @emph{polyline-creator-gadget} is passed
as an argument to this function, since the selection handles to be displayed
are components of the gadget.

To move a point,
click the left mouse button over the point, move it to a new position,
and release the left mouse button. Hitting @code{control-g} while moving a
point will abort the move. Clicking the left mouse button in the middle of
a line will add a point, after which the point can be dragged to a different
location. Clicking on the background while editing a polyline
will turn off the handles for the polyline.

There are several ways to delete points:  either hit the middle mouse button
over the point, double-click on the point, or hit the DELETE key while
moving the point.

When the @code{toggle-polyline-handles} function is called, it first checks
to see if the polyline is already being edited. If it is, it turns
off the handles for the polyline. Otherwise, it turns on the handles
for the polyline. Note that only one polyline can be edited at a
time. If you call this function while a polyline is already being
edited, it will turn off the handles for that polyline before turning
on the handles for the polyline to be edited.

There are five slots in the polyline gadget which specify what actions
cause editing. The slots and their default values are:

@vtable @code
@code{:mover-start-event} - Default = @code{:leftdown}. The event to start moving
a point.

@code{:mover-stop-event} - Default = @code{:leftup}. The event to stop moving a
point.

@code{:adder-start-event} - Default = @code{:leftdown}. The event to add a point.

@code{:deleter-start-event} - Default = @code{:middledown}. The event to delete a
point.

@code{:threshold} - Default = 3. How close you have to click next to a line
to add a point.
@end vtable

There is a slot in the gadget called @code{:polyline-being-edited}. This
slot will contain the polyline that is currently being edited, or NIL
if no polyline is being edited.


@subsection Some Useful Functions
@node Some Useful Functions


@defun gg:stop-polyline-creator gadget

This causes the gadget to create the current object. It ignores the
current mouse position. This is useful if some other gadget (such as a
palette changing the drawing mode) wants to stop the gadget. You can call
this even if the gadget is not operating.
@end defun



@defun gg:abort-polyline-creator gadget

This aborts the gadget without creating the polyline.
@end defun



@section Error-Gadget
@node Error-Gadget
@anchor{error-gadget}
@cindex{error-gadget}
@center @image{error-gadget-pix, 5.5in}

@example
(create-instance 'gg:Error-Gadget opal:aggregadget
   (:parent-window NIL)
   (:font opal:default-font)
   (:justification :center)
   (:modal-p T)
   (:beep-p T)
   (:button-name "OK")
   (:window NIL)               @emph{; Automatically initialized}
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   ...)
@end example

The loader file for the @code{error-gadget} is "error-gadget-loader".

The @code{error-gadget} is a dialog box used to tell the user that an
error has occurred. When activated, the user sees a window appear
with a multi-line text message and an "OK" button centered in the
window. If specified by the designer, all activities in the rest of
the interface will be suspended until the user clicks on the "OK"
button to cause the error window to disappear.

There is also a @code{motif-error-gadget}, which is described in section
@ref{motif-error-gadget}.

Some utility functions in section @ref{top-careful-eval} allow you to easily
raise an @code{error-gadget} in the context of checking user input for errors.

@b{Caveats:}
@itemize
Update the parent window before instantiating the error-gadget.

The instance of the error-gadget should @b{not} be added to an aggregate.
@end itemize


@subsection Programming Interface
@node Programming Interface

In order to associate an error window with an application, an instance
of the @code{error-gadget} should be created with the
@code{:parent-window} slot set to the window of the application. The
error window is activated by calling one of the functions
@cindex{display-error}
@cindex{display-error-and-wait}

@defun gg:display-error error-gadget &optional message
@defunx gg:display-error-and-wait error-gadget &optional message

where the parameter @emph{error-gadget} is the
instance created by the user and @emph{message} is a string to be
displayed in the window. If @emph{message} is not supplied, then the value
in the @code{:string} slot of the gadget is used. The message may have multiple
lines, indicated by carriage returns within the text string. While the
@code{display-error} routine returns immediately when the dialog box
appears, @code{display-error-and-wait} does not return until the user
hits the OK button. The return value of both functions is always T.

When the error-gadget is associated with a parent window, the
error window will appear centered inside of this window. If
@code{:parent-window} is NIL, then the error window will appear at
coordinates (200,200), relative to the upper left corner of the
screen.

The font of the message is specified in the @code{:font} slot. The
@code{:justification} slot is used to specify whether to align the text
against the left or right margin of the window or whether each line
should be centered in the window (allowed values are @code{:left},
@code{:right}, and @code{:center}).

If the value of the @code{:modal-p} slot is T, then all interactors in
the rest of the interface will be suspended, and the user will not be
able to continue working until the "OK" button has been pressed. If
@code{:modal-p} is NIL, then the interface will continue to function
with the error window visible.

If the @code{:beep-p} slot is T, then Garnet will sound a beep when the
gadget becomes visible. To turn off the beep, set @code{:beep-p} to NIL.

The @code{:button-name} slot determines the label of the button. Since the
@code{display-error} routines do @emph{not} take this as a parameter, it must
be set in the gadget itself.

After the instance of the @code{error-gadget} has been created, the
window which will contain the text and the button may be accessed
through the @code{:window} slot of the instance. Note: When the
@code{error-gadget} instance has a parent-window, the @code{:left} and @code{:top}
coordinates of this window will be relative to the parent-window.
Otherwise, they are relative to the full screen.
@end defun


@subsection Error-Checking and Careful Evaluation
@node Error-Checking and Careful Evaluation
@anchor{top-careful-eval}
@cindex{error-checking}

There are several functions that can be used to evaluate lisp expressions
that may contain errors, while avoiding a crash into the debugger. These
functions may be used to evaluate user input to make sure it is free of
errors before passing it on to the rest of an application. If the user
input contains an error (i.e., does not successfully evaluate), the
functions return a special value and can display an @code{error-gadget}
informing the user of the error.

These functions are more portable and more useful than implementation-dependent
functions like @code{ignore-errors}. These functions are used in many Garnet
applications and demos where information is supplied by the user. Examples
can be found in the @code{Inspector}, @code{demo-graph}, @code{garnet-calculator},
and the line and filling-style dialog boxes in Gilt.

All of the @code{careful-eval} functions are defined in @code{error-gadget-utils},
and are loaded automatically along with the error and query gadgets when you do
@code{(garnet-load "gadgets:error-gadget-loader")} or
@code{(garnet-load "gadgets:motif-error-gadget-loader")}.

These functions were inspired by the @code{protected-eval} module in the
Garnet @code{contrib} directory, created by Russell G. Almond.


@subsection Careful-Eval
@node Careful-Eval
@cindex{careful-eval}


@defmac gg:careful-eval form &optional error-gadget error-message


@code{Careful-Eval} will evaluate the @emph{form}. If an error is encountered
during the eval, then the @emph{error-gadget} will be displayed with the actual
lisp error message that was generated, followed by the specified
@emph{error-message} (separated by carriage returns).


When the evaluation is successful, @code{gg:Careful-Eval} returns the evaluated
value (which may be multiple values). If there was an error, then
@code{Careful-Eval} returns two values: NIL and the error condition structure.
(For a discussion of error conditions, see Chapter 29 of the Second Edition
of Guy Steele's @emph{Common Lisp, the Language}.)

Examples:

@example
@b{lisp>} (gg:careful-eval '(+ 4 5))    @emph{;; evaluates successfully}
9
@b{lisp>} (gg:careful-eval '(+ 4 y))    @emph{;; signals an error}
NIL
#<EXCL::SIMPLE-ERROR.0>
@b{lisp>} (multiple-value-bind (val errorp)
         (gg:careful-eval '(+ 4 y))
()       (if errorp   @emph{; perhaps} (typep errorp 'condition) @emph{is safer}
           (format t "An error was encountered~%")
           (format t "Value is ~S~%" val)))
An error was encountered

NIL
@b{lisp>}
@end example
@end defmac


@subsection Careful-Read-From-String
@node Careful-Read-From-String
@cindex{careful-read-from-string}

@example
gg:Careful-Read-From-String @emph{string} &optional @emph{error-gadget  error-message} @ref{function}
@end example

@code{Careful-Read-From-String} will try to read a symbol or expression from the
@emph{string} and return it if successful. If an error is encountered, then the
@emph{error-gadget} will be raised and two values will be returned: NIL and the
error condition. The message displayed in the error gadget will be a
concatenation of the actual lisp error message followed by the
@emph{error-message}.


@subsection Careful-String-Eval
@node Careful-String-Eval
@cindex{careful-string-eval}

@example
gg:Careful-String-Eval @emph{string} &optional @emph{error-gadget  error-message} @ref{function}
@end example

@code{Careful-String-Eval} will try to read a symbol or expression from the
string and then eval it. If the read and eval are successful, then the
evaluated value is returned. If there was an error during either the read
or eval, then the @emph{error-gadget} is raised and two values are returned:
NIL and the error condition. The message displayed in the error gadget will
be a concatenation of the actual lisp error message and the @emph{error-message}.


@subsection Careful-Eval-Formula-Lambda
@node Careful-Eval-Formula-Lambda
@cindex{careful-eval-formula-lambda}

@example
gg:Careful-Eval-Formula-Lambda @emph{expr  error-gadget  error-message} @ref{function}
                               @emph{the-obj  the-slot  the-formula  warn-p}
@end example

@code{Careful-Eval-Formula-Lambda} evaluates the expression AS IF it were
installed in @emph{the-slot} of @emph{the-obj} as a formula. This is useful when
the @emph{expr} contains @code{gvl} calls, which normally require that the @emph{expr}
is already installed in an @code{o-formula} when it is evaluated.
If the evaluation is successful, then the evaluated
value is returned. If there was an error during the eval, then the
@emph{error-gadget} is raised and two values are returned: NIL and the error
condition. The message displayed in the error gadget will be a
concatenation of the actual lisp error message followed by the
@emph{error-message}.

If a formula object has already been created for the expression, then it
should be passed as the value of @emph{the-formula}. This will cause dependencies
to be established as the @code{gv}'s and @code{gvl}'s are evaluated in the
expression. @emph{The-formula} may also have the value @code{:ignore}, which will
prevent the establishment of dependencies.

@sp 1
Example:

@example
@b{lisp>} (create-instance 'R opal:rectangle
        (:my-left 67))
Object R
#k<R>
@b{lisp>} (gg:careful-eval-formula-lambda '(gvl :my-left) NIL NIL
                                        R :left :ignore NIL)
67
@b{lisp>} 
@end example





@section Query-Gadget
@node Query-Gadget
@anchor{query-gadget}
@cindex{query-gadget}
@example
(create-instance 'gg:Query-Gadget gg:error-gadget
   (:button-names '("OK" "CANCEL"))
   (:string "Is that OK?")
   (:parent-window NIL)
   (:font opal:default-font)
   (:justification :center)
   (:modal-p T)
   (:beep-p T)
   (:window NIL)               @emph{; Automatically initialized}
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   ...)
@end example

The loader file for the @code{query-gadget} is "error-gadget-loader"
(the @code{query-gadget} is in the same file as the @code{error-gadget}).

The @code{query-gadget} is similar to the @code{error-gadget}, but it allows
more buttons in the window, so it is useful for a general purpose dialog
box. The button names are supplied in the @code{:button-names} slot of the
@code{query-gadget} or as a parameter to the display functions.
The use of the @code{query-gadget} is the same as the @code{error-gadget}
(and the same caveats apply). There is also a @code{motif-query-gadget},
which is described in section @ref{motif-query-gadget}.

To display a query-gadget, you first create an instance of
@code{query-gadget}, and then call one of:
@cindex{display-query}
@cindex{display-query-and-wait}
@example
display-query @emph{query-gadget} &optional @emph{message label-list}

display-query-and-wait @emph{query-gadget} &optional @emph{message label-list}
@end example
The @emph{message} is the string to display, and the optional @emph{label-list}
allows you to change the buttons. It should be a list of strings, atoms or
keywords. If @emph{message} is not supplied, then the value of the @code{:string}
slot of the gadget is used. This function displays the query-gadget on the
screen and then returns immediately. The @code{selection-function} of the query
gadget (if any) is called with the item from the label-list the user
selected. While the @code{display-query} routine returns immediately
when the dialog box appears, @code{display-query-and-wait} does not
return until the user hits one of the buttons. The return value
@code{display-query-and-wait} is the label of the selected button.


@section[Save Gadget]
@anchor{save-gadget}
@cindex{save-gadget}
@cindex{saving Garnet objects}

@example
(create-instance 'gg:Save-Gadget opal:aggregadget  
  (:maybe-constant '(:parent-window :window-title :window-left :window-top
		     :message-string :num-visible :initial-directory :button-panel-items
                     :button-panel-h-spacing :min-gadget-width :modal-p
                     :check-filenames-p :query-message :query-buttons
                     :dir-input-field-font :dir-input-label-font :message-font
                     :file-menu-font :file-input-field-font :file-input-label-font
                     :button-panel-font))
  (:parent-window NIL)
  (:window-title "save window")
  (:min-gadget-width 240)
  (:initial-directory "./")
  (:message-string "fetching directory...")
  (:query-message "save over existing file")
  (:button-panel-items '("save" "cancel"))
  (:button-panel-h-spacing 25)
  (:num-visible 6)
  (:check-filenames-p t)
  (:modal-p NIL)
  (:selection-function NIL)   @emph{; (lambda (gadget value))}

  (:dir-input-field-font (opal:get-standard-font NIL NIL :small))
  (:dir-input-label-font (opal:get-standard-font NIL :bold NIL))
  (:file-input-field-font (opal:get-standard-font NIL NIL :small))
  (:file-input-label-font (opal:get-standard-font NIL :bold NIL))
  (:message-font (opal:get-standard-font :fixed :italic :small))
  (:button-panel-font opal:default-font)
  (:file-menu-font (opal:get-standard-font NIL :bold NIL))
  ...)
@end example

@float Figure, fig:ex2
@center @image{save-gadget, 5.5in}
@caption{A save-gadget showing the contents of directory @code{/usr0/rajan/}}
@anchor{save-gadget-tag}
@end float

The loader file for the @code{save-gadget} is "save-gadget-loader" (which also
loads the @code{load-gadget}).
Figure @ref{save-gadget-tag} shows a picture of the save gadget.

The @code{save-gadget} is a dialog box used to save a file, while displaying
the contents of the destination directory in a scrolling menu. The gadget
has an accompanying query-gadget dialog box (not shown) that can ask the user
if the file really should be saved before the @code{save-gadget} appears. This
is an extra level of convenience for the application designer.

There is also a @code{motif-save-gadget}, as well as a @code{load-gadget} and
@code{motif-load-gadget}.

@sp 1
@b{Caveats:}
@itemize
Update the parent window before instantiating the save-gadget.

The instance of the save-gadget should @b{not} be added to an aggregate.
@end itemize


@subsection Programming Interface
@node Programming Interface

When a save gadget is created, it does not appear automatically.
Like the query and error gadgets, it has its own display function.
The save window is activated by calling one of these functions:

@cindex{display-save-gadget}
@cindex{display-save-gadget-and-wait}
@example
gg:Display-Save-Gadget @emph{save-gadget} &optional @emph{initial-filename}@value{function}

gg:Display-Save-Gadget-And-Wait @emph{save-gadget} &optional @emph{initial-filename}@value{function}
@end example

While the @code{display-save-gadget} routine returns immediately when the
dialog box appears, @code{display-save-gadget-and-wait} does not return
until the user hits either the "Save" or "Cancel" button.
If an @emph{initial-filename} is provided, it will appear in the "Filename:"
box when the gadget is displayed.

NOTE: To change the directory, set the @code{:initial-directory} slot of
the gadget to be the new directory. Then, when you call one of the
display methods, the directory will be updated.

To hide a save window, use
@cindex{hide-save-gadget}

@defun gg:hide-save-gadget save-gadget


The following function is described in section @ref{save-file-if-wanted-fn}.
@end defun

@defun gg:save-file-if-wanted save-gadget &optional filename (query-string "save file first")

When a save-gadget is first displayed, the "Directory" box will
contain the present directory (unless otherwise specified, as
explained in the next section); the scrolling-menu will have the
contents of that directory; and the "Filename" box will be blank.

@cindex{directories in save-gadget}
Whenever the directory name is changed by the user, the scrolling menu
will also change to list the contents of the new directory. If an invalid
directory name is specified, there will be a beep and the invalid name
will be replaced by the previous name. Whenever a directory is being
fetched, a brief message (by default, "Fetching directory...") will
appear, and will go away when the scrolling menu has been updated. When a
file name is typed into the "Directory" box, the file name will be moved
down to the "Filename" box, and the menu will be updated.

If a file in the scrolling menu is selected, then the "Filename"
box will contain the name of that file. If a directory is selected,
the "Directory" box will be set to the selected directory, and the
scrolling menu will once again update itself. 

If an invalid file name is typed into the "Filename" box, there will
be a beep and the "Filename" box will be reset. An invalid file name
is one that has a directory name in it ("/usr/garnet/foo", for
example). 

The following slots may be changed to customize the @code{save-gadget}:

@vtable @code
@code{:window-title} - contains the title of the save window, which is by
default "Save Window". Window managers usually do not display titles for
subwindows (i.e., if a window is specified in @code{:parent-window}).

@code{:parent-window} - if this slot contains a window, then the @code{save-gadget}
will appear as a subwindow of that window. By default, the
gadget will automatically be centered inside the parent window. If
this is not desired, the @code{:window-left} and @code{:window-top} slots can be
changed to position the gadget.

@code{:window-left} and @code{:window-top} - specify the coordinates of the dialog
box. Default values are 0 for both slots unless there is a parent
window.

@code{:initial-directory} - the directory to display when the @code{save-gadget}
appears. The default is "./", which is the current directory as determined
by the lisp process.

@code{:message-string} - the message to display to the user while the save
gadget fetches the contents of a new directory. Default is 
"Fetching directory...".

@code{:num-visible} - how many files to display in the scrolling menu.
Default is 6.

@code{:button-panel-items} - a list of names for the buttons. The default is
'("Save" "Cancel").
NOTE: It is important that, when you rename the buttons and use the
@code{default-save-function}, you rename them in the "Save" "Cancel" order.
That is, the label that should cause the gadget to save must appear first in
the @code{:items} list, and the label that cancels the gadget's action must
appear second. For example, if you rename the @code{:button-panel-items} slot
as '("Go" "Return"), it will produce the correct results. However, if you use
'("Return" "Go") instead, the wrong functions will get called.

@code{:button-panel-h-spacing} - the distance between the buttons (default 25).

@code{:min-gadget-width} specifies the width of the "Directory" and
"Filename" boxes. The scrolling menu is centered between them.

@code{:modal-p} - when T, then interaction in other Garnet windows will be
suspended untill either the "Save" or the "Cancel" button is hit.

@code{:check-filenames-p} - whether to check to see whether the file
already exists before saving. If the file exists, then a query gadget
will pop up and ask for confirmation.

@code{:query-message} - the string that will be used in the query
gadget that pops up when you try to overwrite a file. If
@code{:check-filenames-p} slot is NIL, this slot is ignored.

@code{:selection-function} - as usual, the function called when the "Save"
button is hit.

@code{:dir-input-field-font} and @code{:dir-input-label-font} - the fonts
for the field and label of the "Directory" box.

@code{:file-input-field-font} and @code{:file-input-label-font} - the fonts
for the field and label of the "Filename" box.

@code{:message-font} - the font to use for the message that appears
when the directory is being fetched.

@code{:file-menu-font} - the font of the items inside the scrolling menu

@code{:button-panel-font} - the font for the buttons

@end vtable
@end defun

@subsection Adding more gadgets to the save gadget
@node Adding more gadgets to the save gadget

It is possible to add more gadgets, such as extra buttons, etc. to the
save gadget. To do this, you simply add more components to the @code{:parts}
list of the save gadget (which is an aggregadget). However, you MUST
include the following 5 components in the parts list: @code{:dir-input},
@code{:file-menu}, @code{:file-input}, @code{:message}, and
@code{:OK-cancel-buttons}.

An example of adding more gadgets to a save gadget follows:
@example
(create-instance 'SG gg:save-gadget
  (:parts 
   `(:dir-input :file-menu :file-input :message :OK-cancel-buttons
     (:extra-button ,gg:text-button
      (:left 10) (:top 220)
      (:text-offset 2) (:shadow-offset 5) (:gray-width 3)
      (:string "Test")))))
@end example

This will, in addition to creating the standard save gadget parts, create
an additional button. This button can be accessed by using @code{(gv
SG :extra-button)}. Naturally, you can have selection functions, etc. to
whatever gadgets you add. However, it is extremely important to include
the @code{:dir-input}, @code{:file-menu}, @code{:file-input}, @code{:message} and
@code{:OK-cancel-buttons} in the @code{:parts} list.

NOTE: The save/cancel buttons automatically position themselves 25
pixels below the last gadget in the @code{:parts} list, since most people
desire the buttons at the bottom of the gadget. If this is not
desired, you can modify the @code{:top} slot of the @code{:OK-cancel-buttons}.


@subsection Hacking the Save Gadget
@node Hacking the Save Gadget

The slots described above should be enough to customize most
applications. However, when that is not the case, it is possible to
hack the save gadget.

For example, the save/cancel buttons are centered with respect to the
"Filename" box. If this is not desirable, the @code{:OK-cancel-buttons}
slot can be modified to the desired left and top coordinates.

Suppose the left of the save/cancel buttons should be at 10. The save
gadget then would look like:
@example
(create-instance 'sg gg:save-gadget	
  (:parts
    `(:dir-input 
      :message 
      :file-menu 
      :file-input
      (:OK-cancel-buttons :modify (:left 10)))))
@end example



@subsection The Save-File-If-Wanted function
@node The Save-File-If-Wanted function
@anchor{save-file-if-wanted-fn}

If you are using a menubar with a "File" menu, you might want to use the
@code{save-file-if-wanted} function. You would call this function before such
operations as quit, close, and read if the contents of the window had not
yet been saved. The format for this function is:

@defun gg:save-file-if-wanted save-gadget &optional filename (query-string "save file first)

This function will pop up a query gadget that asks "Save file first?", or
whatever you specify as the @emph{query-string}.
If "Yes" is selected, then it will call the standard
@code{display-save-gadget-and-wait} function on the given filename, and the
return value of this function will be the same as the return value for the
@emph{save-gadget}'s @code{:selection-function}.
If "Cancel" is selected, it will return @code{:CANCEL}. If "No" is
selected, it will return @code{:NO}.

For an example of when and where this function can be used, look at
the source code for Garnetdraw, under the section labeled "MENU
FUNCTIONS AND MENUBAR". The Open, New and Quit functions all call
this function.

Often, it is necessary to know if the "Cancel" button was hit or not.
For this purpose, the functions @code{save-file-if-wanted} and the
@code{display-save-gadget-and-wait} return @code{:cancel} if the "Cancel"
button was hit. For example, the quit function in Garnetdraw looks like
this:
@example
(defun quit-fun (gadget menu-item submenu-item)
  (unless (eq :cancel (gg:Save-File-If-Wanted *save-db* *document-name*))
    (do-stop)))
@end example

If the user clicks on "Cancel" either in the "Save file first?" query
box, or in the save-gadget itself, @code{save-file-if-wanted} will return
@code{:cancel}.
@end defun

@section[Load Gadget]
@cindex{load-gadget}
@anchor{load-gadget}

@example
(create-instance 'gg:Load-Gadget opal:aggregadget  
  (:maybe-constant '(:parent-window :window-title :window-left :window-top
                     :message-string :num-visible :initial-directory :button-panel-items
                     :button-panel-h-spacing :min-gadget-width :modal-p
                     :check-filenames-p :dir-input-field-font :dir-input-label-font
                     :message-font :file-menu-font :file-input-field-font
                     :file-input-label-font :button-panel-font))
  (:parent-window NIL)
  (:window-title "load window")
  (:min-gadget-width 240)
  (:initial-directory "./")
  (:message-string "fetching directory...")
  (:button-panel-items '("load" "cancel"))
  (:button-panel-h-spacing 25)
  (:num-visible 6)
  (:check-filenames-p t)
  (:modal-p nil)
  (:selection-function NIL)   @emph{; (lambda (gadget value))}

  (:dir-input-field-font (opal:get-standard-font nil nil :small))
  (:dir-input-label-font (opal:get-standard-font nil :bold nil))
  (:file-input-field-font (opal:get-standard-font nil nil :small))
  (:file-input-label-font (opal:get-standard-font nil :bold nil))
  (:message-font (opal:get-standard-font :fixed :italic :small))
  (:button-panel-font opal:default-font)
  (:file-menu-font (opal:get-standard-font nil :bold nil))
  ...)
@end example

The @code{load-gadget} is loaded along with the @code{save-gadget} by the file
"save-gadget-loader".

The @code{load-gadget} is very similar to the @code{save-gadget}. Both look alike,
except for their window titles. The same caveats apply to both the save and
load gadgets (see section @ref{save-gadget}).

The @code{load-gadget} has its own functions for displaying and hiding the
gadget, which are analogous to those used by the @code{save-gadget}:

@defun gg:display-load-gadget load-gadget &optional initial-filename
@defunx gg:display-load-gadget-and-wait load-gadget &optional initial-filename
@defunx gg:hide-load-gadget load-gadget


When a load gadget is created and @code{display-load-gadget} is called,
the window that pops up contains the same initial contents as in the
save gadget. The "Directory" box, the scrolling-menu, and the
message, all work identically in both the gadgets.

The "Filename" box resembles the save gadget in that it beeps when an
invalid file name is typed in (unless the @code{:check-filenames-p} slot is
NIL), and is reset to the empty string, "". However, an invalid file
name is defined as a file name that does not exist, or a directory. 

As in the save gadget, when you rename the buttons and use the default
load function, it is important to put the name corresponding to the
"Load" button as the first element of the @code{:button-panel-items} list.
@end defun


@section Property Sheets
@node Property Sheets
@anchor{propertysheets}
@cindex{Property sheets}

The @code{prop-sheet} gadget takes a list of values to display, and
@code{prop-sheet-for-obj} takes a KR object to display. The
@code{prop-sheet-with-OK} and @code{prop-sheet-for-obj-with-OK} gadgets
combine a property sheet with OK, Apply and Cancel buttons and
functions to display these in windows (using the Garnet look and
feel). Similarly, the @code{motif-prop-sheet-with-OK} and
@code{motif-prop-sheet-for-obj-with-OK} combine a property sheet with
buttons, but use the Motif look and feel (see section @ref{motif-prop-sheets}).

@subsection User Interface
@node User Interface

Press on the value of a slot with the left button to begin typing. Press with
the left button again (anywhere) or hit @code{return} or @code{^j}
to stop editing
(if multi-line
strings are allowed, then @code{return} goes to the next line, so you need to use
@code{^j} or left button to stop editing). Pressing with any other button
inside the string moves the cursor. Regular editing operations are
supported (see the text-interactor in the Interactors manual). If you
hit @code{tab}, the cursor will move to the next field.
If label selection is enabled, then labels can be selected by pressing
with any mouse button. If value selection is enabled, then values must be
selected with the @emph{right} button while they are not being edited. Selected
labels or values are displayed in bold.

@subsection Prop-Sheet
@node Prop-Sheet
@anchor{propsheetsec}

@cindex{prop-sheet}
@example
(create-instance 'gg:Prop-Sheet opal:aggregadget
    (:maybe-constant '(:left :top :items :default-filter :v-spacing
		       :multi-line-p :select-label-p :visible
		       :label-selected-func :label-select-event
		       :select-value-p :value-selected-func :single-select-p))
   @emph{; Customizable slots}
    (:left 0) (:top 0)
    (:items NIL) @emph{; put the values to be displayed here}
    (:default-filter 'default-filter)
    (:v-spacing 1)
    (:pixel-margin NIL)
    (:rank-margin NIL)
    (:multi-line-p NIL) @emph{; T if multi-line strings are allowed}
    (:select-label-p NIL) @emph{; T if want to be able to select the labels}
    (:label-selected-func NIL)
    (:label-select-event :any-mousedown)
    (:select-value-p NIL) @emph{; if want to be able to select the values}
    (:value-selected-func NIL)
    (:single-select-p NIL) @emph{; to select more than one value or label}

   @emph{; Read-only slots}
    (:label-selected NIL) @emph{; set with the selected label objects (or a list)}
    (:value-selected NIL) @emph{; set with the selected value objects (or a list)}
    (:value ...)  @emph{; list of pairs of all the slots and their (filtered) values}
    (:changed-values NIL)) @emph{; only the values that have changed}
@end example

@float Figure, fig:ex2
@center @image{propplain, 5.5in}
@caption{Example of a property sheet with an embedded gadget.}
@anchor{plainproppix}
@end float

The loader for the @code{gg:prop-sheet} gadget is "prop-sheet-loader".

@sp 1

@b{Customizable slots:}

@vtable @code
@code{:left}, @code{:top} - Position of the gadget. Default: 0,0

@code{:items} - The control list of the items to be displayed in the gadget.
The format for the list is a list of lists, as follows:
@code{( (label1 stringval1 [filter1 [realval1 [comment]]]) (label2 ...) )}

@itemize
The @code{labels} can be atoms or strings, and are shown at the left.

The @code{stringval} is the initial (default) value displayed. For an example
of the use of the various forms of @code{stringval}, see section
@ref{propexample}. It can be:
@itemize
a string,

a formula object which computes a string. Note
that all references in the formula must be absolute
(since otherwise they would be relative to the property sheet).

an instance of a gadget (e.g., a @code{radio-button-panel}), in which case
that instance is used instead of an editable text field.
Note that the instance itself is used, so it will be destroyed if the
@code{prop-sheet} is destroyed.
The gadget instance should supply its value in a slot called @code{:value}
(as the standard garnet gadgets do). NOTE: If a gadget, no
filter functions are called (use the @code{:selection-function}
of the gadget), the @code{realval} is ignored, and the @code{:changed-values} slot
is not valid. Useful gadgets are described
in section @ref{propusefulgadgets}.
@end itemize

If the @code{filter} is non-NIL, it is a function called after the 
user types the value (see below).

The @code{realval}, if supplied, is the actual value the @code{stringval}
represents (e.g. if the real values are not strings). If
@code{stringval} is a list of strings, then @code{realval} should be a list 
of the same length.

If supplied, the @code{comment} is displayed after the label.
It can be any string, and will be displayed
after the slot label. Typical uses would be to
give legal values (e.g.: "(1..20)"). 
@end itemize

@code{:default-filter} - If there is no filter on an individual item, then the
global default-filter function is called when the user finishes 
editing. See below. The default filter does nothing.

@code{:v-spacing} - Vertical space between the items. Default = 1

@code{:pixel-margin} - Multiple-valued items are represented as an aggrelist,
so this determines the maximum pixel value of an item, before
wrapping to the next line. Note that this does @emph{not} affect single
valued items. Default: NIL
 
@code{:rank-margin} - Same as @code{:pixel-margin}, but is a count of the number of
values. Default: NIL

@code{:multi-line-p} - Whether the user can enter multi-line strings, 
which means that @code{return} does not exit a field, but makes a new line.
Default: NIL.

@code{:select-label-p} - Whether pressing on the label (with any mouse
button) causes the item to be selected. Default: NIL.

@code{:label-select-event} - If you want to make the labels selectable,
you can specify which mouse event to use in the slot @code{:label-select-event}.

@code{:label-selected-func} - Called with @emph{(gadget label-obj label)}
when a label is selected.

@code{:select-value-p} - Whether pressing on the value (with the right button)
causes the value to be selected. NOTE: Values which are specified as
gadgets cannot be selected. Default: NIL.

@code{:value-selected-func} - Called when a value is selected with
@emph{(gadget value-obj value label)} where label is the label of that
field.

@code{:single-select-p} - Whether a single label or value can be
selected (T) or multiple fields can be selected (NIL). This is only
relevant if one or both of @code{:select-label-p} or
@code{:select-value-p} is non-NIL. Default: NIL.

@end vtable
 
@b{Read-only (output) slots:}

@vtable @code
@code{:label-selected} - Will be set with a list of the selected label objects.
Call @code{Get-Val-For-PropSheet-Value} to get label name from the label object.

@code{:value-selected} - Will be set with a list of the selected value objects.
Call @code{Get-Val-For-PropSheet-value} on an obj to get the value and
label from the value object.

@code{:value} - List of all the slots and their (filtered) values. For example:
@code{( (label1 value1) (label2 value2) ...)}.

@code{:changed-values} - List of the slots that have changed, as:
@code{( (label1 value1) (label2 value2) )}
This slot is not kept valid if a gadget is used as an item.
@end vtable

@b{Filter functions:}

The filter functions allow the program to convert the string values
to the appropriate form. The displayed string and the "real"
value are stored separately, so they can be different. Filter functions are
defined as:
@code{(lambda (prop-sheet-gadget label value-obj new-str old-str))}

The @emph{index} is used for multi-valued slots, and otherwise is zero.
The @emph{value-obj} is the actual object used to display the string, and will
be needed only by hackers.
The filter function can return the value to use (modified @emph{new-str}, not
necessarily a string) or it can return three values:
@code{(new-val in-valid-p new-str)}
where @emph{new-val} is a value (not necessarily a string) to use, @emph{in-valid-p}
is T if the new-str value is invalid (bad), in which case the @emph{new-str} is
still used, but it is shown in italic. If @emph{new-str} is returned, then it is 
displayed instead of what the user typed (for example if the filter function
expands or corrects the typed value).

An example of a custom filter function is shown in section @ref{propexample}.

@subsection Prop-Sheet-For-Obj
@node Prop-Sheet-For-Obj
@anchor{propsheetforobj}
@cindex{Prop-Sheet-For-Obj}

When you want to display a property sheet for a Garnet object, you can
use @code{prop-sheet-for-obj}. The prop-sheet can directly access the
@code{:parameters} list of a Garnet object, which is a list of the slots
normally customizable for the object. You can also display and modify
slots of @emph{multiple} objects simultaneously. Gilt makes heavy use of
many features in this prop-sheet.

@example
(create-instance 'gg:Prop-Sheet-For-Obj gg:prop-sheet
    (:maybe-constant '(:left :top :obj :slots :eval-p :set-immediately-p
		       :v-spacing :multi-line-p :select-label-p
		       :label-selected-func :label-select-event :visible
		       :select-value-p :value-selected-func :single-select-p
		       :type-gadgets :union? :error-gadget))
    (:left 5)
    (:top 5)
    (:obj NIL)   ;@emph{ a single obj or a list of objects}
    (:slots NIL) ;@emph{ list of slots to show. If NIL, get from :parameters}
    (:union? T)  ;@emph{if slots is NIL and multiple objects, use union or intersection of :parameters?}

    (:eval-p T)  @emph{; if T, then evaluates what the user types. Use T for}
		 @emph{; graphical objects. If NIL, then all the values will be strings.}
    (:set-immediately-p T) @emph{; if T then sets slots when user hits @code{return}, else doesn't}
			   @emph{; ever set the slot.}
    (:type-gadgets NIL) ;@emph{ descriptor of special handling for types}
    (:error-gadget NIL) ;@emph{ an error gadget to use to report errors.}

    ;; @emph{plus the rest of the slots also provided by prop-sheet}

    (:v-spacing 1)
    (:pixel-margin NIL)
    (:rank-margin NIL)
    (:multi-line-p NIL)    @emph{; T if multi-line strings are allowed}
    (:select-label-p NIL)  @emph{; T if want to be able to select the labels}
    (:label-select-event :any-mousedown)
    (:label-selected-func NIL)
    (:select-value-p NIL)  @emph{; if want to be able to select the values}
    (:value-selected-func NIL)
    (:single-select-p NIL) @emph{; to select more than one value or label}

   @emph{; Read-only slots}
    (:label-selected NIL)  @emph{; set with the selected label objects (or a list)}
    (:value-selected NIL)  @emph{; set with the selected value objects (or a list)}
    (:value ...)  @emph{; list of pairs of all the slots and their (filtered) values}
    (:changed-values NIL)) @emph{; only the values that have changed}
@end example
 

@float Figure, fig:ex2
@center @image{propforobj, 5.5in}
@caption{Example of a property sheet for an object (the object is
shown at the upper left).}
@end float

The loader for @code{prop-sheet-for-obj} is "prop-sheet-loader".

@b{Customizable slots:}

@vtable @code
@code{:left}, @code{:top} - Position of the gadget. Default: 0,0

@code{:obj} - The KR object or list of objects to be displayed. If this slot
contains a list of objects, then if multiple objects share a slot which is
displayed, then the value from the first object is shown. If the values from
multiple objects differ, then the slot value is shown in italics. If
the user edits the value, then it is set into each object which has that slot
in its @code{:parameters} list.

@code{:error-gadget} - An error-gadget may be placed in this slot.
Type checking is performed before setting a slot, and any errors are reported
in this error gadget. If there is no error gadget, then the error
message is simply not displayed, but a beep is sounded and the slot
value is shown in italics.

@code{:slots} - The list of slots of the object to view. Default value is NIL,
which means the prop-sheet should get the list of slots from the
@code{:parameters} slot of the object being edited (see @code{:union?}).
When relying on @code{:parameters}, the property sheet will use
the @code{Horiz-Choice-List} gadget for slots of type @code{KR-boolean}
and @code{(Member ...)} where the number of options is 5 or less
(see also @code{:type-gadgets}). If the type of a slot has a documentation
string, gotten using
@code{kr:get-type-documentation}, then this is displayed as the slot
comment field.

Alternatively, any element in the list can be a slot name or a sublist:
(@emph{slot} "@emph{comment}" @emph{display}):
@itemize
If the @var{comment} is non-nil, it is displayed after the label.

If the @var{display} parameter is supplied, it can either be:
@itemize
A list of legal values for the slot, e.g. 
@code{'(:direction (:horizontal :vertical))}

A function of the form @code{(lambda (new-val))} which returns T if the
value is bad. This function might pop up an error dialog box after
testing but before returning. The slot keeps its illegal value, but
it is shown in italics.

A gadget, in which case the @code{:value} slot of the gadget is set with
the old value, and the @code{:value} slot is queried to get the final value.
If gadgets are used, then @code{:set-immediately-p} for the property
sheet should be NIL. A useful gadget is
@code{Pop-Up-From-Icon}.
@end itemize
@end itemize

@code{:union?} - This affects which slots are shown for objects when their
@code{:parameters} lists are being used. If there are multiple objects, then
a value of T for this slot will display the slots that are in @emph{any} of
the objects. If the value of this slot is NIL, then only those slots that
appear in @emph{all} of the @code{:parameters} lists (the intersection of the lists)
will be displayed. The default is T, to show the union of all @code{:parameters}
lists.

@code{:eval-p} - If NIL, then the values set into the slots will be all strings.
If T, then evaluates what the user types (using
@code{Read-From-String}) and sets the result into the slot. Usually,
you use T when displaying the graphical fields of graphical 
objects. Default=T. NOTE: Evaluating a slot may cause the
interface to crash if the values are not valid.

@code{:set-immediately-p} - If T, then as soon as the user types CR, the object's
slot is set. If NIL, some external action must set the object's
slots (e.g., when using @code{prop-sheet-for-obj-with-OK}, the object's
slots are not set until the OK button is hit). Default=T.

@code{:type-gadgets} - This slot is used to
modify the default displays for slots from the @code{:parameters} list.
@code{:Type-gadgets} contains a list which can contain the following entries:
@itemize
a slot name - this means never display this slot (omit the slot even
though it is in the @code{:parameters} list).

a list of @code{(typ gadget)} - this means whenever a slot of type
@code{typ} is displayed in the prop-sheet, use the specified gadget.
For example, Gilt uses this mechanism to display a
@code{Pop-Up-From-Icon} for all slots which contain a font:
@example
(list (g-type opal:text :font)
      (create-instance NIL gg:Pop-Up-From-Icon
	(:constant :icon-image :pop-up-function)
	(:creator-function 'Show-Font-Dialog)
	(:pop-up-function 'Pop-Up-Prop-Dialog)))
@end example

a list of @code{(typ othertyp)} - this means whenever a slot of type
@code{typ} is found, pretend instead that it has type @code{othertyp}.
This is useful, for example, to map types that are complicated to ones that
will generate a @code{member} gadget.
@end itemize
@end vtable

 
The slots @code{:v-spacing}, @code{:pixel-margin}, @code{:rank-margin},
@code{:multi-line-p},
@code{:select-label-p}, @code{:label-select-event},
@code{:label-selected-func}, @code{:select-value-p}, 
@code{:value-selected-func}, and @code{:single-select-p} are the same as for
the @code{prop-sheet} gadget.

@b{Read-only (output) slots (same as @code{Prop-Sheet})}

@vtable @code
@code{:label-selected}

@code{:value-selected}

@code{:value}

@code{:changed-values}
@end vtable





@subsection Useful Functions
@node Useful Functions

@cindex{ReUsePropSheet}

@defun gg:reusepropsheet prop-sheet-gadget new-items

@code{ReUsePropSheet} allows you to re-use an old @code{prop-sheet} or a
@code{prop-sheet-with-OK} gadget with a new set of values, which is much
more efficient than destroying and creating a new @code{prop-sheet}.
NOTE: it is NOT sufficient to simply @code{s-value} the @code{:items} slot.
If you plan to reuse property sheets, do not declare the @code{:items}
slot constant.
@end defun

@defun gg:reusepropsheetobj prop-sheet-for-obj &optional obj slots

@code{ReUsePropSheetObj} allows a @code{prop-sheet-for-obj} or
@code{prop-sheet-for-obj-with-OK} gadget to be re-used. If the
new @emph{obj} and @emph{slots} are @emph{not} supplied, then they should be
set into the object before this function is called. NOTE: it is NOT
sufficient to simply @code{s-value} the @code{:obj} and @code{:slots} slot.
@end defun


@defun gg:Get-Val-For-Propsheet-Value (label-or-value-obj)
The @code{Get-Val-For-PropSheet-Value} function returns the label when
a label is passed in, or for a value-obj, returns multiple values:
@code{value label}, where @emph{label} is the label (name, not object) of that
field.

@cindex{Set-val-for-propsheet-value}
If you want to change the value of a property sheet item without
regenerating a new property sheet, you can use the new function
@code{Set-Val-For-PropSheet-Value}. This takes the form:
@end defun

@defun gg:set-val-for-propsheet-value label-or-value-obj new-value

The @emph{label-or-value-obj} parameter is the object used by the
property-sheet to represent the field.
@end defun


@subsection Prop-Sheet-With-OK
@node Prop-Sheet-With-OK
@anchor{propsheetwithok}
@cindex{Prop-Sheet-With-OK}

The next set of gadgets combine property sheets with OK, Apply and
Cancel buttons. There are two pairs: one for Garnet look-and-feel
gadgets, and one for Motif look-and-feel gadgets (see section
@ref{motif-prop-sheets} for the Motif version).

@example
(create-instance 'gg:Prop-Sheet-With-OK opal:aggregadget
    (:maybe-constant '(:left :top :items :default-filter :ok-function
		       :apply-function :Cancel-Function :v-spacing
		       :multi-line-p :select-label-p  :visible
		       :label-selected-func :label-select-event
		       :select-value-p :value-selected-func :single-select-p))
   @emph{; Customizable slots}
    (:left 0) (:top 0)
    (:items NIL)
    (:default-filter 'default-filter)
    (:OK-Function NIL)
    (:Apply-Function NIL)
    (:Cancel-Function NIL)
    (:v-spacing 1)
    (:pixel-margin NIL)
    (:rank-margin NIL)
    (:multi-line-p NIL) @emph{; T if multi-line strings are allowed}
    (:select-label-p NIL) @emph{; T if want to be able to select the entries}
    (:label-select-event :any-mousedown)
    (:label-selected-func NIL)
    (:select-value-p NIL)
    (:value-selected-func NIL)
    (:single-select-p NIL)

   @emph{; Read-only slots}
    (:label-selected ...)
    (:value-selected ...)
    (:value ...)
    (:changed-values ...))
@end example

The @code{prop-sheet-with-OK} gadget is just the @code{prop-sheet} gadget
with Garnet text buttons for OK, Apply, and Cancel.

The loader for @code{prop-sheet-with-OK} is "prop-sheet-win-loader".

@b{Customizable slots}

@vtable @code

@code{:OK-Function} - Function called when the OK button is hit. Defined as:

@code{(lambda (Prop-Sheet-With-OK-gadget))}
Typically, this would do something with the values gotten from
@code{(gv Prop-Sheet-With-OK-gadget :values)  or}
@code{(gv Prop-Sheet-With-OK-gadget :changed-values).}
If you use the @code{Pop-Up-Win-For-Prop} functions, then the window
will be removed before the @code{OK-function} is called, so you do not
have to worry about the window.

@code{:Apply-Function} - Function called when the Apply button is hit.
Defined as:

@code{(lambda (Prop-Sheet-With-OK-gadget)}
Typically, this would do something with the values gotten from
@code{(gv Prop-Sheet-With-OK-gadget :values)  or}
@code{(gv Prop-Sheet-With-OK-gadget :changed-values).}

@code{:Cancel-Function} - Function called when Cancel button is hit. Defined as:
@code{(lambda (Prop-Sheet-With-OK-gadget))}
Programmers typically would not use this.
If you use the @code{Pop-Up-Win-For-Prop} functions, then the window
will be removed before the @code{Cancel-function} is called, so you do not
have to worry about the window.
@end vtable
 
The rest of the slots are the same as for @code{prop-sheet}.

@subsection Prop-Sheet-For-Obj-With-OK
@node Prop-Sheet-For-Obj-With-OK
@anchor{propsheetforobjwithok}
@cindex{Prop-Sheet-for-obj-With-OK}

@example
(create-instance 'gg:Prop-Sheet-For-Obj-With-OK prop-sheet-with-OK
    (:maybe-constant '(:left :top :obj :slots :eval-p :ok-function
		       :apply-function :Cancel-Function :v-spacing
		       :multi-line-p :select-label-p :visible
		       :label-selected-func :label-select-event
		       :select-value-p :value-selected-func :single-select-p))
   @emph{; Customizable slots}
    (:OK-Function NIL)
    (:Apply-Function NIL)
    (:Cancel-Function NIL)
    (:left 0) (:top 0)
    (:obj NIL)   @emph{; a single obj or a list of objects}
    (:slots NIL) @emph{; list of slots to show. If NIL, get from :parameters}
    (:eval-p T)  @emph{; if T, then evaluates what the user types. Use T for}
		 @emph{; graphical objects. If NIL, then all the values will be strings.}
    (:set-immediately-p T) @emph{; if T then sets slots when user hits @code{return}, else doesn't}
			   @emph{; ever set the slot.}
    (:type-gadgets NIL) @emph{; descriptor of special handling for types}
    (:error-gadget NIL) @emph{; an error gadget to use to report errors.}

    ;; @emph{plus the rest of the slots also provided by prop-sheet}

    (:v-spacing 1)
    (:pixel-margin NIL)
    (:rank-margin NIL)
    (:multi-line-p NIL)   @emph{; T if multi-line strings are allowed}
    (:select-label-p NIL) @emph{; T if want to be able to select the labels}
    (:label-select-event :any-mousedown)
    (:label-selected-func NIL)
    (:select-value-p NIL) @emph{; if want to be able to select the values}
    (:value-selected-func NIL)
    (:single-select-p NIL) @emph{; to select more than one value or label}

   @emph{; Read-only slots}
    (:label-selected NIL) @emph{; set with the selected label objects (or a list)}
    (:value-selected NIL) @emph{; set with the selected value objects (or a list)}
    (:value ...)  @emph{; list of pairs of all the slots and their (filtered) values}
    (:changed-values NIL)) @emph{; only the values that have changed}

@end example

The @code{prop-sheet-for-obj-with-OK} gadget is just the
@code{prop-sheet-for-obj} gadget with Garnet text buttons for OK, Apply,
and Cancel.

The loader for @code{prop-sheet-for-obj-with-OK} is "prop-sheet-win-loader".

Given a list of slots for a KR object, displays the values and
allows them to be edited. The labels and values can optionally be selectable.
Sets the object's slot only when OK or Apply is hit. (So
@code{:set-immediately-p} is always NIL).

@b{Customizable slots}

@vtable @code

@code{:OK-Function} - Function called when the OK button is hit. Defined as:
@code{(lambda (Prop-Sheet-For-Obj-With-OK-gadget))}
Since this gadget will set the slots of the object automatically when
OK is hit (before this function is called) and the window
visibility is handled automatically, programmers
rarely need to supply a function here.

@code{:Apply-Function} - Function called when the Apply button is hit.
Defined as:
@code{(lambda (Prop-Sheet-For-Obj-With-OK-gadget))}
Since this gadget will set the slots of the object automatically when
Apply is hit (before this function is called), programmers
rarely need to supply a function here.

@code{:Cancel-Function} - Function called when Cancel button is hit. Defined as:
@code{(lambda (prop-sheet-for-obj-with-ok-gadget))}  Since
the window visibility is handled automatically, programmers
rarely need to supply a function here.

@end vtable



@subsection Useful Functions
@node Useful Functions


@defun gg:pop-up-win-for-prop prop-gadget-with-ok left top title &optional modal-p

Given an existing gadget of any of the "OK" types, this function pops
up a window which will show the
property sheet, and will go away when the user hits either "OK" or
"Cancel". The window is allocated by this function to be the correct
size. When the @emph{modal-p} parameter is T, then interaction in all other
Garnet windows will be suspended until the user clicks either the "OK" or
"Cancel" button in this window. This function can be called many times on the
@b{same} gadget, which is much more efficient than allocating a new gadget and
window each time. To change the items or object before redisplaying, use one
of the functions below.
@end defun


@defun gg:pop-up-win-change-items prop-gadget-with-ok new-items left top title &optional modal-p

Given an existing gadget, @code{Pop-Up-Win-Change-Items} sets the items
field of the gadget
to the specified value, and then pops up a window displaying that
property sheet. (This function calls @code{ReUsePropSheetObj}
automatically). (Note: if you want to pop up a
@code{Prop-Sheet-With-OK} or @code{Motif-Prop-Sheet-With-OK} gadget
without changing the @emph{items} field, you can simply pass it to
@code{Pop-Up-Win-For-Prop}.
@end defun

@defun gg:pop-up-win-change-obj prop-obj-gadget-with-ok obj slots left top title &optional modal-p

Given an existing gadget, @code{Pop-Up-Win-Change-Obj} sets the @emph{obj}
and @emph{slot} fields of the gadget
to the specified values, and then pops up a window displaying that
property sheet. (This function calls @code{ReUsePropSheetObj}
automatically). (Note: if you want to pop up a
@code{Prop-Sheet-For-Obj-With-OK} or
@code{Motif-Prop-Sheet-For-Obj-With-OK} gadget without
changing the @emph{obj} and
@emph{slot} fields, you can simply pass it to @code{Pop-Up-Win-For-Prop}.
@end defun

@subsection Useful Gadgets
@node Useful Gadgets
@anchor{propusefulgadgets}

This section describes two gadgets that are useful in property sheet
fields as the values. Both of these gadgets are shown in Figure
@ref{motifpropfix}.

@subsection Horiz-Choice-List
@node Horiz-Choice-List
@cindex{horiz-choice-list}
The @code{horiz-choice-list} displays the choices and allows the user to
pick one with the left mouse button. The choices can be strings or
atoms.

@example
(create-instance 'gg:Horiz-Choice-List opal:aggregadget
   (:maybe-constant '(:left :top :items))
   @emph{; Customizable slots}
   (:left 0) @emph{; left and top are set automatically when used in a prop-sheet}
   (:top 0)
   (:items '("one" "two" "three")) @emph{; the items to choose from}
   @emph{; Input and output slot}
   (:value NIL) @emph{; what the user selected}
   )
@end example

The loader for @code{Horiz-Choice-List} is "prop-values-loader",
although it is automatically loaded when you load a property sheet.

The @code{Horiz-Choice-List} is automatically used when you list a set
of legal values for the display parameter for a
@code{prop-sheet-for-obj}.

@subsection Pop-Up-From-Icon
@node Pop-Up-From-Icon
@cindex{Pop-Up-From-Icon}
The @code{Pop-Up-From-Icon} displays a small icon, and if the user hits
on it, then a function is called which can pop-up a dialog box or
menu to make the choice.

@example
(create-instance 'gg:Pop-Up-From-Icon opal:aggregadget
  (:maybe-constant '(:left :top :icon-image :pop-up-function))
  @emph{; Customizable slots}
  (:left 0) @emph{; left and top are set automatically when used in a prop-sheet}
  (:top 0)
  (:icon-image pop-up-icon) @emph{; you can replace with your own picture}
  (:pop-up-function NIL))   @emph{;put a function here to pop-up the menu or whatever}
@end example

The loader for @code{Pop-Up-From-Icon} is "prop-values-loader",
although it is automatically loaded when you load a property sheet.

The @code{pop-up-function} is called when the user presses with the left
button and then releases over the icon. It is called as follows:
@code{(lambda(pop-up-from-icon-gadget))}
It should stuff its results into the @code{:value} field of that gadget.
See the manual on Gilt for some functions that are useful for popping
up dialog boxes and menus.

@subsection Property Sheet Examples
@node Property Sheet Examples
@anchor{propexample}

First, an example filter function, which checks if value is a number,
and if it is between 1 and 20.
@example
(defun string-to-num-filter (prop-gadget label index value-obj new-str old-str)
  (declare (ignore prop-gadget label index value-obj))
  (let* ((sym (read-from-string new-str))
	 (number (when (integerp sym) sym)))
    (if (and number (>= number 1) (<= number 20))
	@emph{; then OK, return the converted number}
	(values number NIL new-str) 
	@emph{; else bad, return original string and T to say invalid}
	(progn
	  (inter:beep) @emph{; first, beep}
	  (values new-str T new-str)))))
@end example

Now, we will use that filter function in a property sheet. This code creates
the property sheet shown in Figure @ref{plainproppix} in section
@ref{propsheetsec}. It contains three regular lines, a slot using a
gadget, and then a slot with a filter function and a comment.

@example
(create-instance 'PROP1 garnet-gadgets:prop-sheet 
   (:items `((:color "Red")
             (:height "34")
	     (:status "Nervous")
	     (:direction ,(create-instance NIL garnet-gadgets:horiz-choice-list
			    (:items '("up" "down" "diagonal"))))
	     (:range "1" ,#'string-to-num-filter 1 "(1..20)"))))
@end example

Finally, a Motif look and feel property sheet for an object with OK, Apply and
Cancel buttons in it. The @code{my-rectangle1} object is only changed when OK
or Apply is hit. The resulting window is shown in Figure
@ref{motifpropfix}.

@example
(create-instance 'MY-OBJ-PROP gg:motif-prop-sheet-for-obj-with-OK
  (:left 0)
  (:top 0)
  (:obj MY-RECTANGLE1)
  (:slots `(:left @emph{; first four slots are normal}
	    :top
	    :width
	    :height 
	    (:quality (:good :medium :bad)) @emph{;list of options}
	    @emph{; next two slots use pop-up icon gadgets}
	    (:line-style ,(create-instance NIL gg:pop-up-from-icon
			    (:pop-up-function #'Line-Style-Pop-Up)))
	    (:filling-style ,(create-instance NIL gg:pop-up-from-icon
			       (:pop-up-function #'Fill-style-pop-up))))))
@end example



@section Mouseline
@node Mouseline
@cindex{MouseLine}
@cindex{Balloon Help}
@cindex{Documentation Line}
@cindex{Help Line}
@cindex{mode line}
@cindex{who line}
@cindex{Mouse Documentation Line}
There are two new gadgets that will show a help string attached to any
object. The string can be shown in a fixed location in a
window using the @code{MouseLine} gadget, and therefore is like the
@b{mouse documentation line} on Symbolics Lisp
machines (sometime called the 
``mode line'' or ``who line'').
Alternatively, the help string can pop up in a window using 
the @code{MouseLinePopup} gadget, and therefore be
like @b{Balloon Help} in the Macintosh System 7. You can also control
whether the string appears immediately or only after the mouse is over
an object for a particular period of time.

An example of the use of the two mouseline gadgets is
@code{gg:mouseline-go} which is at the end of the @code{mouseline.lisp}
file. The standard @code{demos-controller} which you get when you load
@code{garnet-demos-loader} also uses the @code{MouseLinePopup} gadget to
show what the different demos do.

Note: the mouseline gadget is implemented in a rather inefficient
manner. It has the potential to significantly slow down applications,
especially when the delay feature is used (@code{:wait-amount} non-zero).
If this proves to be a big problem in practice, please let us know.

Note 2: the delay feature is implemented with multiple processes, which
are only supported in Allegro and Lucid lisp.

@subsection MouseLine gadget
@node MouseLine gadget

@example
(create-instance 'gg:MouseLine opal:aggregadget
  (:left 5)
  (:top (o-formula (- (gvl :window :height)  ; @emph{default is bottom of window}
		      (gvl :label :height)
		      5))) 
  (:windows (o-formula (gvl :window)))  ; @emph{default is the window containing the mouseline gadget}
  (:wait-amount 0)   ; @emph{how long to wait before displaying the string}
@end example

The loader file for the @code{MouseLine} is @code{mouseline-loader}.

You create an instance of the @code{mouseline} gadget and add it to a
window. By default it is positioned at the bottom left, but you can
override the @code{:top} and @code{:left} to position it where-ever you
want. Once created, the string will display the value of the
@code{:help-string} field for any object the mouse is over in the window
or windows specified in the @code{:windows} slot. By default
@code{:windows} is only the window that the @code{mouseline} gadget is in,
but it can be any list of windows, or T for all interactor windows.

@cindex{Help-string slot}
The gadget first looks at the leaf object under the mouse, and if that
does not have a help-string, then its parent (aggregate) is looked at,
and so on. The lowest-level help string found is displayed in the
string. The string can contain newlines but not font information (the
display is a @code{opal:multi-text} not a @code{opal:multifont-text}).
Of course, the @code{:help-string} slot can contain a formula, which
might, for example, generate a different string when a gadget is
disabled explaining why.

If the mouseline gadgets catch on, we might provide a way
to specify the help-strings as part of the standard @code{:items}
protocol for gadgets, but for now you need to @code{s-value} the
@code{:help-string} slots directly. See the @code{demos-controller} for how
this might be done.

If the @code{:wait-amount} slot is non-zero, then it is the number of
seconds the mouse must remain over an object before the mouseline
string is displayed. This feature relies on the @code{animation-interactor}
which uses the multi-process mechanism in Lisp, @b{so the @code{:wait-amount} is
only currently available in Lucid, Allegro, and LispWorks.}

@subsection MouseLinePopup gadget
@node MouseLinePopup gadget
@cindex{MouseLinePopup}

@example
(create-instance 'gg:MouseLinePopup opal:aggregadget
  (:start-event :SHIFT-CONTROL-META-LEFTDOWN)
  (:windows (o-formula (gvl :window))) ; @emph{default is the window containing the mouseline gadget}
  (:wait-amount 3) ; @emph{how long to wait before displaying string}
@end example

The loader file for the @code{MouseLinePopup} is @code{mouseline-loader}.

This displays the same help-string as the @code{mouseline} gadget above,
but the string is displayed in a window which pops up at the mouse.
Therefore it is like ``Balloon Help'' in the Macintosh System 7.
The window is just big enough for the string, and it goes away when
you move off of the object. The @code{:wait-amount} determines how long
in seconds you must keep the mouse over the object before the window
appears.





@section Standard Edit
@node Standard Edit
@anchor{standardeditsec}
@cindex{Standard Edit}

There are a number of editing functions that are
shared by most graphical editors. The file @code{standard-edit.lisp}
supplies many of these functions in a manner that can probably be used by
your graphical editors without change. They support such operations
such as cut, copy, paste, delete, duplicate, group, ungroup, refresh,
to-top, to-bottom, etc. These functions are designed to work with the
@code{Multi-Graphics-Selection} gadget, and can be invoked from buttons,
menus, or a menubar. 
The @code{standard-edit} functions
are currently used by GarnetDraw, Gilt and Marquise. 
You don't have to use all the functions in an application. For
example, Gilt does not support grouping and ungrouping.
(If you find that changing a @code{standard-edit} routine will allow
it to be useful to your application, let us know.)

The @code{standard-edit} routines can be loaded using
@code{(garnet-load "gg:standard-edit-loader")}.

@subsection General Operation
@node General Operation

The @code{standard-edit} routines assume that the graphical objects that
are to be edited are all in a single aggregate in a single window
(extensions to handle multiple windows are planned, but not in place
yet). The routines are tightly tied to the design of the
@code{Multi-Graphics-Selection} gadget. For example, most routines
determine which objects to operate on by looking at the current
selection, and many change the selection.

@code{Standard-edit} determines how to edit objects by
looking at various slots. The slots listed below are set in the @b{selected}
objects, not in the selection gadget itself. Most Garnet prototypes already
contain the correct default values:

@vtable @code
@code{:line-p} - if non-NIL, then the object is controlled by a
@code{:points} list of 4 values. True by default for @code{opal:line} and
@code{gg:arrow-line}s.

@code{:polygon-p} -  if non-NIL, then the object is controlled by a
@code{:point-list} list of multiple values. True by default for
@code{opal:polyline}s. 

@code{:group-p} - if non-NIL, then the object is a group of objects that the
user might be able to get the parts of. True by default for
@code{opal:aggregadget}s. If you allow high-level objects to be added
in your editor (e.g., gadgets like buttons), and you supply the
@code{Standard-Ungroup} command, you should set the @code{:group-p} slot
of any objects you don't want the user to ungroup to be NIL. 

@code{:grow-p} - whether the object can change size or not.
@end vtable

If the object has @code{:line-p} and @code{:polygon-p} both NIL, then it
is assumed to be controlled by a @code{:box} slot.

The various routines find information they need by looking in a
special slots of the gadget that invokes them. This means that all
routines must be invoked from the same gadget set, for example, the
same @code{menubar} or @code{motif-button-panel}.


@subsection The Standard-Edit Objects
@node The Standard-Edit Objects

The @code{gg:Clipboard-Object} holds the last object that was cut or
copied. It also contains some parameters used for pasting and
duplicating the objects. Each application can have its own
clipboard, or a set of applications can share a clipboard to allow cut
and paste among applications. For example, GarnetDraw and Gilt both share
the same clipboard, so you can cut and paste objects between the two
applications. By default, all applications share the
one @code{gg:Default-Global-Clipboard}.

Note that this does @emph{not} use the X cut buffer, since there is no
standard way to copy graphics under X. 

@cindex{Clipboard-Object}
@example
(create-instance 'gg:Clipboard-Object NIL
  (:value NIL)
  (:x-inc-amt NIL)  ; @emph{Offset for duplicate. If NIL, then uses 10}
  (:y-inc-amt NIL))

(create-instance 'gg:Default-Global-Clipboard gg:Clipboard-Object)
@end example

The @code{Default-Global-Clipboard} is used by default, and allows
objects to be copied from one Garnet application to another.


@subsection Standard Editing Routines
@node Standard Editing Routines

@cindex{Standard-Initialize-Gadget}
@example
gg:Standard-Initialize-Gadget @emph{gadget  selection-gadget  agg-of-items} @ref{function}
                              &key @emph{clipboard  undo-delete?}
@end example

This routine must be called once before any of the others are invoked.
Typically, you would call this after the editor's windows and objects
are created. It takes the @code{gadget} that is going to invoke the
standard-edit routines (e.g., a menubar), the selection gadget that
is used to select objects in the graphics editor, and the aggregate
that holds the items created in the graphics editor. 
If you do not supply a @code{clipboard} object, then
@code{Default-Global-Clipboard} will be used.

Unfortunately, there is not yet a global undo facility, but you can
support undoing just the delete operations. The @code{undo-delete?}
flag tells standard-edit whether you want this or not. If non-NIL,
then deleted objects are never destroyed, they are just saved in a
list.

@cindex{Standard-NIY}
@example
gg:Standard-NIY @emph{gadget} &rest @emph{args} @ref{function}
@end example

Useful for all those functions that are @b{N}ot @b{I}mplemented
@b{Y}et. It prints "Sorry, Not Implemented Yet" in the Lisp listener
window and beeps.


@cindex{Standard-Delete}
@example
gg:Standard-Delete @emph{gadget} &rest @emph{args} @ref{function}
@end example
Deletes all the selected objects. Makes there be no objects selected.

@cindex{Standard-Delete-All}
@example
gg:Standard-Delete-All @emph{gadget} &rest @emph{args} @ref{function}
@end example
Deletes all the objects. Makes there be no objects selected.

@cindex{Standard-Undo-Last-Delete}
@example
gg:Standard-Undo-Last-Delete @emph{gadget} &rest @emph{args} @ref{function}
@end example
If you have initialized standard-edit with @code{Undo-delete?} as
non-NIL, then this function will undo the last delete operation. The
objects brought back are selected.

@cindex{Standard-To-Top}
@example
gg:Standard-To-Top @emph{gadget} &rest @emph{args} @ref{function}
@end example
Moves the selected objects to the top (so not covered). They stay selected.

@cindex{Standard-To-Bottom}
@example
gg:Standard-To-Bottom @emph{gadget} &rest @emph{args} @ref{function}
@end example
Moves the selected objects to the bottom (so covered by all other
objects). They stay selected.

@cindex{Standard-Refresh}
@example
gg:Standard-Refresh @emph{gadget} &rest @emph{args} @ref{function}
@end example
Simply redraws the window containing the objects using
@code{(opal:update win T)}.

@cindex{Standard-Select-All}
@example
gg:Standard-Select-All @emph{gadget} &rest @emph{args} @ref{function}
@end example
Causes all of the objects to be selected.

@cindex{Standard-Cut}
@example
gg:Standard-Cut @emph{gadget} &rest @emph{args} @ref{function}
@end example
Copies the selected objects into the clipboard's cut buffer, and then
removes them from the window. Afterwards, there will be no selection.

@cindex{Standard-Copy}
@example
gg:Standard-Copy @emph{gadget} &rest @emph{args} @ref{function}
@end example
Copies the selected objects into the clipboard's cut buffer, but
leaves them in the window. The selection remains the same.

@cindex{Standard-Paste-Same-Place}
@example
gg:Standard-Paste-Same-Place @emph{gadget} &rest @emph{args} @ref{function}
@end example
Pastes the objects in the clipboard into the window at the same place
from which they were cut. Pasting the same objects multiple times
will give multiple copies, all in the same place. An application will
typically provide either @code{Standard-Paste-Same-Place} or
@code{Standard-Paste-Inc-Place} as the ``paste'' operation. The new
objects will be selected.

@cindex{Standard-Paste-Inc-Place}
@example
gg:Standard-Paste-Inc-Place @emph{gadget} &rest @emph{args} @ref{function}
@end example
Pastes the objects in the clipboard into the window offset from where 
they were cut. Pasting the same objects multiple times
will give multiple copies, each offset from the previous. The offset
amount is determined by the @code{:x-inc-amt} and @code{:y-inc-amt} slots
of the clipboard object, or, if NIL, then 10 is used. The new
objects will be selected.

@cindex{Standard-Duplicate}
@example
gg:Standard-Duplicate @emph{gadget} &rest @emph{args} @ref{function}
@end example
Makes a copy of the selected objects, and places them back into the
window, offset from the previous objects by @code{:x-inc-amt} and
@code{:y-inc-amt} (or 10 if these are NIL). The new
objects will be selected.

@cindex{Standard-Group}
@example
gg:Standard-Group @emph{gadget} &rest @emph{args} @ref{function}
@end example
Creates an @code{aggregadget} and puts the selected objects into it.
The @code{Multi-Graphics-Selection} gadget will then operate on the
group as a whole, and will not let parts of it be manipulated (like
MacDraw, but unlike Lapidary). The group (aggregadget) object will be
selected.

@cindex{Standard-UnGroup}
@example
gg:Standard-UnGroup @emph{gadget} &rest @emph{args} @ref{function}
@end example
Goes through all the selected objects, and for any that have the
@code{:group-p} slot non-NIL, removes all the components from that
aggregate and adds the objects directly to the parent of the group.
@code{:Group-p} is true by default for @code{opal:aggregadget}s. If you allow
high-level objects to be added 
in your editor (e.g., gadgets like buttons), and you supply the
@code{Standard-Ungroup} command, you should set the @code{:group-p} slot to be NIL
for any objects you don't want the user to ungroup.

@subsection Utility Procedures
@node Utility Procedures

@cindex{sort-objs-display-order}
@example
gg:Sort-Objs-Display-Order @emph{objs draw-agg} @ref{function}
@end example
For many operations, it is important to operate on the objects in
display order, rather than in the order in which the objects were
selected. @code{Sort-Objs-Display-Order} takes a list of objects
(@emph{objs}) and an aggregate that contains them (@emph{draw-agg}) and
sorts the objects so they are in the same order as in @emph{draw-agg}.
The procedure returns a @b{copy} of the list passed in, so it is safe
to supply the @code{:value} of the @code{Multi-Graphics-Selection} gadget,
for example.

@cindex{Is-A-Motif-Background}
@example
gg:Is-A-Motif-Background @emph{obj} @ref{function}
@end example
Tests whether the specified object is a @code{Motif-Background} object.
This procedure is safe even if the Motif gadgets have not been loaded.

@cindex{Is-A-Motif-Rect}
@example
gg:Is-A-Motif-Rect @emph{obj} @ref{function}
@end example
Tests whether the specified object is a @code{Motif-Rect} object.
This procedure is safe even if the Motif gadgets have not been loaded.




@section The Motif Gadget Objects
@node The Motif Gadget Objects

@anchor{Motif-Gadgets}

The Motif gadgets in the Gadget Set were designed to simulate the
appearance and behavior of the OSF/Motif widgets. They are analogous
to the standard gadgets of Chapter @ref{Standard-Gadgets}, and many of
the customizable slots are the same for both sets of gadgets.

As in the previous chapter, the descriptions of the Motif gadgets
begin with a list of customizable slots and their default values (any
of which may be ignored). The @code{motif-gadget-prototype} object which
occurs in the definition of each Motif gadget is just an instance of
an @code{opal:aggregadget} with several color, filling-style, and line-style
slot definitions used by all Motif gadgets.
@cindex{Motif-gadget-prototype}

The Motif gadgets have been implemented to appear on either color or
black-and-white screens without changes to the instances.
The @code{:foreground-color} slot is used to compute filling-styles internally
on a color screen, and it is ignored on a black-and-white screen. Figure
@ref{color-and-bw-motif} shows how a few of the Motif gadgets look on each
type of screen.

@float Figure, fig:ex2
@center @image{color-motif-pix, 5.5in}
@center @image{bw-motif-pix, 5.5in}
@caption{Motif style gadgets on color and black-and-white screens}
@anchor{color-and-bw-motif}
@end float


@section Useful Motif Objects
@node Useful Motif Objects

In order to facilitate the construction of interfaces containing Motif
gadgets, Garnet exports some miscellaneous objects that are commonly
found in Motif. The objects described in this section are defined in
the "motif-parts" file (automatically loaded with all Garnet Motif-style
"-loader" files).


@subsection Motif Colors and Filling Styles
@node Motif Colors and Filling Styles

@cindex{Motif colors}
@cindex{Motif filling styles}
In each Motif gadget, there is a slot for the color of the gadget.
The @code{:foreground-color} is the color that should be shown in the foreground
of the gadget (i.e., the part of the gadget that does not appear recessed).
The background, shadow, and highlight colors for the gadget are computed
internally based on the @code{:foreground-color} given.

@sp 1
The default @code{:foreground-color} for the gadgets is @code{opal:motif-gray},
but the user may provide any instance of @code{opal:color} in the slot.
Additionally, Opal provides the following colors for use
with the Motif gadgets. The associated filling styles may be of use in other
objects designed by the programmer.

@table @code
opal:motif-gray

opal:motif-blue

opal:motif-green

opal:motif-orange

opal:motif-light-gray

opal:motif-light-blue

opal:motif-light-green

opal:motif-light-orange

opal:motif-gray-fill

opal:motif-blue-fill

opal:motif-green-fill

opal:motif-orange-fill

opal:motif-light-gray-fill

opal:motif-light-blue-fill

opal:motif-light-green-fill

opal:motif-light-orange-fill
@end table

When the Motif gadgets are used on a black-and-white monitor, the gadgets
ignore the @code{:foreground-color} slot and internally compute reasonable
filling-styles that are black, white, or Opal halftones.


@subsection Motif-Background
@node Motif-Background

@example
(create-instance 'gg:Motif-Background opal:rectangle
   (:foreground-color opal:motif-gray))
@end example

In order to simulate the Motif three-dimensional effect in an interface,
there should be a gray background in a window containing Motif-style
gadgets. Garnet provides two ways to achieve this effect. You could
add an instance of the @code{motif-background} object to the window,
which is a rectangle whose dimensions conform to the size of the
window in which it appears.

Alternately, you could supply the @code{:background-color} of your window
with an appropriate Opal @code{color} object (like
@code{opal:motif-gray}). This is generally more efficient, since it is
faster to redraw a window with its background color than to redraw a
rectangle that occupies the entire window.

@b{NOTE:} If you choose to use the @code{motif-background} object, it is
essential that the instance be added to the top-level aggregate before
any other Garnet object. This will ensure that the background is
drawn @b{behind} all other objects in the window.

Of course, the @code{:foreground-color} of the @code{motif-background}
instance or the @code{:background-color} of the window
should be the same as the colors of all the Motif gadgets in the window.

@subsection Motif-Tab-Inter
@node Motif-Tab-Inter
@cindex{Motif-tab-inter}

@example
(create-instance 'gg:Motif-Tab-Inter inter:button-interactor
   (:window NIL)
   (:objects NIL)
   (:rank 0)
   (:continuous NIL)
   (:start-where T)
   (:start-event '(#\tab :control-tab))
   (:waiting-priority gg:motif-tab-priority-level)
   (:running-priority gg:motif-tab-priority-level)
   (:stop-action #'(lambda (interactor obj-over) ...))
   (:final-function NIL))
@end example

Each Motif gadget has the ability to be operated by the keyboard as
well as the mouse. In traditional Motif interfaces, the keyboard
selection box is moved within each gadget with the arrow keys, and it
is moved among gadgets with the tab key (i.e., one gadget's keyboard
selection is activated while the previous gadget's keyboard selection
is deactivated). The keyboard interface can be manually
activated by setting a Motif gadget's @code{:keyboard-selection-p} to T, but the
bookkeeping becomes formidable when there are a large number of Motif
gadgets on the screen and their keyboard status is changing.
Thus, Garnet provides the @code{motif-tab-inter} which handles the bookkeeping
among multiple Motif gadgets. 

To use the @code{motif-tab-inter}, create an instance with
a list of the Motif gadgets on which to operate in the
@code{:object} slot and the window of the objects in the @code{:window}
slot. Usually, these are the only two slots that will need to be set.

Repeatedly hitting the tab key (or simultaneously hitting @code{control} and
@code{tab} will cause the keyboard selection to cycle through the list of
objects. Specifically, hitting the tab key causes the
@code{:rank} of the @code{motif-tab-inter} to be incremented, and the interactor
checks the @code{:active-p} slot of the next object in the @code{:object} list.
If the result is T, then that object's @code{:keyboard-selection-p} slot is
set to T. Otherwise, the @code{:rank} is incremented again and the next object
is checked.

The @code{:active-p} slots of the "continuous" Motif gadgets -- the scroll bars,
slider, and gauge -- all default to T, while the @code{:active-p} slots of the
Motif buttons and menu depend on the items in the @code{:inactive-items} list.

The @code{:running-priority} and @code{:waiting-priority} of the
@code{motif-tab-inter} are both set to be @code{motif-tab-priority-level},
which is a higher priority than the default interactor priority levels
(but lower than the @code{error-gadget}'s @code{error-priority-level}). This
allows the @code{motif-tab-inter} to be used at the same time as the
@code{inter:text-interactor} (as in the @code{motif-scrolling-labeled-box}).

The function in the @code{:final-function} slot is executed whenever the
current selection changes. It takes the parameters
@code{(lambda (inter new-object))}

Examples of the @code{motif-tab-inter} in use may be found in demo-motif
and in all three Motif button demos.


@section Motif Scroll Bars
@node Motif Scroll Bars
@anchor{motif-scroll-bars}
@cindex{Motif-v-scroll-bar}
@cindex{Motif-h-scroll-bar}

@example
(create-instance 'gg:Motif-V-Scroll-Bar gg:motif-gadget-prototype
   (:maybe-constant '(:left :top :width :height :val-1 :val-2 :scr-incr
		      :page-incr :scr-trill-p :percent-visible :scroll-p
		      :foreground-color :visible))
   (:left 0)
   (:top 0)
   (:width 20)
   (:height 200) 
   (:val-1 0)
   (:val-2 100)
   (:scr-incr 1)
   (:page-incr 5) 
   (:scr-trill-p T) 
   (:percent-visible .5)
   (:scroll-p T)
   (:keyboard-selection-p NIL)
   (:foreground-color opal:motif-gray)
   (:value (o-formula ...))
   (:active-p T)
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example
@sp 1

@example
(create-instance 'gg:Motif-H-Scroll-Bar gg:motif-gadget-prototype
   (:maybe-constant '(:left :top :width :height :val-1 :val-2 :scr-incr
		      :page-incr :scr-trill-p :percent-visible :scroll-p
		      :foreground-color :visible))
   (:left 0)
   (:top 0)
   (:width 200)
   (:height 20)
   (:val-1 0)
   (:val-2 100)
   (:scr-incr 1)
   (:page-incr 5) 
   (:scr-trill-p T)
   (:percent-visible .5)
   (:scroll-p T)
   (:keyboard-selection-p NIL)
   (:foreground-color opal:motif-gray)
   (:value (o-formula ...))
   (:active-p T)
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@center @image{motif-scroll-pix, 5.5in}

The loader file for the
@code{motif-v-scroll-bar} is "motif-v-scroll-loader". The loader file
for the @code{motif-h-scroll-bar} is "motif-h-scroll-loader".

The Motif scroll bars allow the specification of the minimum and maximum
values of a range, while the @code{:value} slot is a report of the
currently chosen value in the range. The interval is determined by
the values in @code{:val-1} and @code{:val-2}, and either slot may be the
minimum or maximum of the range. The value in @code{:val-1} will
correspond to the top of the vertical scroll bar and to the left of the
horizontal scroll bar. The @code{:value} slot may be accessed directly
by some function in the larger interface, and other formulas in the
interface may depend on it. If the @code{:value} slot is set directly,
then the appearance of the scroll bar will be updated accordingly.

The trill boxes at each end of the scroll bar allow the user to
increment and decrement @code{:value} by the amount specified in
@code{:scr-incr}. The designer may choose to leave the trill boxes out
by setting @code{:scr-trill-p} to NIL.

The indicator may also be moved directly by mouse movements. Dragging
the indicator while the left mouse button is pressed will change the
@code{:value} accordingly. A click of the left mouse button in the
background trough of the scroll bar will cause the @code{:value} to increase or
decrease by @code{:page-incr}, depending on the location of the
indicator relative to the mouse click.

When @code{:keyboard-selection-p} is T, then a black-selection box is
drawn around the scroll bar and the indicator can be moved with the
arrow keys (uparrow and downarrow for the @code{motif-v-scroll-bar},
leftarrow and rightarrow for the @code{motif-h-scroll-bar}).

The @code{:percent-visible} slot contains a value between 0 and 1, and is used to
specify the length of the indicator relative to the length of the trough.
If @code{:percent-visible} is .5, then the length of the
indicator will be half the distance between the two trill boxes. This
feature might be useful in a scrolling menu where the length of the
indicator should correspond to one "page" of items in the menu (e.g., for
three pages of items, set @code{:percent-visible} to .33).

The slots @code{:scroll-p} and @code{:active-p} are used to enable and disable the
scrolling feature of the scroll bar. When either is set to NIL, the
trill boxes of the scroll bar become inactive and the indicator cannot
be moved. The difference is that when @code{:active-p} is set to NIL, then
the keyboard selection cannot be enabled.

@section Motif Slider
@node Motif Slider
@anchor{Motif-Slider}

@example
(create-instance 'gg:Motif-Slider gg:motif-v-scroll-bar
   (:maybe-constant '(:left :top :height :trough-width :val-1 :val-2
		      :scr-incr :page-incr :scr-trill-p :text-offset
		      :scroll-p :indicator-text-p :indicator-font
		      :foreground-color :visible))
   (:left 0) 
   (:top 0) 
   (:height 200)
   (:trough-width 16)
   (:val-1 0)
   (:val-2 100)
   (:scr-incr 1)
   (:page-incr 5)
   (:scr-trill-p NIL)
   (:text-offset 5)
   (:scroll-p T)
   (:indicator-text-p T)
   (:keyboard-selection-p NIL)
   (:indicator-font opal:default-font)
   (:foreground-color opal:motif-gray)
   (:value (o-formula ...))
   (:active-p T)
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   (:parts (...)))
@end example

@center @image{motif-slider-pix, 5.5in}

@cindex{motif-slider} The loader file for the @code{motif-slider} is
"motif-slider-loader".

The @code{motif-slider} is similar to the @code{motif-v-scroll-bar},
except that it has a fixed-size indicator with accompanying text
feedback. The mouse can be used to drag the indicator, and the arrow
keys can be used when keyboard-selection is activated.

The slots @code{:value}, @code{:val-1}, @code{:val-2}, @code{:scr-incr},
@code{:page-incr}, @code{:scr-trill-p}, @code{:scroll-p}, @code{:active-p} and
@code{:keyboard-selection-p} all have the same functionality as in the
@code{motif-v-scroll-bar}.

The @code{:trough-width} slot determines the width of the scroll-bar
part of the slider. The actual @code{:width} of the gadget is not
user-settable because of the changing value feedback width.

The current @code{:value} of the slider is displayed beside the trough
if @code{:indicator-text-p} is T. The font of the indicator text is in
@code{:indicator-font}. The distance from the indicator text to the
trough is in @code{:text-offset}.


@section Motif-Trill-Device
@node Motif-Trill-Device
@anchor{motif-trill-device}
@cindex{motif-trill-device}

@center @image{motif-trill-pix, 5.5in}
		
@example
(create-instance 'gg:Motif-Trill-Device gg::motif-gadget-prototype
  (:left 0) (:top 0) 
  (:width 150) (:height 40)
  (:val-1 0) (:val-2 100)
  (:value 20)
  (:foreground-color opal:motif-gray)
  (:format-string "~a")
  (:value-feedback-font opal:default-font)
  (:value-feedback-p T)
  (:scroll-incr 1)
  (:selection-function NIL)   @emph{; (lambda (gadget value))}
  )
@end example

The loader file for the @code{motif-trill-device} is "motif-trill-device-loader".
The demo @code{(gg:motif-trill-go)} is loaded by default, and shows an example of
the @code{motif-trill-device}.

The @code{motif-trill-device} is a simple incrementing/decrementing gadget with
trill boxes and a numerical display.
The behavior is identical to the standard @code{trill-device} -- click on the
left or right arrows to change the value, and click the left mouse button on
the text to edit it.

The slots @code{:val-1} and @code{:val-2} contain the upper and lower bounds for
the value of the gadget. Either slot may be the minimum or maximum, and either
slot may be NIL (indicating no boundary). If a value less than the minimum
allowed value is entered,
the value of the gadget will be set to the minimum, and analogously for the
maximum. Clicking on the left trill box always moves the value closer to
@code{:val-1}, whether that is the max or min, and clicking on the right trill
box always moves the value closer to @code{:val-2}.

The current value of the gadget is stored in the @code{:value} slot, and may
be set directly using @code{s-value}. The @code{:scroll-incr} slot specifies
the increment for changing the value with the trill boxes.
All other slots work the same as in the standard @code{trill-device}. See
section @ref{trill-device} for more information.

The @code{:foreground-color} slot specifies the color of the object.


@section Motif Gauge
@node Motif Gauge
@anchor{motif-gauge}
@cindex{Motif-gauge}

@example
(create-instance 'gg:Motif-Gauge gg:motif-gadget-prototype
   (:maybe-constant '(:left :top :width :title :foreground-color :title-font
		      :value-font :enum-font :num-marks :tic-marks-p
		      :enumerate-p :value-feedback-p :text-offset :val-1 :val-2
		      :scr-incr :format-string :enum-format-string :visible))
   (:left 0)
   (:top 0)
   (:width 230)
   (:title "Motif Gauge")
   (:foreground-color opal:motif-gray)
   (:title-font opal:default-font)
   (:value-font opal:default-font)
   (:enum-font (create-instance NIL opal:font (:size :small)))
   (:num-marks 10)             @emph{; Includes endpoints}
   (:tic-marks-p T)
   (:enumerate-p T)
   (:value-feedback-p T)
   (:text-offset 5)
   (:val-1 0)
   (:val-2 180)
   (:scr-incr 5)
   (:format-string "~a")       @emph{; How to print the feedback value}          
   (:enum-format-string "~a")  @emph{; How to print the tic-mark values}
   (:keyboard-selection-p NIL)
   (:value (o-formula ...))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@center @image{motif-gauge-pix, 5.5in}

The @code{motif-gauge} is a semi-circular meter with tic-marks around the
perimeter. As with scroll bars and sliders, this object allows the user to
specify a value between minimum and maximum values. An arrow-shaped polygon
points to the currently chosen value, and may be rotated either by dragging
it with the mouse or by the arrow keys when keyboard selection is activated.
Text below the gauge reports the current value to which the needle is pointing.

The slots @code{:num-marks}, @code{:tic-marks-p}, @code{:enumerate-p}, @code{:val-1},
@code{:val-2}, and @code{:enum-font} are implemented as in the standard Garnet
sliders (see section @ref{sliders}). The value in @code{:val-1} corresponds to
the right side of the gauge.

The title of the gauge is specified in @code{:title}. No title will
appear if @code{:title} is NIL. The fonts for the title of the gauge
and the current chosen value are specified in @code{:title-font} and
@code{:value-font}, respectively.

If @code{:value-feedback-p} is T, then numerical text will appear below the
gauge indicating the currently chosen value. The value in @code{:text-offset}
determines the distance between the gauge and the title string, and between
the title string and the value feedback.

The @code{:format-string} and @code{:enum-format-string} slots allow you to
control the formatting of the text strings, in case the standard formatting
is not appropriate. This is mainly useful for floating point numbers.
The slots should each contain a string that can be passed to the lisp function
@code{format}. The default string is @code{"~a"}.

Setting @code{:keyboard-selection-p} to T activates the keyboard interface to
the @code{motif-gauge}. The left and right arrow keys can then be used to
change the value of the gauge. The increment by which the value of the gauge
changes during each press of an arrow key is in @code{:scr-incr}.




@section Motif Buttons
@node Motif Buttons
@anchor{motif-buttons}

@float Figure, fig:ex2
@center @image{motif-buttons-pix, 5.5in}
@caption{Motif Text Buttons, Check Buttons, and Radio Buttons}
@end float

As with the standard Garnet buttons, the Motif buttons can be either a single,
stand-alone button or a panel of buttons. Use of the Motif gadgets is
identical to the use of standard Garnet buttons in the following respects
(see Section @ref{buttons}).

@enumerate
All slots that can be customized in an aggrelist can be customized in the
Motif button panels.

The @code{:value} slot contains the string or atom of the currently selected
item (in the @code{motif-check-button-panel} this value is a list of selected
items). In button panels, the currently selected component of the panel's
aggrelist is named in the @code{:value-obj} slot.

The @code{:width} and @code{:height} of button panels are determined internally,
and may not be set directly. Instead, refer to the slots
@code{:fixed-width-size} and @code{:fixed-height-size}. The @code{:width} and
@code{:height} slots may be accessed after the object is instantiated.

The @code{:items} slot can be either a list of strings, a list of atoms, or a
list of string/function or atom/function pairs (see section @ref{items-slot}).

The font in which the button labels appear may be specified in the @code{:font}
slot.

Most of the buttons and button panels have a @code{:toggle-p} slot that
controls whether buttons can become deselected. If the value of this
slot is T, then clicking on a selected button deselects it. Otherwise,
the button always stays selected, though the @code{:selection-function}
and the item functions will continue to be executed each time the
button is pressed.
@end enumerate

The following slots provide additional functionality for the Motif buttons:

@enumerate

In single Motif buttons, if the @code{:active-p} slot is NIL, then the string of
the button appears in "grayed-out" text and the button is not user selectable.

Analogously, the @code{:inactive-items} slot of the Motif button panels contains
a list of strings or atoms corresponding to the members of the @code{:items}
list. The text of each item listed in @code{:inactive-items} will appear
"grayed-out" and those buttons will not be user selectable. If @code{:active-p}
is set to NIL, then all items will appear "grayed-out".

@cindex{keyboard-selection}
When the slot @code{:keyboard-selection-p} is T, the keyboard interface to the
button gadgets is activated. The arrow keys will move the selection box among
the buttons in a button panel, and the space-bar will select the boxed
button. The component of the button panel aggrelist currently surrounded by
the selection box is named in
@code{:keyboard-selection-obj}, and its string is in @code{:keyboard-selection}.
Thus, the slot @code{:keyboard-selection} may be set with a string (or an atom,
depending on the @code{:items} list) to put the selection box around a button.
Since this slot contains a formula, the programmer may not supply an initial
value at create-instance time. Instead, as with the @code{:value} slot, the user
must first gv the @code{:keyboard-selection} slot and then s-value it to
the desired initial value.

@b{NOTE:} When keyboard selection is activated, the space-bar is used to
select buttons, while the return key is used to select items in the
@code{motif-menu}.
@end enumerate

@subsection Motif Text Buttons
@node Motif Text Buttons
@anchor{motif-text-buttons}
@cindex{Motif-text-buttons}

@example
(create-instance 'gg:Motif-Text-Button gg:motif-gadget-prototype
   (:maybe-constant '(:left :top :text-offset :active-p :string :toggle-p :font
                      :final-feedback-p :foreground-color :visible))
   (:left 0)
   (:top 0)
   (:text-offset 5)
   (:active-p T)
   (:string "Motif Text Button")
   (:font opal:default-font)
   (:final-feedback-p NIL)
   (:toggle-p T)
   (:keyboard-selection-p NIL)
   (:foreground-color opal:motif-gray)
   (:value (o-formula (if (gvl :selected) (gvl :string))))
   (:selected (o-formula (gvl :value)))  @emph{;Set by interactor}
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example
@sp 1

@example
(create-instance 'gg:Motif-Text-Button-Panel motif-gadget-prototype
   (:maybe-constant '(:left :top :text-offset :final-feedback-p :toggle-p :items :font
                      :foreground-color :direction :v-spacing :h-spacing :v-align
                      :h-align :indent :fixed-width-p :fixed-width-size :fixed-height-p
                      :fixed-height-size :rank-margin :pixel-margin :visible))
   (:left 0)
   (:top 0)
   (:text-offset 5)
   (:final-feedback-p NIL)
   (:items '("Text 1" "Text 2" "Text 3" "Text 4"))
   (:inactive-items NIL)
   (:toggle-p NIL)
   (:keyboard-selection-p NIL)
   (:keyboard-selection (o-formula ...))
   (:keyboard-selection-obj (o-formula ...))
   (:font opal:default-font)
   (:foreground-color opal:motif-gray)
   (:value-obj NIL)
   (:value (o-formula ...))
   (:active-p (o-formula ...))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   <All customizable slots of an aggrelist>)
@end example

The loader file for the @code{motif-text-button} and @code{motif-text-button-panel}
is "motif-text-buttons-loader".

The @code{motif-text-button-panel} is a set of rectangular buttons, with the
string or atom associated with each button aligned inside.
The button will stay depressed after the mouse
is released only if @code{:final-feedback-p} is T.

The distance from the beginning of the longest label to the inside edge of the
button frame is specified in @code{:text-offset}.

@subsection Motif Check Buttons
@node Motif Check Buttons
@anchor{motif-check-buttons}
@cindex{Motif-check-buttons}

@example
(create-instance 'gg:Motif-Check-Button gg:motif-gadget-prototype
   (:maybe-constant '(:left :top :button-width :text-offset :text-on-left-p
		      :active-p :toggle-p :string :font :foreground-color :visible))
   (:left 0)
   (:top 0)
   (:button-width 12)
   (:text-offset 5)
   (:text-on-left-p NIL)
   (:active-p T)
   (:string "Motif Check Button")
   (:font opal:default-font)
   (:toggle-p T)
   (:keyboard-selection-p NIL)
   (:foreground-color opal:motif-gray)
   (:value (o-formula (if (gvl :selected) (gvl :string))))
   (:selected (o-formula (gvl :value))) @emph{;Set by interactor}
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example
@sp 1

@example
(create-instance 'gg:Motif-Check-Button-Panel motif-gadget-prototype
   (:maybe-constant '(:left :top :button-width :text-offset :text-on-left-p :items
                      :font :foreground-color :direction :v-spacing :h-spacing 
                      :v-align :h-align :indent :fixed-width-p :fixed-width-size
                      :fixed-height-p :fixed-height-size :rank-margin :pixel-margin
                      :visible))
   (:left 0)
   (:top 0)
   (:button-width 12)
   (:text-offset 5)
   (:text-on-left-p NIL)
   (:items '("Check 1" "Check 2" "Check 3"))
   (:inactive-items NIL)
   (:keyboard-selection-p NIL)
   (:keyboard-selection (o-formula ...))
   (:keyboard-selection-obj (o-formula ...))
   (:font opal:default-font)
   (:foreground-color opal:motif-gray)
   (:value-obj NIL)
   (:value (o-formula ...))
   (:active-p (o-formula ..))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   <All customizable slots of an aggrelist>)
@end example

The loader file for the @code{motif-check-button} and the
@code{motif-check-button-panel} is "motif-check-buttons-loader".

The @code{motif-check-button-panel} is analogous to the @code{x-button-panel} from
the standard Garnet Gadget Set. Any number of buttons may be selected at one
time, and clicking on a selected button de-selects it.

Since the @code{motif-check-button-panel} allows selection of several items at
once, the @code{:value} slot is a list of strings (or atoms), rather than a
single string. Similarly, @code{:value-obj} contains a list of button objects.

The slot @code{:text-on-left-p} specifies whether the text will appear on the
right or left of the buttons. A NIL value indicates that the text should
appear on the right. When text appears on the right, the designer will
probably want to set @code{:h-align} to @code{:left} in order to left-justify the
text against the buttons.

The distance from the labels to the buttons is specified in @code{:text-offset}.

The slot @code{:button-width} specifies the height and width of each button
square.

@subsection Motif Radio Buttons
@node Motif Radio Buttons
@anchor{motif-radio-buttons}
@cindex{Motif-radio-buttons}

@example
(create-instance 'gg:Motif-Radio-Button gg:motif-gadget-prototype
   (:maybe-constant '(:left :top :button-width :text-offset :text-on-left-p
		      :toggle-p :active-p :string :font :foreground-color :visible))
   (:left 0)
   (:top 0)
   (:button-width 12)
   (:text-offset 5)
   (:text-on-left-p NIL)
   (:active-p T)
   (:string "Motif Radio Button")
   (:font opal:default-font)
   (:toggle-p T)
   (:keyboard-selection-p NIL)
   (:foreground-color opal:motif-gray)
   (:value (o-formula (if (gvl :selected) (gvl :string))))
   (:selected (o-formula (gvl :value)))  @emph{; Set by interactor}
   (:selection-function NIL)             @emph{; (lambda (gadget value))}
   )
@end example
@sp 1

@example
(create-instance 'gg:Motif-Radio-Button-Panel motif-gadget-prototype
   (:maybe-constant '(:left :top :button-width :text-offset :text-on-left-p :toggle-p
                      :items :font :foreground-color :direction :v-spacing :h-spacing
                      :v-align :h-align :indent :fixed-width-p :fixed-width-size
		      :fixed-height-p :fixed-height-size :rank-margin :pixel-margin
                      :visible))
   (:left 0)
   (:top 0)
   (:button-width 12)
   (:text-offset 5)
   (:text-on-left-p NIL)
   (:items '("Radio 1" "Radio 2" "Radio 3"))
   (:inactive-items NIL)
   (:toggle-p NIL)
   (:keyboard-selection-p NIL)
   (:keyboard-selection (o-formula ...))
   (:keyboard-selection-obj (o-formula ...))
   (:font opal:default-font)
   (:foreground-color opal:motif-gray)
   (:value-obj NIL)
   (:value (o-formula ...))
   (:active-p (o-formula ...))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   <All customizable slots of an aggrelist>)
@end example

The loader file for the @code{motif-radio-button} and
@code{motif-radio-button-panel} is "motif-radio-buttons-loader".

The @code{motif-radio-button-panel} is a set of diamond buttons with items
appearing to either the left or the right of the buttons (implementation
of @code{:button-width}, @code{:text-on-left-p} and @code{:text-offset} is identical
to the motif check buttons). Only one button may be selected at a time.



@section[Motif Option Button]
@anchor{motif-option-button}
@cindex{motif-option-button}

@example
(create-instance 'gg:Motif-Option-Button opal:aggregadget
  (:maybe-constant '(:left :top :text-offset :label :button-offset :items :initial-item
                     :button-font :label-font :button-fixed-width-p :v-spacing
                     :keep-menu-in-screen-p :menu-h-align :foreground-color))
  (:left 40) (:top 40)
  (:text-offset 6)
  (:label "Option button:")
  (:button-offset 2)
  (:items '("Item 1" "Item 2" "Item 3" "Item 4"))
  (:initial-item (o-formula (first (gvl :items))))
  (:button-font opal:default-font)
  (:label-font (opal:get-standard-font NIL :bold NIL))
  (:foreground-color opal:motif-gray)
  (:value (o-formula (gvl :option-text-button :string)))
  (:button-fixed-width-p T)
  (:v-spacing 8)
  (:keep-menu-in-screen-p T)
  (:menu-h-align :left)
  (:selection-function NIL)   @emph{; (lambda (gadget value))}
  ...)
@end example

@float Figure, fig:ex2
@center @image{motif-option-button-normal, 5.5in}

@center @image{motif-option-button-pressed, 5.5in}

@caption{A Motif option button in its normal state (left), and showing the
available options after the button is pressed (right).}
@anchor{motif-option-button-tag}
@end float


This is a Motif version of the @code{option-button} gadget.
When the left mouse button is clicked
on the option button, a menu will pop up, from which items can be
selected by moving the mouse over the desired item and releasing the
button. The selected item will appear as the new label of the button.
Figure @ref{motif-option-button-tag} shows a Motif option button in its normal
state and after the button has been pressed.

This button works exactly like the standard @code{option-button} described
in section @ref{option-button}.
The customizations are also alike, except that the @code{motif-option-button}
does not have a @code{:button-shadow-offset} slot and adds a
@code{:background-color} slot. The loader file for the motif option button
is named "motif-option-button-loader".



@section Motif Menu
@node Motif Menu
@anchor{motif-menu}
@cindex{Motif-menu}

@example
(create-instance 'gg:Motif-Menu gg:motif-gadget-prototype
   (:maybe-constant '(:left :top :min-frame-width :text-offset :v-spacing :h-align
                      :items :accelerators :bar-above-these-items :item-font
                      :accel-font :item-to-string-function :final-feedback-p
                      :foreground-color :visible))
   (:left 0)
   (:top 0)
   (:min-frame-width 0)
   (:text-offset 6)
   (:v-spacing 8)
   (:h-align :left)
   (:items '("Menu 1" "Menu 2" "Menu 3" "Menu 4" "Menu 5"))
   (:inactive-items NIL)
   (:accelerators NIL)
   (:bar-above-these-items NIL)
   (:item-to-string-function
    #'(lambda (item)
	(if item
	    (if (stringp item)
		item
		(string-capitalize (string-trim ":" item)))
	    "")))
   (:final-feedback-p T)
   (:keyboard-selection-p NIL)
   (:keyboard-selection (o-formula ...))
   (:keyboard-selection-obj (o-formula ...))
   (:item-font opal:default-font)
   (:accel-font opal:default-font)
   (:foreground-color opal:motif-gray)
   (:value-obj NIL)
   (:value (o-formula ...))
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@center @image{motif-menu-pix, 5.5in}

The loader file for the @code{motif-menu} is "motif-menu-loader".


@subsection Programming Interface
@node Programming Interface

The @code{motif-menu} is analogous to the @code{menu} from the standard Gadget
Set, with the addition of an @code{:accelerators} slot which facilitates the
selection of a menu item by the user. Only one item may be selected at a
time.

The @code{:accelerators} slot is a list of triples which correspond to the items
in the @code{:items} list. Consider the following slot definitions in
an instance of the @code{motif-menu}:
@example
(:items '("Remove-window" "Move-window" ...))
(:accelerators '((#\R "Alt+F2" :META-F2) (#\M "Alt+F3" :META-F3) ...))
@end example
Since the #\M character appears in the second accelerator pair, the "M" in the
"Move-window" item will be underlined in the menu. The string "Alt+F3" will
appear to the right of the "Move-window" item in the menu. Interactors
are defined in the @code{motif-menu} that allow the user to press the "M" key
whenever keyboard selection is activated to select "Move-window". And, after
properly initializing an instance of the @code{motif-menu-accelerator-inter}
(described below), simultaneously pressing the "Alt" and "F3" keys will also
select "Move window".

Since this menu supports only single selection, the @code{:value} slot contains
the currently selected item (from the @code{:items} list) and the @code{:value-obj}
slot contains the currently selected object in the menu's aggrelist.

The @code{:items} and @code{:item-to-string-function} slots are implemented
as in the @code{:scrolling-menu} from the standard Gadget Set (see Section
@ref{scrolling-menu}). Each item (the actual item, not its string conversion)
specified in the @code{:inactive-items} list will appear "grayed-out" and will
not be selectable.

A separator bar will appear above each item listed in the slot
@code{:bar-above-these-items}.

The minimum width of the menu frame is determined by @code{:min-frame-width}.
The menu will appear wider than this value only if the longest item string
(and its corresponding accelerator, if any) will not fit in a menu of this
width.

The @code{:v-spacing} slot determines the distance between each item in the menu,
and @code{:text-offset} determines the distance from the menu frame to the
items (and the distance between the longest item and its corresponding
accelerator, if any).

The justification of the items in the menu is determined by the slot
@code{:h-align} and may be either @code{:left}, @code{:center}, or @code{:right}.

A feedback box will appear around the currently selected item if
@code{:final-feedback-p} is T.

When the slot @code{:keyboard-selection-p} is T, the keyboard interface to the
@code{motif-menu} is activated. The arrow keys will move the selection box among
the items in the menu, and the return key will select the boxed item.
The component of the menu's aggrelist currently surrounded by the selection
box is named in
@code{:keyboard-selection-obj}, and its string is in @code{:keyboard-selection}.
Thus, the slot @code{:keyboard-selection} may be set with a string (or an atom,
depending on the @code{:items} list) to put the selection box around an item.
Since this slot contains a formula, the programmer may not supply an initial
value at create-instance time. Instead, as with the @code{:value} slot, the user
must first gv the @code{:keyboard-selection} slot and then s-value it to
the desired initial value. @b{NOTE:} The return key is used to select items
in the @code{motif-menu}, while the space-bar is used to select Motif buttons.

The fonts in which to display the items and the accelerator strings are in
@code{:item-font} and @code{:accel-font}, respectively.


@subsection The Motif-Menu Accelerator Interactor
@node The Motif-Menu Accelerator Interactor

@example
(create-instance 'gg:Motif-Menu-Accelerator-Inter inter:button-interactor
   (:window NIL)
   (:menus NIL)
   (:continuous NIL)
   (:start-where T)
   (:start-event (o-formula (multiple-value-call #'append
			      (values-list (gvl :accel-chars)))))
   (:accel-chars (o-formula (mapcar #'(lambda (menu)
					(gv menu :global-accel-chars))
				    (gvl :menus))))
   (:waiting-priority gg:motif-tab-priority-level)
   (:running-priority gg:motif-tab-priority-level)
   (:stop-action #'(lambda (interactor obj-over) ...))
   (:final-function NIL))
@end example

@cindex{motif-menu-accelerator-inter}
The @code{motif-menu-accelerator-inter} interactor is used with a set of
@code{motif-menu}
instances to implement the global character selection feature (:META-F2, etc.
above). When an instance is supplied with a list of menus in the @code{:menus}
slot and the window of the menus in the @code{:window} slot, then when the
user strikes any of the accelerator keys defined in the menus, the
corresponding menu item will be selected and its functions will be executed.
Only one item may be assigned to each global accelerator character.
An example of the @code{motif-menu-accelerator-inter} may be found in demo-motif
and in the @code{motif-menu} demo.


@subsection Adding Items to the Motif-Menu
@node Adding Items to the Motif-Menu

The @code{add-item} method for the @code{motif-menu} is similar to the standard
method, except that the programmer may supply an accelerator to be added
to the menu which corresponds to the item being added.

@example
opal:add-item @i{motif-menu item} [:accelerator @i{accel}] [[:where] @i{position [locator]} [:key @i{function-name}]]
@end example

The value for @emph{accel} should be an accelerator triplet that can be
inserted into the @code{:accelerators} list of the @emph{motif-menu}, such as
@code{'(#\R "Alt+F2" :META-F2)}.
Note that the accelerator parameter must come @b{before} the "where" keys.

The usual @code{remove-item} method is used for the @code{motif-menu}, with the
additional feature that the accelerator corresponding to the old item is
automatically removed from the @code{:accelerators} list (if there is one).


@section[Motif Scrolling Menu]
@anchor{motif-scrolling-menu}
@cindex{motif-scrolling-menu}

@center @image{motif-scrolling-menu-pix, 5.5in}

@example
(create-instance 'gg:Motif-Scrolling-Menu motif-gadget-prototype
   (:maybe-constant '(:left :top :scroll-on-left-p
		      :scr-incr :page-incr :min-frame-width :v-spacing :h-align
		      :multiple-p :items :item-to-string-function
		      :item-font :num-visible :int-menu-feedback-p
		      :final-feedback-p :text-offset :title :title-font
		      :visible))
   (:left 0) (:top 0)
   (:active-p T)

   ;; Scroll bar slots
   (:scroll-on-left-p T)
   (:scr-incr 1)
   (:page-incr (o-formula (gvl :num-visible)))
   (:scroll-selection-function NIL)

   ;; Menu slots
   (:toggle-p T)
   (:min-frame-width 0)
   (:v-spacing 6)
   (:h-align :left)
   (:multiple-p T)
   (:items '("Item 1" "Item 2" "Item 3" "Item 4" "Item 5" "Item 6" "Item 7"
	     "Item 8" "Item 9" "Item 10" "Item 11" "Item 12" "Item 13"
	     "Item 14" "Item 15" "Item 16" "Item 17" "Item 18" "Item 19"
	     "Item 20"))
   (:item-to-string-function
    #'(lambda (item)
	(if item
	    (if (stringp item)
		item
		(string-capitalize (string-trim ":" item)))
	    "")))
   (:item-font opal:default-font)
   (:num-visible 5)
   (:int-menu-feedback-p T)
   (:final-feedback-p T)
   (:text-offset 6)
   (:title NIL)
   (:title-font (opal:get-standard-font :serif :roman :large))
   (:menu-selection-function NIL)
   (:selected-ranks NIL)
   (:foreground-color opal:motif-gray)
   (:value (o-formula ...)))
@end example


The loader file for the @code{motif-scrolling-menu} is named
"motif-scrolling-menu-loader".

The @code{motif-scrolling-menu} is very much like
the standard @code{scrolling-menu}, but there are a few differences. Since the
scrolling window has a motif-v-scroll-bar as a part of it, the slots
@code{:min-scroll-bar-width}, @code{page-trill-p}, @code{:indicator-text-p}, and
@code{:int-scroll-feedback-p} are not applicable.

Also, the @code{motif-scrolling-menu} has a slot @code{:foreground-color}, which is
absent in the standard @code{scrolling-menu}.


@section Motif-Menubar
@node Motif-Menubar
@anchor{motif-menubar}
@cindex{motif-menubar}

@float Figure, fig:ex2
@center @image{motif-menubar-pix, 5.5in}
@caption{An instance of the @t[motif-menubar] gadget}
@anchor{motif-menubar-pix}
@end float

@example
(create-instance 'gg:Motif-Menubar gg::motif-gadget-prototype
  (:left 0)(:top 0)
  (:items NIL)
  (:title-font opal:default-font)
  (:item-font opal:default-font)
  (:min-menubar-width 0)          
  (:accelerators NIL)
  (:accelerator-windows (o-formula (gvl :window)))
  (:bar-above-these-items NIL))
@end example

To load the @code{motif-menubar}, execute
@code{(garnet-load "gadgets:motif-menubar-loader")}.

The @code{motif-menubar} is used very much like the standard @code{menubar},
described in section @ref{menubar}.
The @code{motif-menubar} has several additional features, including:
slots that allow the menubar to extend across the top of the entire window,
keyboard accelerators, and decorative "bars" in the submenus.

A simple demo which uses the @code{motif-menubar} is loaded along with the
@code{motif-menubar}. To run it, execute @code{(gg:motif-menubar-go)}.
Larger demos also use the @code{motif-menubar}, including @code{GarnetDraw} and
@code{Demo-Multifont}.

The @code{:min-menubar-width} slot specifies how wide the @code{motif-menubar}
should be. If it contains a value greater than the current
width of the @code{motif-menubar}, the bar will extend itself. However, the
items will remain fixed (i.e. they won't spread out equidistantly over
the bar). This feature is useful when you want the menubar to extend across
the top of the entire window, as in Figure @ref{motif-menubar-pix}.


@subsection Selection Functions
@node Selection Functions
@anchor{mmbar-sel-fns}

Like in the standard @code{menubar}, there is no @code{:value} slot for this
gadget. The designer must use the @code{:selection-function} or the
item functions to act on the user's selections.

There are three levels of functions in the @code{motif-menubar} gadget that
may be called when the user makes a selection. Functions can be
attached to individual submenu items, whole submenus, or the top level
menubar.

All the selection functions take three parameters:

@code{(lambda (gadget menu-item submenu-item))}

The following @code{:items} list is taken from the @code{gg:Motif-Menubar-Go} demo,
defined at the end of motif-menubar.lisp.

@example
(:items
 `((:family ,#'family-fn
	    ((:fixed ,#'fixed-fn)(:serif ,#'serif-fn)(:sans-serif ,#'sans-serif-fn)))
   (:face ,#'face-fn
	  ((:roman)(:bold)(:italic)(:bold-italic)))
   (:size ,#'size-fn
	  ((:small)(:medium)(:large)(:very-large)))))
@end example

This @code{:items} list attaches the functions @code{family-fn},
@code{face-fn}, and @code{size-fn} to each of the @emph{submenus}
in the menubar. Whenever the user selects an item from one of those submenus,
the corresponding submenu-function will be executed.

Additionally, the functions @code{fixed-fn}, @code{serif-fn},
and @code{sans-serif-fn} are attached to each @emph{item} in the first
submenu. Whenever the user chooses "Fixed", "Serif", or "Sans-Serif" from
the "Family" menu, the function associated with that item will be executed.

The order of function execution is as follows:  First, the submenu-item
function is called, then the submenu function, and then the top-level
@code{:selection-function}. Notice that this is different from the order in
which the functions for the regular menubar are called.


@subsection Accelerators
@node Accelerators
@anchor{mmbar-accelerators}

Since the @code{motif-menubar} uses actual instances of the @code{motif-menu}
gadget for its submenus, the "accelerators" feature of the @code{motif-menu}
gadget can be used in the menubar. The syntax for specifying accelerators
is a bit more complicated in the menubar, because multiple submenus are used.

An accelerator is a relationship between a keyboard event and an item in
the menubar. When a key is typed that corresponds to a menubar item, the
function that is associated with the item is executed as if the user had
pulled down the submenu and selected the item with the mouse. Each accelerator
is specified by its lisp character (e.g., @code{:F3}), and a string to be shown
to the user describing the accelerator key (e.g., "F3"). These
string/character
pairs are supplied to the menubar in a list, one pair for each item in the
menubar. For example,

@example
(:accelerators '((("!f" :|META-f|) ("!b" :|META-b|))
		 NIL
		 (NIL NIL ("!x" :|META-x|))))
@end example

In this accelerators list, the first item in the first submenu has
accelerator string "!f", and is selected by the keyboard event,
:META-f. The second item in the first submenu has the
accelerator string "!b", and keyboard event :META-b. The second
submenu has no accelerators. The first two items in the third submenu
have no accelerators. The third item in the third submenu has string
"!x" and event META-x.	

In general, the format for the @code{:accelerators} slot is:

@example
(:accelerators '(((s1,1 k1,1) (s1,2 k1,2) ...)
		 ((s2,1 k2,1) (s2,2 k2,2) ...)
		 ...))
@end example

where sM,N is the accelerator string for the N-th item in the M-th
submenu, and kM,N is the keyboard event for the same.

The @code{:accelerator-windows} slot by default contains the @code{motif-menubar}'s
window, but may contain a list of windows. When an accelerator event occurs
in one of these windows, it will be perceived by the menubar and the item
functions will be executed. If the mouse is in a different window, and the
accelerator event occurs, the menubar will not notice the event. For this
reason, you should put a list of all your application's windows in this
slot, if you always want the accelerator to activate the menubar.


@subsection Decorative Bars
@node Decorative Bars

The "bars" feature of the @code{motif-menu} can also be used in the
@code{motif-menubar} gadget. The @code{:bar-above-these-items} slot specifies
over which items a horizontal line should appear. For example:

@example
(:bar-above-these-items '(("Small")
			  NIL
			  ("Faster" "Warp Speed")))
@end example

will cause a bar to appear above the item "Small" in the first
submenu, and above the items @code{"Faster"} and @code{"Warp Speed"} in the third
submenu, with no bars in the second submenu. In the @code{motif-menubar} demo,
pictured in Figure @ref{motif-menubar-pix}, there is a bar above third item
in the last submenu.


@subsection Programming the Motif-Menubar the Traditional Garnet Way
@node Programming the Motif-Menubar the Traditional Garnet Way

There are two approaches to programming a @code{motif-menubar}. The first,
discussed in this section, is the Garnet way, where all the @code{:items}
are provided while creating the menubar. The second approach, discussed
in section @ref{mmbar-components}, requires that all the sub-objects be
created individually and attached to the menubar. 

The format for the @code{:items} slot of the @code{motif-menubar} is the same as in
the regular @code{menubar}. For example,

@example
(:items '(("Speed" NIL (("Slow" Slow-Fn) ("Medium" Med-Fn)
			("Fast" Fast-Fn) ("Whoa" Too-Fast-Fn)))))
@end example

This @code{:items} list creates a menubar with one bar-item, @code{"Speed"},
which has no submenu selection function. In that bar-item's submenu,
are the items @code{"Slow"}, @code{"Medium"}, @code{"Fast"} and @code{"Whoa"},
which will call @code{Slow-Fn}, @code{Med-Fn}, @code{Fast-Fn}
and @code{Too-Fast-Fn} respectively when selected. Note that in contrast to the
example of Section @ref{mmbar-sel-fns}, we did not include #' function
specifiers with the selection function names. This is not necessary, because
the functions are invoked with @code{funcall}, and the symbols will be
dereferenced when necessary (though it would be faster to include the #', and
avoid the dereferencing).

The submenu-items should always be described with lists, even if they
have no functions (e.g., @code{("Slow")} instead of @code{"Slow"}). Also, the
submenu function should either be NIL (as in the above example) or a function.
As in the regular menubar, the item functions are optional and may be
omitted.



@subsection An Example
@node An Example

The following example creates the @code{motif-menubar} pictured in Figure
@ref{motif-menubar-pix}. Note the behavior of the META-f accelerator and the
location of the bar.


@example
(create-instance 'WIN inter:interactor-window
  (:background-color opal:motif-gray)
  (:aggregate (create-instance 'TOP-AGG opal:aggregate)))

(defun Fixed-Fn (submenu bar-item submenu-item)
  (format T "Fixed called with ~s ~s ~s~%" submenu bar-item submenu-item))

(defun Face-Fn (gadget menu-item submenu-item)
  (format T "Face called with ~s ~s ~s~%"
	  gadget menu-item submenu-item))

(create-instance 'MY-MOTIF-MENUBAR gg:motif-menubar
  (:foreground-color opal:motif-gray)
  (:items
   '((:family NIL
	      ((:fixed fixed-fn)(:serif)(:sans-serif)))
     (:face face-fn
	    ((:roman)(:bold)(:italic)(:bold-italic)))
     (:size NIL
	    ((:small)(:medium)(:large)(:very-large)))))
  (:accelerators
   '((("!f" :|META-f|) ("!e" :|META-e|) ("!a" :|META-a|))
     (("!r" :|META-r|) ("!b" :|META-b|) ("!i" :|META-i|) ("!B" :META-B))
     (("!s" :|META-s|) ("!m" :|META-m|) ("!l" :|META-l|) ("!v" :|META-v|))))
  (:bar-above-these-items
   '(NIL
     NIL
     (:large))))

(opal:add-component TOP-AGG MY-MOTIF-MENUBAR)
(opal:update win)
@end example


@subsection Adding Items to the Motif-Menubar
@node Adding Items to the Motif-Menubar

Adding items to the @code{motif-menubar} is very similar to adding items to
the regular @code{menubar}, with the additional ability to add accelerators
to the menubar along with the new items.

The add-item method for the motif-menubar may be used to add submenus:

@cindex{Add-item}
@cindex{Motif-menubar}
@example
opal:Add-Item @i{menubar submenu} [:accelerators @i{accels}] @ref{method}
              @i{                              } [[:where] @i{position} [@i{locator}] [:key @i{index-function}]]
@end example

NOTE: If any accelerators are being added, the @code{:accelerators} keyword and
arguments @emph{must} appear before the @code{:where} arguments.

The following will add a bar item named "Volume", with a few items and
accelerators in it:

@example
(opal:add-item MY-MOTIF-MENUBAR 
	       '("Volume" NIL (("Low") ("Medium") ("High") ("Yowsa")))
	       :accelerators '(NIL NIL
			       ("!h" :|META-h|) ("!y" :|META-y|))
	       :before :size :key #'car)
@end example

To add a submenu item, use the function:

@example
gg:Add-Submenu-Item @i{menubar submenu-title submenu-item} @ref{method}
                    [:accelerator @i{accel}]
                    [[:where] @i{position} [@i{locator}] [:key @i{index-function}]]
@end example

As with the previous function, if any accelerators are being added, they
@emph{must} appear before the @code{:where}. Also, notice that since only one
accelerator is being added for the item, the keyword is @code{:accelerator}, not
@code{:accelerators}.

The following example will add a submenu item named "Quiet" to the
submenu named "Volume", and its accelerator will be META-q:

@example
(gg:add-submenu-item MY-MOTIF-MENUBAR "Volume" '("Quiet")
		     :accelerator '("!q" :|META-q|) :before "Low" :key #'car)
@end example



@subsection Removing Items from the Motif-Menubar
@node Removing Items from the Motif-Menubar

An item is removed from a @code{motif-menubar} in exactly the same way as
from a regular menubar. To remove an entire submenu, use:

@cindex{remove-item}
@cindex{motif-menubar}
@code{opal:Remove-Item @i<menubar submenu> @ref{method}}

For traditional Garnet programming, the @i<submenu> should be a sublist
of the top level @code{:items} list, or it can just be the title of a
submenu.

The following line will remove the "Volume" submenu from the previous
examples.

@code{(opal:remove-item MY-MOTIF-MENUBAR "Volume")}

For removing submenu items, use

@cindex{remove-submenu-item}
@code{gg:Remove-Submenu-Item @i<menubar submenu-title submenu-item> @ref{method}}

The following will remove the @code{:small} item from the submenu, @code{:size}.

@code{(gg:remove-submenu-item MY-MOTIF-MENUBAR :size '(:small))}


@subsection Programming the Motif-Menubar with Components
@node Programming the Motif-Menubar with Components
@anchor{mmbar-components}

The designer may also choose a bottom-up way of programming the
@code{motif-menubar}. The idea is to create the submenus of the menubar
individually using the functions described in this section, and then attach
them to a menubar.

@subsection An Example
@node An Example

This example creates a @code{motif-menubar} and several components, and
attaches them together. 

@example
(create-instance 'WIN inter:interactor-window
  (:background-color opal:motif-blue)
  (:aggregate (create-instance 'TOP-AGG opal:aggregate)))
	
@emph{; Create the menubar and a bar item}
(setf MY-MOTIF-MENUBAR (garnet-gadgets:make-motif-menubar))
(s-value MY-MOTIF-MENUBAR :foreground-color opal:motif-blue)
		
(setf MAC-BAR (garnet-gadgets:make-motif-bar-item :title "Fonts"))
		
@emph{; Create the submenu items}
(setf SUB1 (garnet-gadgets:make-motif-submenu-item :desc '("Gothic")))
(setf SUB2 (garnet-gadgets:make-motif-submenu-item :desc '("Venice")))
(setf SUB3 (garnet-gadgets:make-motif-submenu-item :desc '("Outlaw")))
		
@emph{; Add submenu items to the bar item}
(opal:add-item MAC-BAR SUB1)
(opal:add-item MAC-BAR SUB2)
(opal:add-item MAC-BAR SUB3 :after "Venice" :key #'car)
		
@emph{; Add the bar item to the menubar and update the window}
(opal:add-item MY-MOTIF-MENUBAR MAC-BAR
	       :accelerators '(("!g" :|META-g|) ("!v" :|META-v|) ("!o" :|META-o|)))

@emph{; Add the menubar to the top-level aggregate}
(opal:add-component TOP-AGG MY-MOTIF-MENUBAR)
		
(opal:update win)
@end example

When programming a @code{motif-menubar} by components, you should add
accelerators only when you add a bar-item to the menubar, or when adding
a submenu item to a bar item that has already been added to a menubar.
That is, you cannot add an accelerator to a submenu that has not been attached
to a menubar yet.

@subsection Creating Components of the Motif-Menubar
@node  Creating Components of the Motif-Menubar

A @code{motif-menubar} is essentially the same as a menubar in that there are
three components - the menubar itself, bar items containing submenus,
and submenu items. Each can be created with the following functions:

@cindex{make-motif-menubar}
@code{gg:Make-Motif-Menubar @ref{function}}

Will return an instance of @code{motif-menubar}.

@cindex{make-motif-bar-item}
@code{gg:Make-Motif-Bar-Item &key @i<desc font title> @ref{function}}

Returns a @code{motif-bar-item}. Like the regular @code{menubar}, the @code{:desc}
parameter is a description of the submenu (e.g., @code{'("Speed" NIL
(("Fast") ("Slow") ("Crawl")))}), and the font and title keys specify
the font and the heading of the submenu.

@cindex{make-motif-submenu-item}
@defun gg:make-motif-submenu-item &key desc enabled

Creates and returns an instance of @code{motif-submenu-item}, which is
actually a @code{motif-menu-item}, since each motif-submenu is just a
@code{motif-menu}. The @code{:desc} parameter describes the item, (e.g.,
@code{'("Italic")} or @code{'("Italic" italic-fn)}). The default for enabled is T.
@end defun

@subsection Adding Components to the Motif-Menubar
@node Adding Components to the Motif-Menubar

Two types of components that can be added to the @code{motif-menubar} are
bar-items and submenu-items. The @code{add-item} method can be used to add
new bar-items to the menubar, and can also be used to add new submenu-items
to existing bar-items. The @code{set-...} functions are used to
install a collection of components all at once.

@cindex{set-menubar}
@code{gg:Set-Menubar @i<motif-menubar new-bar-items> @ref{method}}

This removes the current bar-items from @i<motif-menubar> and adds the
new bar items. This is useful for recycling a menubar instead of creating
a new one.

@cindex{set-submenu}
@code{gg:Set-Submenu @i<motif-bar-item new-submenu-items> @ref{method}}

Sets the @i<motif-bar-item> to have the new submenu-items. For more
information on these two functions, see section @ref{menubar}.

@cindex{Add-item}
@cindex{Motif-menubar}
@example
opal:Add-Item @i<motif-menubar motif-bar-item> [:accelerators @i<accels>] @ref{method}
              @i<                                                 > [[:where] @i<position> [@i<locator>] [:key @i<index-function>]]
@end example

Will add @i<motif-bar-item> to @i<motif-menubar>. As usual, if any
accelerators are being added, the @code{:accelerators} key @emph{must} be
specified before the @code{:where} key. The @code{:accelerators} syntax is
described in Section @ref{mmbar-accelerators}.

@cindex{Add-item}
@cindex{Motif-menubar}
@example
opal:Add-Item @i<motif-bar-item motif-menu-item> @ref{method}
              [:accelerator @i<accels>] 
              [[:where] @i<position> [@i<locator>] [:key @i<index-function>]]
@end example

Adds the submenu-item, @i<motif-menu-item> to @i<motif-bar-item>. If the
@i<motif-bar-item> is not attached to a @code{motif-menubar}, then no
accelerators will be added, regardless of whether any are specified.

The following example shows how bar items are added to a @code{motif-menubar}:

@example
(setf bar1 (gg:make-motif-bar-item
            :desc '("Color" NIL (("Red") ("Blue") ("Polka Dots")))))	
(setf bar2 (gg:make-motif-bar-item
            :desc '("Size" NIL (("Small") ("Medium") ("Large")))))
(opal:add-item MY-MOTIF-MENUBAR bar1
               :accelerators '(("!r" :|META-r|) ("!b" :|META-b|) ("!p" :|META-p|)))
(opal:add-item MY-MOTIF-MENUBAR bar2 :before bar1)	
(opal:update win)
@end example

This sequence shows how submenu-items can be attached to bar-items:

@example
(setf color1 (gg:make-motif-submenu-item :desc '("Maroon")))
(setf color2 (gg:make-motif-submenu-item :desc '("Peachpuff")))
(opal:add-item bar1 color1 :accelerator '("!m" :|META-m|))
(opal:add-item bar1 color2 :after "Blue" :key #'car)
@end example


@subsection Removing Components from the Menubar
@node Removing Components from the Menubar

Bar-items and submenu-items can be removed from the menubar with the
@code{remove-item} method.

In the example from the previous section, to remove @code{color1} from @code{bar1},
we say:

@code{(opal:remove-item bar1 color1)}

And to remove the @code{bar1} itself:

@code{(opal:remove-item MY-MOTIF-MENUBAR bar1)}


@subsection Methods Shared with the Regular Menubar
@node Methods Shared with the Regular Menubar

The following methods have the same effect on the @code{motif-menubar} as
they have on the standard @code{menubar}. Please see section @ref{menubar}
for more information.

@example
gg:Menubar-Components @i<motif-menubar> @ref{method}
gg:Submenu-Components @i<motif-bar-item> @ref{method}
gg:Get-Bar-Component @i<motif-menubar> @i<item> @ref{method}
gg:Get-Submenu-Component @i<motif-bar-item> @i<item> @ref{method}
gg:Find-Submenu-Component @i<motif-menubar> @i<submenu-title> @i<submenu-item> @ref{method}
gg:Menubar-Disable-Component @i<motif-menubar-component> @ref{method}
gg:Menubar-Enable-Component @i<motif-menubar-component> @ref{method}
gg:Menubar-Enabled-P @i<motif-menubar-component> @ref{method}
gg:Menubar-Get-Title @i<motif-menubar-component> @ref{method}
gg:Menubar-Set-Title @i<motif-menubar-component> @ref{method}
gg:Menubar-Installed-P @i<motif-menubar-component> @ref{method}
@end example



@section Motif-Scrolling-Labeled-Box
@node Motif-Scrolling-Labeled-Box
@anchor{motif-scrolling-labeled-box}
@cindex{motif-scrolling-labeled-box}

@example
(create-instance 'gg:Motif-Scrolling-Labeled-Box motif-gadget-prototype
   (:maybe-constant '(:left :top :width :field-offset :label-offset :label-string
                      :field-font :label-font :foreground-color :active-p :visible))
   (:left 0)
   (:top 0)
   (:width 135)
   (:field-offset 4)
   (:label-offset 5)
   (:label-string "Label:")
   (:value "Field")
   (:field-font opal:default-font)    @emph{;;**Must be fixed width**}
   (:label-font (create-instance NIL opal:font (:face :bold)))
   (:foreground-color opal:motif-gray)
   (:keyboard-selection-p NIL)
   (:active-p T)
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

@center @image{motif-scrolling-labeled-box-pix, 5.5in}

The loader file for the @code{motif-scrolling-labeled-box} is
"motif-scrolling-labeled-box-loader".

This gadget is a Motif version of the @code{scrolling-labeled-box}.
The @code{:width} of the box is fixed, and the
@code{:value} string will scroll inside the box if it is too long to be
displayed.

When the @code{:active-p} slot is set to NIL, both the label and the field will
appear "grayed-out" and the field will not be editable.



@section Motif-Error-Gadget
@node Motif-Error-Gadget
@anchor{motif-error-gadget}
@cindex{motif-error-gadget}
@center @image{motif-error-gadget-pix, 5.5in}

@example
(create-instance 'gg:Motif-Error-Gadget opal:aggregadget
   (:string "Error")
   (:parent-window NIL)
   (:font (opal:get-standard-font :sans-serif :bold :medium))
   (:justification :center)
   (:modal-p T)
   (:beep-p T)
   (:window NIL)        @emph{;; Automatically initialized}
   (:foreground-color opal:motif-orange)
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

The loader file for the @code{motif-error-gadget} is "motif-error-gadget-loader".

The @code{motif-error-gadget} is a dialog box that works exactly the same way
as the @code{error-gadget} described in section @ref{error-gadget}. The same
caveats apply, and the functions @code{display-error} and
@code{display-error-and-wait} may be used to display the dialog box.

There is an additional slot provided in the @code{motif-error-gadget} which
determines the color of the dialog box. The @code{:foreground-color} slot may
contain any instance of @code{opal:color}.



@section Motif-Query-Gadget
@node Motif-Query-Gadget
@anchor{motif-query-gadget}
@cindex{motif-query-gadget}
@example
(create-instance 'gg:Motif-Query-Gadget gg:motif-error-gadget
   (:string "Is that OK?")
   (:button-names '("OK" "CANCEL"))
   (:parent-window NIL)
   (:font (opal:get-standard-font :sans-serif :bold :medium))
   (:justification :center)
   (:modal-p T)
   (:beep-p T)
   (:window NIL)        @emph{;; Automatically initialized}
   (:foreground-color opal:motif-orange)
   (:selection-function NIL)   @emph{; (lambda (gadget value))}
   )
@end example

The loader file for the @code{motif-query-gadget} is "motif-error-gadget-loader"
(it is defined in the same file as the @code{motif-error-gadget}).

The @code{motif-query-gadget} works exactly the same way
as the @code{query-gadget} described in section @ref{query-gadget}.
It has more buttons than the @code{motif-error-gadget}, so it can be used as
a general-purpose dialog box.
The functions @code{display-query} and @code{display-query-and-wait}
may be used to display the dialog box.

The additional @code{:foreground-color} slot may contain any instance of
@code{opal:color}, and determines the color of the dialog box.


@section[Motif Save Gadget]
@anchor{motif-save-gadget}
@float Figure, fig:ex2
@center @image{motif-save-gadget, 5.5in}
@caption{An instance of the Motif save gadget. "/usr0/rajan" is the
current directory.}
@anchor{motif-save-gadget-tag}
@end float

@example
(create-instance 'motif-save-gadget opal:aggregadget  
  (:maybe-constant '(:left :top :parent-window :window-title :window-left :window-top
		     :message-string :num-visible :initial-directory :button-panel-items 
		     :button-panel-h-spacing :min-gadget-width :check-filenames-p
                     :modal-p :query-message :query-buttons :foreground-color
                     :dir-input-field-font :dir-input-label-font :file-input-field-font
                     :file-input-label-font :file-menu-font :button-panel-font 
                     :message-font))
  (:window-title "save window")
  (:initial-directory "./")
  (:message-string "fetching directory...")
  (:num-visible 6)
  (:button-panel-items '("save" "cancel"))
  (:button-panel-h-spacing 25)
  (:min-gadget-width 240)
  (:modal-p NIL)
  (:check-filenames-p t)
  (:query-message "save over existing file")
  (:foreground-color opal:motif-light-blue)
  (:selection-function NIL)   @emph{; (lambda (gadget value))}
  (:dir-input-field-font (opal:get-standard-font NIL NIL :small))
  (:dir-input-label-font (opal:get-standard-font NIL :bold NIL))
  (:file-input-field-font (opal:get-standard-font NIL NIL :small))
  (:file-input-label-font (opal:get-standard-font NIL :bold NIL))
  (:message-font (opal:get-standard-font :fixed :italic :small))
  (:file-menu-font (opal:get-standard-font NIL :bold NIL))
  (:button-panel-font opal:default-font)
  ...)
@end example

The @code{motif-save-gadget} works exactly like the @code{save-gadget}, described
in section @ref{save-gadget}. The only
difference is that the @code{motif-save-gadget} has a slot called
@code{:foreground-color} which allows the user to set the color of the
gadget. This slot can be set to any @code{opal:color} object.

The loader file for the @code{motif-save-gadget} is named
"motif-save-gadget-loader". Figure @ref{motif-save-gadget-tag} shows an
instance of the Motif save gadget.





@section[Motif Load Gadget]
@anchor{motif-load-gadget}
@cindex{motif-load-gadget}
@example
(create-instance 'gg:Motif-Load-Gadget opal:aggregadget  
  (:maybe-constant '(:left :top :parent-window :window-title :window-left
		     :window-top :dir-input-field-font :dir-input-label-font
		     :message-font :message-string :num-visible :file-menu-font
		     :initial-directory :file-input-field-font
		     :file-input-label-font :button-panel-items :button-panel-font
		     :button-panel-h-spacing :min-gadget-width :modal-p
		     :check-filenames-p :foreground-color)))
  (:parent-window NIL)
  (:window-title "load window")
  (:message-string "fetching directory...")
  (:num-visible 6)
  (:initial-directory "./")
  (:button-panel-items '("load" "cancel"))
  (:button-panel-h-spacing 25)
  (:min-gadget-width 240)
  (:modal-p NIL)
  (:check-filenames-p t)
  (:foreground-color opal:motif-light-blue)
  (:selection-function NIL)   @emph{; (lambda (gadget value))}
  (:dir-input-field-font (opal:get-standard-font NIL NIL :small))
  (:dir-input-label-font (opal:get-standard-font NIL :bold NIL))
  (:file-input-field-font (opal:get-standard-font NIL NIL :small))
  (:file-input-label-font (opal:get-standard-font NIL :bold NIL))
  (:message-font (opal:get-standard-font :fixed :italic :small))
  (:file-menu-font (opal:get-standard-font NIL :bold NIL))
  (:button-panel-font opal:default-font)
  ...)

@end example

The @code{motif-load-gadget} is loaded along with the @code{motif-save-gadget}
by the file "motif-save-gadget-loader".

The @code{motif-load-gadget} works the same way as the standard @code{load-gadget}.
The only difference is that the motif gadget has an additional
@code{:foreground-color} slot, which can be set to any @code{opal:color} object.



@section Motif Property Sheets
@node Motif Property Sheets
@anchor{motif-prop-sheets}

The following property sheets are similar to the standard property sheets,
except that they use the Motif look and feel. For a complete discussion of
the use of property sheets, see section @ref{propertysheets}.


@subsection Motif-Prop-Sheet-With-OK
@node Motif-Prop-Sheet-With-OK
@cindex{Motif-Prop-Sheet-With-OK}

@example
(create-instance 'gg:Motif-Prop-Sheet-With-OK opal:aggregadget
    (:maybe-constant '(:left :top :items :default-filter :ok-function :apply-function
                       :cancel-function :v-spacing :multi-line-p :select-label-p
		       :label-selected-func :label-select-event :select-value-p
                       :value-selected-func :single-select-p :foreground-color :visible))

   @emph{; Customizable slots}
    (:foreground-color opal:motif-gray) @emph{; the color for the background}
    (:left 0) (:top 0)
    (:items NIL)
    (:default-filter 'default-filter)
    (:OK-Function NIL)
    (:Apply-Function NIL)
    (:Cancel-Function NIL)
    (:v-spacing 1)
    (:pixel-margin NIL)
    (:rank-margin NIL)
    (:multi-line-p NIL)
    (:select-label-p NIL)
    (:label-select-event :any-mousedown)
    (:label-selected-func NIL)
    (:select-value-p NIL)
    (:value-selected-func NIL)
    (:single-select-p NIL)

   @emph{; Read-only slots}
    (:label-selected ...
    (:value-selected ...
    (:value ...
    (:changed-values ...
@end example

The loader for @code{motif-prop-sheet-with-OK} is
"motif-prop-sheet-win-loader".

This is the same as @code{Prop-Sheet-With-OK} (described in section
@ref{propsheetwithok} except that it uses the
Motif look-and-feel, and you can set the foreground color.


@subsection Motif-Prop-Sheet-For-Obj-With-OK
@node Motif-Prop-Sheet-For-Obj-With-OK
@anchor{motif-prop-sheet-for-obj-with-ok}
@cindex{Motif-Prop-Sheet-for-obj-With-OK}

@example
(create-instance 'Motif-Prop-Sheet-For-Obj-With-OK Motif-Prop-Sheet-With-OK
    (:maybe-constant '(:left :top :obj :slots :eval-p :ok-function :apply-function
                       :cancel-function :v-spacing :multi-line-p :select-label-p
		       :label-selected-func :label-select-event :select-value-p
                       :value-selected-func :single-select-p :foreground-color :visible))

   @emph{; Customizable slots}
    (:foreground-color opal:motif-gray)
    (:OK-Function NIL)
    (:Apply-Function NIL)
    (:Cancel-Function NIL)
    (:left 0) (:top 0)
    (:obj NIL)   @emph{; a single obj or a list of objects}
    (:slots NIL) @emph{; list of slots to show. If NIL, get from :parameters}
    (:union? T)  @emph{; if slots is NIL and multiple objects, use union or intersection of :parameters?}

    (:eval-p T)  @emph{; if T, then evaluates what the user types. Use T for}
		 @emph{; graphical objects. If NIL, then all the values will be strings.}
    (:set-immediately-p T) @emph{; if T then sets slots when user hits @code{return}, else doesn't}
			   @emph{; ever set the slot.}
    (:type-gadgets NIL)  @emph{; descriptor of special handling for types}
    (:error-gadget NIL)  @emph{; an error gadget to use to report errors.}

    ;; @emph{plus the rest of the slots also provided by prop-sheet}

    (:v-spacing 1)
    (:pixel-margin NIL)
    (:rank-margin NIL)
    (:multi-line-p NIL) @emph{; T if multi-line strings are allowed}
    (:select-label-p NIL) @emph{; T if want to be able to select the labels}
    (:label-select-event :any-mousedown)
    (:label-selected-func NIL)
    (:select-value-p NIL) @emph{; if want to be able to select the values}
    (:value-selected-func NIL)
    (:single-select-p NIL) @emph{; to select more than one value or label}

   @emph{; Read-only slots}
    (:label-selected NIL) @emph{; set with the selected label objects (or a list)}
    (:value-selected NIL) @emph{; set with the selected value objects (or a list)}
    (:value ...)  @emph{; list of pairs of all the slots and their (filtered) values}
    (:changed-values NIL)) @emph{; only the values that have changed}
@end example

@float Figure, fig:ex2
@center @image{motifpropforobj, 5.5in}
@caption{An example of @code{motif-prop-sheet-for-obj-with-OK}
containing some gadgets. The code to create this is shown in section
@ref{propexample}.}
@anchor{motifpropfix}
@end float

The loader for @code{motif-prop-sheet-for-obj-with-OK} is
"motif-prop-sheet-win-loader".

The implementation and operation of @code{motif-prop-sheet-for-obj-with-ok} is
identical to the @code{prop-sheet-for-obj-with-ok} gadget (described in
section @ref{propsheetforobjwithok} with the exception
that the @code{:foreground-color} slot may be set to any @code{opal:color} object.


@section Motif-Prop-Sheet-For-Obj-With-Done
@node Motif-Prop-Sheet-For-Obj-With-Done
@cindex{motif-prop-sheet-for-obj-with-done}

There is a new gadget that displays a property sheet for an object and
a ``Done'' button. When a slot value is edited, the slot is set
immediately, rather than waiting for an OK or APPLY to be hit. Thus,
the prop-sheet-for-obj slot @code{:set-immediately-p} is always T.
This is especially useful for when the property sheet is displaying
multiple objects, since slots which are not edited won't be set. The
Done button simply removes the property sheet window from the screen.

Sorry, there is no Garnet look-and-feel version of this gadget.

The parameters are pretty much the same as for
@code{prop-sheet-for-obj}, with the addition of the @code{:done-function}
which is called with the property sheet as a parameter.

@example
(create-instance 'gg:Motif-Prop-Sheet-For-Obj-With-Done opal:aggregadget
    (:maybe-constant '(:left :top :obj :slots :eval-p :done-function :v-spacing
		       :multi-line-p :select-label-p :label-selected-func
                       :label-select-event :select-value-p :value-selected-func
                       :single-select-p	:foreground-color :visible :type-gadgets
                       :union? :error-gadget))
    (:left 5) (:top 5)
    (:obj NIL)            @emph{; can be one object or a list of objects}
    (:slots NIL)          @emph{; list of slots to show. If NIL uses :parameters}
    (:done-function NIL)  @emph{; called when hit done as (lambda (prop))}
    (:eval-p T)           @emph{; evaluate the values of the slots?  Usually T.}
    (:error-gadget NIL)   @emph{; used to report errors on evaluation}
    (:type-gadgets NIL)   @emph{; modifies the default display of slots}
    (:union? T)  @emph{; if slots is NIL and multiple objects, use union or intersection of :parameters?}
    (:v-spacing 1)
    (:select-p NIL)       @emph{; T if want to be able to select the entries}

    (:foreground-color opal:Motif-Gray) @emph{; background color of the window}

    (:select-label-p NIL) @emph{; T if want to be able to select the entries}
    (:label-selected-func NIL)
    (:label-select-event :any-mousedown)
    (:select-value-p NIL)
    (:value-selected-func NIL)
    (:single-select-p NIL)

   @emph{;; Read-Only Slots}
    (:label-selected (o-formula (gvl :propsheet :label-selected)))
    (:value-selected (o-formula (gvl :propsheet :value-selected)))
    (:value (o-formula (gvl :propsheet :value)))
    (:changed-values (o-formula (gvl :propsheet :changed-values)))
    (:width (o-formula (MAX (gvl :done-panel :width)
			    (gvl :propsheet :width))))
    (:height (o-formula (+ 2 (gvl :done-panel :height)
			   (gvl :propsheet :height))))
    
@end example

The loader for @code{motif-prop-sheet-for-obj-with-done} is
"motif-prop-sheet-win-loader".




@section Motif Scrolling Window
@node Motif Scrolling Window
@anchor{motif-scrolling-window}
@cindex{motif-scrolling-window}
@cindex{motif-scrolling-window-with-bars}

@example
(create-instance 'gg:Motif-Scrolling-Window-With-Bars opal:aggregadget
   (:maybe-constant '(:left :top :width :height :border-width :title :total-width 
                      :total-height :foreground-color :h-scroll-bar-p :v-scroll-bar-p
		      :h-scroll-on-top-p :v-scroll-on-left-p :h-scr-incr :h-page-incr
                      :v-scr-incr :v-page-incr :icon-title :parent-window :visible))

   ;; @emph{Window slots}
   (:left 0)  ; @emph{left, top, width and height of outermost window}
   (:top 0)
   (:position-by-hand NIL) ; @emph{if T, then left,top ignored and user asked for window position}
   (:width 150) ;@i{width and height of inside of outer window}
   (:height 150)
   (:border-width 2) ; @emph{of outer window}
   (:parent-window NIL) ; @emph{window this scrolling-window is inside of, or NIL if top level}
   (:double-buffered-p NIL)
   (:omit-title-bar-p NIL)
   (:title "Motif-Scrolling-Window")
   (:icon-title (o-formula (gvl :title))) ;@emph{Default is the same as the title}
   (:total-width 200)   ; @emph{total size of the scrollable area inside}
   (:total-height 200)   
   (:X-Offset 0)  ; @emph{x offset in of the scrollable area. CANNOT BE A FORMULA}
   (:Y-Offset 0)  ; @emph{CANNOT BE A FORMULA}
   (:visible T)  ; @emph{whether the window and bars are visible (mapped)}
   (:foreground-color opal:motif-gray)

   (:h-scroll-bar-p T)  ; @emph{Is there a horizontal scroll bar?}
   (:v-scroll-bar-p T)  ; @emph{Is there a vertical scroll bar?}

   ;; @emph{Scroll Bar slots}
   (:h-scroll-on-top-p NIL)  ; @emph{whether horiz scroll bar is on top or bottom}
   (:v-scroll-on-left-p T)   ; @emph{whether vert scroll bar is on left or right}
   (:h-scr-incr 10)  ; @emph{in pixels}
   (:h-page-incr (o-formula (- (gvl :width) 10))) ; @emph{default jumps one page minus 10 pixels}
   (:v-scr-incr 10)  ; @emph{in pixels}
   (:v-page-incr (o-formula (- (gvl :height) 10))) ; @emph{default jumps one page minus 10 pixels}

   ;; @emph{Read-Only slots}
   (:Inner-Window NIL)  ; @emph{these are created by the update method}
   (:inner-aggregate NIL) ; @emph{add your objects to this aggregate (but have to update first)}
   (:outer-window NIL) ; @emph{call Opal:Update on this window (or on gadget itself)}
   (:clip-window NIL)
   ...)
@end example

@center @image{motif-scrolling-window-gadget, 5.5in}

The loader file for the @code{motif-scrolling-window-with-bars} gadget is
"motif-scrolling-window-loader".
@cindex{scrolling-window-loader}

The use of @code{motif-scrolling-window-with-bars} is identical to the
@code{scrolling-window-with-bars} gadget described in section
@ref{scrolling-windows}, with the exception that the parameters to the scroll
bars are slightly different and the @code{:foreground-color} can be set.

@b{Caveats:}
@itemize
If the motif-scrolling-window has a @code{:parent-window}, update the parent
window before instantiating the motif-scrolling-window.

Update the scrolling-window gadget before referring to its inner/outer
windows and aggregates.

The instance of the motif-scrolling-window should @b{not} be added to
an aggregate.
@end itemize

The @code{motif-scrolling-window-with-bars} gadget is not a window itself; it is
an aggregadget that points to its own windows. These windows are accessed
through the @code{:outer-window}, @code{:inner-window}, and
@code{:clip-window} slots of the gadget, as in
@code{(g-value MY-SCROLL-WIN :outer-window)}. So you cannot call 
@code{opal:make-ps-file} with the scrolling-window gadget as an argument. You
have to send one of the windows that it points to:

@example
> (opal:make-ps-file (g-value SCROLL-WIN :outer-window)
                     "fig.PS" :LANDSCAPE-P T :BORDERS-P :MOTIF)
T
>
@end example


@section Using the Gadgets: Examples
@node Using the Gadgets: Examples

@anchor{Examples}

@section Using the :value Slot
@node Using the :value Slot
@anchor{use-value}
In order to use the value returned by a gadget,
we have to access the top level @code{:value} slot.
As an example, suppose we want to make an aggregadget out of a vertical slider
and a circle, and that we want the diameter of the circle to be dependent on
the current value of the slider. We may create such a unit by putting
a formula in the @code{:diameter} slot of the circle that depends on the value
returned from the slider.
Such an aggregadget is implemented below.
The formula in the @code{:diameter} slot of the circle uses the KR function
@code{gvl} to access the @code{:value} slot of the vertical slider.

@example
(create-instance 'BALLOON opal:aggregadget
   (:parts
    `((:slider ,gg:v-slider
               (:left 10)
               (:top 20))
      (:circle ,opal:circle
               (:diameter ,(o-formula (gvl :parent :slider :value)))
               (:left 100) (:top 50)
               (:width ,(o-formula (gvl :diameter)))
               (:height ,(o-formula (gvl :diameter)))))))
@end example

@section Using the :selection-function Slot
@node Using the :selection-function Slot
@anchor{use-selection}
In order to execute a function whenever any new value or item is selected
(i.e., when the @code{:value} slot changes), that function must be specified in
the slot @code{:selection-function}.
Suppose we want
a set of buttons which give us a choice of several ancient cities. We would
also like to define a function which 
displays a message to the screen when a new city is selected. This
panel can be created with the definitions below.

@example
(create-instance 'MY-BUTTONS gg:text-button-panel
    (:selection-function #'Report-City-Selected)
    (:items '("Athens" "Babylon" "Rome" "Carthage")))

(defun Report-City-Selected (gadgets-object value)
  (format t "Selected city:  ~S~%~%" value)
  (format t "Pressed button object ~S~%"
            (gv gadgets-object :value-obj)))
@end example



@section Using Functions in the :items Slot
@node Using Functions in the :items Slot
@anchor{use-item-fn}
In order to execute a specific function when a specific menu item (or button)
is selected, the desired function must be paired with its associated string
or atom in the @code{:items} list. A menu which executes functions assigned to
item strings appears below. Only one function
(@code{My-Cut}) has been defined, but the definition of the others is analogous.

@example
(create-instance 'MY-MENU gg:menu
   (:left 20)
   (:top 20)
   (:title "Menu")
   (:items '(("Cut" my-cut) ("Copy" my-copy) ("Paste" my-paste))))

(defun my-cut (gadgets-object item-string)
  (format t "Function CUT called~%~%"))
@end example

@section Selecting Buttons
@node Selecting Buttons
@anchor{sel-buttons}
@cindex{initial value}
In order to directly select a button in a button panel (rather than allowing
the user to select the button with the mouse), either the @code{:value} or
@code{:value-obj} slots may be set. However, neither of these slots may be
given values at the time that the button panel is created (i.e., @emph{do not
supply values in the} @code{create-instance} @emph{call for these slots}),
since this would permanently override the formulas in the slots.

The @code{:value} slot may be set with any of the items (or the first element in
any of the item pairs) in the @code{:items} list
of the button panel. The example below shows how buttons on a
text-button-panel and an x-button-panel could be manually selected. In both
cases, the selected items (i.e., those appearing in the @code{:value} slot) will
appear selected when the button panels are displayed in a window.

@example
(create-instance 'MY-TEXT-BUTTONS gg:text-button-panel
   (:items '(:left :center :right)))
(gv MY-TEXT-BUTTONS :value)   @emph{;; initialize the formula in the :value slot}
(s-value MY-TEXT-BUTTONS :value :center)

(create-instance 'MY-X-BUTTONS gg:x-button-panel
   (:items '("Bold" "Underline" "Italic")))
(gv MY-X-BUTTONS :value)   @emph{;; initialize the formula in the :value slot}
@emph{;; Value must be a list because x-buttons have multiple selection}
(s-value MY-X-BUTTONS :value '("Bold" "Underline"))
@end example

Buttons may also be selected by setting the @code{:value-obj} slot to be the
actual button object or list of button objects which should be selected.
This method requires the designer to look at the internal slots of the button
gadgets. The example below shows how the same results may be
obtained using this method as were obtained in the above example.

@example
(create-instance 'NEW-TEXT-BUTTONS gg:text-buttons-panel
   (:items `(:left :center :right)))
(s-value NEW-TEXT-BUTTONS
         :value-obj
         @emph{;; The second button corresponds to the item ":center"}
         (second (gv NEW-TEXT-BUTTONS :text-button-list :components)))
@end example

The @code{:value} slot of a single button will either contain the @code{:string}
of the button or NIL. Single buttons will appear selected when the @code{:value}
slot contains any non-NIL value.


@section The :item-to-string-function Slot
@node The :item-to-string-function Slot
@anchor{sm-ex}
@cindex{Item-to-string-function}
The @code{:items} slot of the scrolling menu may be a list of any objects at all,
including the standard items described in section @ref{buttons}. The
mechanism which allows strings to be generated from arbitrary objects is the
user-defined @code{:item-to-string-function}. The default scrolling menu will
handle a list of standard items, but for a list of other objects a suitable
function must be supplied.

As discussed in section @ref{items-slot}, the elements of the @code{:items} list
can be either single atoms or lists. When an element of the @code{:items} list
is a list, then the @code{:item-to-string-function} is applied only to the
first element in the list, rather than the list itself. In other words, the
@code{:item-to-string-function} takes the @code{car} of the item list as its
parameter, rather than the entire item list.

Suppose the list in the @code{:items} slot of the scrolling menu is
@example
(list v-scroll-bar v-slider trill-device)
@end example
which is a list of Garnet Gadget schemas.
A function must be provided which returns a string identifying an item when
given a schema as input. The following slot/value pair, inserted into the
definition of the new schema, will accomplish this task:
@example
(:item-to-string-function #'(lambda (item)
                              (if item
                                  (name-for-schema item)  @emph{;; imported from KR}
                                  "")))
@end example


@chapter Debugging Tools for Garnet Reference Manual
@node Debugging Tools for Garnet Reference Manual

by Roger B. Dannenberg,
Andrew Mickish,
Dario Giuse

@value{DATE}

@section Abstract
@node Abstract

Debugging a constraint-based graphical system can be difficult
because critical interdependencies can be hard to visualize
or even discover. The debugging tools for Garnet 
provide many convenient ways to inspect objects and constraints
in Garnet-based systems.




@section Introduction
@node Introduction
This manual is intended for users of the Garnet system and assumes that
the reader is familiar with Garnet. Other reference manuals cover
the object and constraint system KR @cite{KRTR2}, 
the graphics system Opal @cite{OpalMANUAL},
Interactors @cite{InterMANUAL}
for handling keyboard and mouse input, Aggregadgets @cite{AggregadgetsMANUAL}
for making instances of aggregates of Opal objects.

@section Notation in this Manual
@node Notation in this Manual

In the examples that follow, user type-in follows the asterisk (@code{*}),
which is the prompt character in CMU Common Lisp on the RT. 
Function results are printed following the characters ``@code{-->}''.
This is not what CMU Common Lisp prints, but is added to avoid
confusion, since most debugging functions print text in addition
to returning values:
@example
* (some-function an-arg or-two)
some-function prints out this information,
    which may take several lines
--> function-result-printed-here
@end example

@section Loading and Using Debugging Tools
@node Loading and Using Debugging Tools
@cindex{loading}
Normally, debugging tools will be loaded automatically when you load
the file @code{garnet-loader.lisp}. Presently, the debugging tools are
located in the files @code{debug-fns.lisp} and @code{objsize.lisp}. A
few additional functions are defined in the packages they support.

Most of the debugging tools are in the @code{GARNET-DEBUG} package,
@cindex{garnet-debug (package)}
and you should ordinarily type
@example
(use-package "GARNET-DEBUG")
@end example
to avoid typing the package name when using these tools. Functions
and symbols mentioned in this document that are @emph{not} in the
@code{GARNET-DEBUG} package will be shown with their full package name.

@section Inspecting Objects
@node Inspecting Objects

@subsection Inspector
@node Inspector
@anchor{inspectorsec}
@cindex{Inspector}
The @code{Inspector} is a powerful tool that can be of significan help in
debugging. It pops up a window showing an object, and also
shows the aggregate and is-a hierarchy for objects, and the
dependencies for formulas. Various operations can be performed on
objects and slots. In general, the @code{Inspector} is quite useful for
debugging programs, and provides interfaces to many of the other
debugging functions in Garnet. A view of an object being inspected in
shown in Figure @ref{inspectorfig}.

@float Figure, fig:ex2
@center @image{inspectorfig, 5.5in}
@caption{The Inspector showing a text object.}
@anchor{inspectorfig}
@end float

The @code{Inspector} is loaded automatically when you load the debugging
tools which is enabled by default in garnet-loader, but it can 
also be loaded explicitly using @code{(garnet-load "debug:inspector")} 
The @code{Inspector} is in the @code{garnet-debug} package.

An example of using the Inspector is included in the Tutorial at the beginning
of this Reference Manual.


@subsection Invoking the Inspector
@node Invoking the Inspector
There are a number of ways to inspect objects. The easiest is to put
the mouse over an object and hit the @code{HELP} keyboard key. This
will print a message in the Lisp listener window and pop up a window
like Figure @ref{inspectorfig}. If you want to use the @code{HELP}
keyboard key for something else, you can set the variable
@cindex{HELP key}
@cindex{inspector-key}
@code{garnet-debug:*inspector-key*} to a different key (or NIL for none)
@emph{before} loading the @code{Inspector}.

@sp 1
Alternatively, you can explicitly invoke the @code{Inspector} on an object
using either
@example
garnet-debug:Inspector @i<obj> @ref{function}
gd:Inspector @i<obj>
@end example
(@code{gd} is an abbreviation for @code{garnet-debug}).

@cindex{inspect-next-inter}
To inspect the @emph{next} interactor that runs, you can hit
@code{CONTROL-HELP} on the keyboard (the mouse position is irrelevant),
or call the function
@example
gd:Inspect-Next-Inter @ref{function}
@end example
Hitting @code{CONTROL-HELP} a second time before an interactor runs will
cancel the invocation of the @code{Inspector}. To change the binding of this
function, set the variable
@cindex{inspector-next-inter-key}
@code{gd:*inspector-next-inter-key*} @emph{before} loading the
@code{Inspector}.

By default, @code{SHIFT-HELP} is bound to a little function that simply
prints the object under the mouse to the Lisp Listener, and does not
invoke the @code{Inspector}. Example output from it is:
@example
--> (24,96) = #k<MULTIFONT-LINE-1447> in window #k<INTERACTOR-WINDOW-1371>

--> No object at (79,71) in window #k<INTERACTOR-WINDOW-1371>
@end example
To change the binding of this function, use the variable
@cindex{show-object-key} @code{gd:*show-object-key*}.

@subsection Schema View
@node Schema View
The schema view shown in Figure @ref{inspectorfig} tells all the local
slots of an object. To see the inherited slots also, click on the
@code{Inherited Slots} button. For each slot, the display is:
@itemize
The slot name.

A @emph{(C)} if the slot is constant.

An @emph{(I)} if the slot is inherited.

The formula for the slot, if any.

If there is a formula, then a @emph{(V)} if the slot value is valid,
otherwise a @emph{(IV)} for invalid.

The current value of the slot, which may wrap to multiple lines if the
value is long.

The entire line is red if the slot is a @emph{parameter} to the object
(if it is in the @code{:parameters} list), otherwise the line is black.
@end itemize

If the object's values change while it is being inspected, the view is
@emph{not} updated automatically. To see the current value of slots, hit
the "@code{Re-Fetch}" button.

To change the value of a slot of an object, click in the value part of
the slot (after the =), and edit the value to the desired value and
hit return. The object will immediately be updated and the @code{Inspector}
display will be re-fetched. If you change your mind about editing the value
before hitting return, simply hit @code{control-g}. If you try to set a
slot which is marked constant, the @code{Inspector} will go ahead and set the
slot, but it gives you a warning because often dependencies based on
the slot will no longer be there, so the effect of setting the slot
may not work. 

If a slot's value is an object and you want to inspect that
object, or if you want to inspect a formula, you can double-click the
left button over the object name, and hit the "@code{Show Object}" button.
Also, you can use the "@code{Show in New}" button if you want the object
to be inspected in a new window.

@subsection Object View
@node Object View
@anchor{inspectobjects}
@cindex{Object View (in Inspector)}
Hitting the "@code{Objects}" button brings up the view in Figure
@ref{inspectorobjects}. This view shows the name of the object being
inspected at the top, then the @code{is-a} hierarchy. In Figure
@ref{inspectorobjects}, @code{TEXT-6509} is the immediate prototype of
the inspected object (@code{TEXT-6508}), and @code{TEXT-7180} is the
prototype of @code{TEXT-6509}, and so on. The next set of objects shows
the aggregate hierarchy. Here, @code{TEXT-6508} is in the aggregate
@code{MOTIF-BAR-ITEM-3024-5430}, etc. The last item in this list is
always the window that the object is in (even though that is
technically not the @code{:parent} of the top-level aggregate). The
final list is simply the list of objects that have been viewed in this
window, which forms a simple history of views.

@float Figure, fig:ex2
@center @image{inspectorobjsfig, 5.5in}
@caption{The Inspector showing the objects related to the text object
of Figure @ref{inspectorfig}.}
@anchor{inspectorobjects}
@end float

To return to the schema view of the current object, use the
"@code{Re-Fetch}" button. You can double-click on any object and use
"@code{Show Object}" or "@code{Show in New}" to see its fields, or you can hit
"@code{Objects}" to go to the object view of the selected object.

@subsection Formula Dependencies View
@node Formula Dependencies View
@anchor{dependencysec}
@cindex{Dependency View (in Inspector)}
If you select a formula or a slot name (by double-clicking on it) and
then hit the "@code{Dependencies}" button, you get the view of Figure
@ref{inspectordepfig}. This slows the slots used in calculating the
value in the formula.

@float Figure, fig:ex2
@center @image{inspectordepfig, 5.5in}
@caption{The Inspector showing the dependencies of the @code{:visible}
slot of the object shown in Figure @ref{inspectorfig}.}
@anchor{inspectordepfig}
@end float

The first lines show the object, the slot, the formula name, and the
expression of the formula. Then the dependencies are shown. The
outer-most level of indenting are those slots that are immediately
used by the formula. In this case, the @code{:visible} slot of
@code{#k<MOTIF-BAR-ITEM-3024-5430>}. Note that only non-constant slots
are shown, 
which is why the @code{:parent} slot of @code{TEXT-6508} is not listed (it
is constant). Indented underneath each slot are the slots it depends
on in turn, so @code{:visible} of @code{#k<MOTIF-BAR-ITEM-3024-5430>}
depends on its @code{:parent} and its parent's @code{:visible}. The
@code{"..."} means that there are more levels of dependencies. To see
these, you can double click on the @code{"..."} or on any slot name and
hit the "@code{Dependencies}" button.

@subsection Summary of Commands
@node Summary of Commands

@vtable @code
@emph{double-clicking} the left button on an object or slot will select it, and it will
then be the parameter for further commands.

@emph{single-clicking} the left button after the @code{=} will let you edit
the value. Hit return to set the value or control-g to abort.

@code{Show Object} - displays the selected object in the same window.

@code{Show in New} - displays the selected object in a new window.

@code{Re-Fetch} - redisplay the current object, and re-fetch the values
of all slots, in case any have changed. This command is also used to
get back to the schema view from the object or dependency views.

@code{Dependencies} - when a formula or a slot containing a formula is
selected, then shows the slots that are used to calculate it (see
section @ref{dependencysec}).

@code{Done} - get rid of this @code{Inspector} window.

@code{Done All} - get rid of all @code{Inspector} windows.

@code{Flash} - if an object is selected, flash it, otherwise flash the
current object being inspected. The object is flashed by bringing its
window to the top and putting an XOR rectangle over it (using the
function @code{gd:flash}).

@code{Search} - Find a slot of the object and display it at the top of
the list. This helps you find slots in a long list, and it will find
inherited slots, so you don't have to hit @code{Inherited Slots} and get
the whole list when you are only interested in one slot. After
hitting the @code{Search} button, you will be prompted for the slot
name, and you can type in a few letters, hit RETURN, and the @code{Inspector}
will try to fill out the name based on all current slots of the object.

@code{Notify} - If a slot is selected, then will print a message in the
@code{Inspector} @emph{and} in the Lisp Listener window
whenever the selected slot of the object is set. If no slot is
selected, then will print a message whenever @emph{any} slot of
the object is set. You can be waiting for a Notify or Break on
multiple slots of multiple objects at the same time. Note that
execution is much slower when there are @emph{any} Breaks or Notifies
in effect. 

@code{Break} - If a slot is selected, then will break into the debugger
whenever the selected slot of the object is set. If no slot is
selected, then will break into the debugger whenever @emph{any} slot of
the object is set. You should go to your Lisp Listener window to
handle the break, and then @emph{continue} from the break (rather than
aborting or popping from the break). The @code{Inspector} will not operate
while you are in the debugger unless you type
@code{(inter:main-event-loop)}.

@code{Clear Breaks} - Clear all the breaks and notifies. All Breaks and
Notifies are also cleared when you hit the @code{Done} or @code{Done All}
buttons. There is no interface for clearing a single break or notify.

@code{Inherited Slots} - Toggle the display of inherited slots in the
schema view.

@code{Objects} - Switch to the object view that shows the is-a and
aggregate hierarchy (see section @ref{inspectobjects}).
@end vtable


@section PS -- Print Schema
@node PS -- Print Schema
The same information that is shown in the Inspector for an object's slots and
values can be printed with the simpler @code{kr:ps}. This function does not
create a new window to show the information, but instead prints right into
the lisp listener.
@example
kr:PS @emph{object} &key @i{types-p  all-p} (@i{control} T) (@i{inherit} NIL) @ref{function}
                (@i{indent} 0) (@i{stream} *standard-output*)
@end example
@cindex{ps}
(All the nuances of this function are described in the KR manual.)

@section Look, What, and Kids
@node Look, What, and Kids
For quick inspection of objects, the @code{look}, @code{what}, and @code{kids} 
functions may be used:
@example
gd:Look @emph{object} &optional (@emph{detail} 2)@ref{function}
@cindex{look}
gd:What @emph{object}@ref{function}
@cindex{what}
gd:Kids @emph{object}@ref{function}
@cindex{kids}
@end example
The @code{look} function prints out varying amounts of information
about an object, depending upon the optional argument @emph{detail}:
@cindex{detail}
@itemize
@code{(look obj 0)} prints a one-line description of @code{obj}. This
is equivalent to calling @code{(what obj)}.

@code{(look obj 1)} prints a one-line description of @code{obj} and also
shows the immediate components of @code{obj} if it is an aggregate.
This form is equivalent to calling @code{(kids obj)}.

@code{(look obj 2)} recursively prints all components of @code{obj}.
This is the default, equivalent to typing @code{(look obj)}. Use
it to look at the structure of an aggregate.

@code{(look obj 3)} prints slots of @code{obj}, using @code{ps}, and
then prints the tree of components.

@code{(look obj 4)} prints slots of @code{obj} and its immediate
components. Any (trees of) sub-components are also printed.

@code{(look obj 5)} prints what is essentially complete information
about a tree of objects, including all slots of all components.
@end itemize
For example, 
@example
* (what mywindow)
#k<MYWINDOW> is-a #k<INTERACTOR-WINDOW> (WINDOW)
--> NIL
* (look mywindow)
#k<MYWINDOW> is-a #k<INTERACTOR-WINDOW> (WINDOW)
   #k<MYAGG> is-a #k<AGGREGATE> (VIEW-OBJECT)
      #k<MYRECT> is-a #k<MOVING-RECTANGLE> (RECTANGLE)
      #k<MYTEXT> is-a #k<CURSOR-MULTI-TEXT> (MULTI-TEXT)
--> NIL
@end example

@section Is-A-Tree
@node Is-A-Tree
Look prints the parent of the object and then the ``standard
parent'' @cindex{standard parent} of the object's parent in parentheses.
The ``standard parent'' is 
the first named object encountered traveling up the @code{:is-a}
tree. If @code{look} does not print enough information about an object,
the @code{is-a-tree} function might be useful:
@example
gd:Is-A-Tree@ref{function}
@cindex{is-a-tree}
@end example
This function traces up @code{:is-a} links and prints the resulting
tree:
@example
* (is-a-tree mytext)
#k<MYTEXT> is-a
   #k<CURSOR-MULTI-TEXT> is-a
      #k<MULTI-TEXT> is-a
         #k<TEXT> is-a
            #k<GRAPHICAL-OBJECT> is-a
               #k<VIEW-OBJECT>
--> NIL
@end example

@section Finding Graphical Objects
@node Finding Graphical Objects
It is often necessary to locate @cindex{locate} 
a graphical object or figure out
why a graphical object is not visible. @cindex{visibility}  The function
@example
gd:Where @emph{object}@ref{function}
@cindex{where}
@end example
prints out the @emph{object}'s @code{:left}, @code{:top}, @code{:width}, 
@code{:height}, and @code{:window} in a one-line format.

@example
* (where mywindow)
#k<MYWINDOW> :TOP 43 :LEFT 160 :WIDTH 355 :HEIGHT 277
--> NIL
* (where myagg)
#k<MYAGG> :TOP 20 :LEFT 80 :WIDTH 219 :HEIGHT 150 :WINDOW #k<MYWINDOW>
--> NIL
@end example

If you are not sure which screen image corresponds with a 
particular Opal object, use the following function:
@example
gd:Flash @emph{object}@ref{function}
@cindex{flash}
@end example
The @code{flash} function will invert the bounding box of @emph{object}
making the object flash on and off. @code{flash} has two interesting
features:
@enumerate
You can @code{flash} aggregates, which are otherwise invisible.

If the object is not visible, @code{flash} will try hard to
tell you why not. Possible reasons include:
@itemize
The object does not have a window,

The window does not have an aggregate,

The object is missing a critical slot (e.g. @code{:left}),

The object is outside of its window,

The object's @code{:visible} slot is @code{nil},

The aggregate containing the object is not visible, or

The object is outside of its aggregate (a problem with the
aggregate).
@end itemize
@end enumerate
@code{Flash} does not test to see if the object is obscured by
another window. If @code{flash} does not complain and you
do not see any blinking, use @code{where} to find the object's
window. Then use @code{where} (or @code{flash}) applied to the window 
to locate the window on your screen. Bring the window to the front
and try again.

The @code{invert} function is similar to @code{flash}, but it leaves
the object inverted. The @code{uninvert} function will undo the 
effect of @code{invert}:
@example
gd:Invert @emph{object}@ref{function}
@cindex{invert}
gd:Uninvert @emph{object}@ref{function}
@cindex{uninvert}
@end example
@code{invert} uses a single Opal rectangle to
invert an area of the screen. If the rectangle is in use, it
is first removed, so at most one region will be inverted at any
given time. Unlike, @code{flash}, @code{invert} depends upon Opal,
so if Opal encounters problems with redisplay, @code{invert} will 
not work (see @code{fix-up-window} in Section @ref{fix-up-windows}).

The previous functions are only useful if you know the name
of a graphical object. To obtain the name of an object that
is visible on the screen, use:
@cindex{locate}
@example
gd:Ident@ref{function}
@cindex{ident}
@end example
@code{Ident} waits for the next input event and reports the object
under the mouse at the time of the event.
In addition to printing the leaf @cindex{leaf} 
object under the mouse,
@code{ident} runs up the @code{:parent} links and prints the chain
of aggregates up to the window.
Some interesting features to note are:
@itemize
@code{ident} will report a window if you do not select an object.

@code{ident} returns a list@footnote{A list is returned rather than
a multiple value because multiple values print out on multiple lines
in CMU Common Lisp, taking too much screen space when @code{ident} is
used interactively.} in the form (@emph{object} @emph{window} @emph{x} @emph{y} @emph{code})
so you can then use the selection in another expression, e.g.
@code{(kr:ps (car (ident)))}. @emph{Object} will be @code{nil} if none was
selected.

@code{ident} also prints the input event and mouse location. For
instance, use @code{ident}
if you want to know the Lisp name @cindex{character code}
for the character 
transmitted when you type the key labeled ``Home'' on your keyboard
or to tell you the window coordinates @cindex{coordinates}
of the mouse.
@end itemize

Another way to locate @cindex{locate} a window is to use the function:
@example
gd:Windows@ref{function}
@cindex{Windows (debugging function)}
@end example
which prints a list of Opal windows and their locations. The
list of windows is returned. Only mapped windows are listed,
so @code{windows} will only report a window that has been
@code{opal:update}'d. @cindex{update}  For example:
@example
* (windows)
#k<MYWINDOW> :TOP 43 :LEFT 160 :WIDTH 355 :HEIGHT 277
#k<DEMO-GROW::VP> :TOP 23 :LEFT 528 :WIDTH 500 :HEIGHT 300
--> (#k<DEMO-GROW::VP> #k<MYWINDOW>)
@end example

@section Inspecting Constraints
@node Inspecting Constraints
@cindex{constraint}
Formulas@cindex{formula} often have unexpected values, and program listings do
not always help when formulas and objects are inherited and/or
created at run time. To make dependencies @cindex{dependencies} 
explicit, the
@code{explain-slot}
@cindex{explain-slot}
@cindex{slot} function can be used:
@example
gd:Explain-Slot @emph{object slot}@ref{function}
@end example
@code{explain-slot} will track down all dependencies of @emph{object}'s
@emph{slot} and prints them. Indirect dependencies that occur when
a formula depends upon the value of another formula are also
printed. The complete set of dependencies is a directed graph,
but the printout is tree-structured, representing a depth-first
traversal of the graph. The search is cut off whenever a 
previously visited node is encountered. This can represent
either a cycle or two formulas with a common dependency.

In the following example, the @code{:top} of @code{mytext} depends
upon the @code{:top} of @code{myrect} which in turn depends upon its
own @code{:box} slot:
@example
* (explain-slot mytext :top)
#k<MYTEXT>'s :TOP is #k<F2449> (20 . T),
which depends upon:
   #k<MYRECT>'s :TOP is #k<F2439> (20 . T),
   which depends upon:
      #k<MYRECT>'s :BOX is (80 20 100 150)
--> NIL
@end example

When @code{explain-slot} is too verbose, a non-recursive version
can be used:@cindex{explain-short}
@example
gd:Explain-Short @emph{object slot}@ref{function}
@end example
For example:
@example
* (explain-short mytext :top)
#k<MYTEXT>'s :TOP is #k<F2449> (20 . T),
which depends upon:
   #k<MYRECT>'s :TOP is #k<|1803-2439|> (20 . T),
      ...
--> NIL
@end example

@emph{Warning:} @code{explain-slot} and @code{explain-short}
may produce incorrect results in the following ways:
@itemize
Both @code{explain-slot} and @code{explain-short} rely on dependency
pointers maintained for internal use by KR.
In the present version,
KR sometimes leaves dependencies around that are no longer current.
This is not a bug because, at worst, extra dependencies only cause
formulas to be reevaluated unnecessarily. However, this may cause
@code{explain-slot} or @code{explain-short} to print extra dependencies.

Formulas may access slots but not use the values. This will create
the appearance of a dependency when none actually exists.

Formulas that that try to follow a null link,@cindex{null link} e.g. 
@code{(gv :self :feedback-obj :top)} where @code{:feedback-obj} is
@code{nil}, may be marked as invalid and have their dependency lists cleared.
@code{explain-slot} and @code{explain-short} will detect this case and
warn you if it happens.
@end itemize

@section Choosing Constant Slots
@node Choosing Constant Slots

Since the use of constants can significantly reduce the storage requirements
and execution time of an application, we have provided several new functions
that help you to choose which slots should be declared constant. The following
functions are used in conjunction to identify slots that are candidates for
constant declarations.


@subsection Suggest-Constants
@node Suggest-Constants
@anchor{suggest-constants}

@cindex{record-from-now}
@cindex{suggest-constants}
@example
gd:Record-From-Now@ref{function}

gd:Suggest-Constants @emph{object} &key @emph{max} (@emph{recompute-p} T) (@emph{level} 1)@ref{function}
@end example

To use these functions, bring up the application you want to analyze, and
execute @code{record-from-now}. Exercise all the parts and gadgets of the
interface that are expected to be operated during normal use, and then
call @code{suggest-constants}. Information will be printed out that identifies
slots which, if declared constant, would cause dependent formulas to be
replaced by their actual values.

Keep in mind that it is usually not necessary to declare every reported slot
constant. Many formulas will @b{become} constant if they depend on constant
slots. For example, declaring many of the parameters of a
@code{gg:text-button-panel} constant in the top-level gadget is sufficient
to eliminate the internal formulas that depend on them.

Also, it is important to exercise @b{all} parts of the application in order to
get an accurate list of constant slot candidates. If you forget to operate
a certain button while recording, slots may be suggested that would cause the
button to become inoperable, since @code{suggest-constants} would assume it
was a static object.

@code{Suggest-constants} will tell you if a potential slot is in the object's
@code{:maybe-constant} list. When the slot is in this list, then it can be
declared constant by supplying the value of T in the @code{:constant} list.
As you add constants, though, you may want to carefully name each slot
individually in the @code{:constant} list to avoid erroneous constant
declarations.

The parameters to @code{suggest-constants} are used as follows:

@vtable @code
@emph{object} - This can be any Garnet object, but it is usually a window or its
top-level aggregate. The function examines formulas in @emph{object} and
all its children.

@emph{max} - This parameter controls how many constant slot candidates are printed
out. The default is to print all potential constant slots that are found
in @emph{object} and all its children.

@emph{recompute-p} - Set this parameter to NIL if you do not need to reexamine
all the objects and you trust what was computed earlier (the same information
that was printed out before will be printed out again, without checking that
it is still valid).

@emph{level} - The default value of @emph{level}, which is 1, causes the
function to print only slots which would, by themselves, eliminate
some formula. If @emph{level} is made higher, slots will be printed that may
not eliminate formulas by themselves, but will at least eliminate some
dependencies from the formulas that remain.

For example, consider a formula that depends on slots A and B. Declaring
constant either A or B alone would not eliminate the formula, so with @emph{level}
set to 1, slots A and B would not be suggested by @code{suggest-constants}.
Setting @emph{level} to 2, however, will printe both A and B, since the
combination of the two slots would indeed eliminate a formula. Higher
values of @emph{level} make @code{suggest-constants} print out formulas that are
less and less likely to eliminate formulas.
@end vtable


@section Explain-Formulas and Find-Formulas
@node Explain-Formulas and Find-Formulas

@example
@cindex{explain-formulas}
gd:Explain-Formulas @emph{aggregate} &optional (@emph{limit} 50) @emph{eliminate-useless-p}@ref{function}
@end example

@code{Explain-formulas} is used to analyze all the formulas that were @b{not}
evaluated since the last call to @code{record-from-now}. These formulas might
have been evaluated when the application was first created, to position the
objects appropriately, but are not a dynamic part of the interface, and are
thus candidates for constant declarations.
If the @emph{eliminate-useless-p} option is non-NIL, then formulas that are 
in fact unnecessary (i.e., would go away if they were recomputed) are actually
eliminated immediately.


@example
@cindex{find-formulas}
gd:Find-Formulas @emph{aggregate} &optional (@emph{only-totals-p} T) (@emph{limit} 50) @emph{from}@ref{function}
@end example

If the function @code{find-formulas} is called with a non-NIL @emph{only-totals-p}
option, it will print out the total number of formulas that have not
been reevaluated since the last call to @code{record-from-now}.
If @emph{only-totals-p} is NIL and @emph{limit} is specified,
it will print out at most @emph{limit} formula names. If @emph{limit} is NIL,
all formula names will be printed out.

You will seldom need to specify the @emph{from} parameter. This allows you
to print out formulas that have been unevaluated since @emph{from}. The
default value is the number returned by the last call to
@code{record-from-now}; specifying a smaller number reduces the number of
formulas that are printed out, since formulas that were evaluated
earlier are discarded.


@section Count-Formulas and Why-Not-Constant
@node Count-Formulas and Why-Not-Constant
@anchor{count-formulas}

@cindex{count-formulas}
@example
gd:Count-Formulas @emph{object}@value{function}
@end example

@code{Count-formulas} will print a list of all existing formulas in @emph{object}
and all its children. It is important to note that formulas are not copied
down into an object until they are specifically requested by a @code{g-value}
or @code{gv} call. Thus, you may not get an accurate count of the real number
of formulas in an object until you exercise the object in its intended way.
For example, if a prototype @code{A} has a formula in its
@code{:left} slot and you count the formulas in @code{B}, an instance of @code{A},
before asking for @code{B}'s @code{:left} slot, then @code{B}'s @code{:left} formula
will not be counted, because it has not been copied down yet.
@sp 1


@cindex{why-not-constant}
@example
gd:Why-Not-Constant @emph{object  slot}@value{function}
@end example

This function is extremely useful when you are trying to get rid of formulas
by declaring constant slots. If @code{count-formulas} tells you that formulas
still exist in your application that you think should go away due to
propagation of constants, then you can call @code{why-not-constant} on a
particular slot to find out what its formula depends on. The function will
print out a list of dependencies for the formula in the @emph{slot}, which will
give you a hint about what other slot could be declared constant to make
this formula go away.




@section Noticing when Slots are Set
@node Noticing when Slots are Set

@anchor{notify-on-slot-set-sec}

It is often useful to be notified when a slot of an object is set, so now
we provide a set of debugging functions that do this. There is also an
interface to these functions through the @code{Inspector} (section
@ref{inspectorsec}) which makes them more convenient to use.

Note that the
implementation of this is @emph{very} inefficient and is intended only
for debugging. Don't use this as general-purpose demon technique
since a search is performed for @emph{every} formula evaluation and every
slot setting when any notifies or breaks are set.

@cindex{Notify-On-Slot-Set}
@example
gd:Notify-On-Slot-Set &key @emph{object  slot  value} @ref{function}
@end example

This will print out a message in the Lisp Listener window whenever the
appropriate slot is set. If a value is supplied, then only notifies
when the slot is set to that particular value. 
If an object is provided, then only notifies
when a slot of that object is set. If no object is supplied, then
notifies whenever @emph{any} object is set. If a slot is provided, then
only notifies when that slot is set. If no slot is supplied, then
notifies whenever @emph{any} slot is set. If object is NIL, then clears
all breaks and notifies. If all parameters are missing, then shows
current status. For example,
@example
(gd:Notify-On-Slot-Set :object obj :slot :left) @emph{;notify when :left of obj set}
(gd:Notify-On-Slot-Set :object obj :slot :left :value 0) @emph{;notify when :left of obj set to 0}
(gd:Notify-On-Slot-Set :value NIL) @emph{;notify when any slot of any obj set to NIL}
(gd:Notify-On-Slot-Set :object obj) @emph{;notify when any slot of obj set}
@end example

Each call to @code{Notify-On-Slot-Set} adds to the previous list of
breaks and notifies, unless the object is NIL. You can use
@code{clear-slot-set} to remove a break or notify (see below).

@cindex{Break-On-Slot-Set}
@example
gd:Break-On-Slot-Set &key @emph{object  slot  value} @ref{function}
@end example

Same as @code{Notify-On-Slot-Set}, but breaks into the debugger when the
appropriate slot is set.

@cindex{Call-Func-On-Slot-Set}
@example
gd:Call-Func-On-Slot-Set @emph{object  slot  value  fnc  extra-val} @ref{function}
@end example
This gives you more control, since you get to supply the function
that is called when the appropriate slot is set. The parameters here are not
optional, so if you don't want to specify the object, slot or value,
use the special keyword @code{:*any*}. The function @code{fnc} is called as:
@example
(lambda (obj slot val reason extra-val))
@end example
where the @emph{slot} of @emph{obj} is being set with @emph{val}. The
@emph{reason} explains why the slot is being set and will be one
of @code{:s-value}, @code{:formula-evaluation}, @code{:inheritance-propagation} or
@code{:destroy-slot}. @emph{Extra-val} can be anything 
and is the same value passed into @code{Call-Func-On-Slot-Set}.

@cindex{Clear-Slot-Set}
@example
gd:Clear-Slot-Set &key @emph{object  slot  value} @ref{function}
@end example
Clear the break or notify for the object, slot and value. If nothing is
specified or object is NIL, then clears all breaks and notifies.



@section Opal Update Failures
@node Opal Update Failures

@cindex{update}
@anchor{fix-up-windows}
Opal assumes that graphical objects have valid display parameters
such as @code{:top} or @code{:width}. If a parameter is computed
by formula and there is a bug, the problem will often cause an
error within Opal's @code{update} function.

A "quarantine slot" named @code{:in-progress} exists in all Garnet windows.
If there was a crash during the last update of the window, then the window
will stop being updated automatically along with the other Garnet windows,
until you can fix the problem and update the window successfully. The
quarantine slot is discussed in detail in the Opal Manual.

There are several ways to proceed after an update failure.
The first and easiest action is to run @code{opal:update} with
the optional parameter @code{t}:
@example
(opal:update window t)
@end example
This forces @code{opal:update} to do a complete update of @code{window}
as opposed to an incremental update. This may fix your problem
by bringing all slots up-to-date and expunging previous display
parameters.

Another possibility is, after entering the debugger, call
@example
gd:Explain-NIL@ref{function}
@end example
This function@cindex{explain-nil} 
will check to see if a formula tried to follow a
null link @cindex{null link}
(a typical cause of Opal object slots becoming @code{nil}).
If so, the object and slot associated with the formula will be
printed followed by objects and slots on which the 
formula depends@footnote{@code{Explain-nil} does not use the same
technique for finding dependencies as @code{explain-slot}, which
uses forward pointers from the formula's @code{:depends-on} slot. 
Since @code{:depends-on} is currently cleared when a null link is
encountered, @code{explain-nil} uses back pointers from the
objects back to the formula. These are in the @code{:depended-upon}
slot of objects. To locate the back pointers, @code{explain-nil}
searches for all components of all Opal windows. Only objects in
windows are searched, so dependencies on non-graphical objects
will be missed.}.
One of the slots depended upon will be the null link that caused
the formula to fail. 

@emph{Warning:} @code{explain-nil} will always
attempt to describe the last formula that failed due to a null
link @emph{since the last time @code{explain-nil} was evaluated}.
This may or may not be relevant to the bug you are searching
for. The last error is cleared every time @code{explain-nil} is
evaluated to reduce confusion over old errors.
If there has been no failure, @code{explain-nil} will print
@example
No errors in formula evaluation detected
@end example

A third possibility is to run@cindex{fix-up-window}

@defun gd:fix-up-window window

on the window in question. (You may want to use @code{windows} to
find the window object.)  @code{fix-up-window} will do type checking
@cindex{type checking}
without attempting a redisplay. If an error is detected, 
@code{fix-up-window} will allow you to interactively remove 
objects with problems from the window.

After fixing the problem that caused @code{update} to crash, you should be
able to do a successful total update on the window (discussed above).
A successful total update will clear the quarantine slot, and will allow
interactions to take place in the window normally.

@end defun


@section Inspecting Interactors
@node Inspecting Interactors

@cindex{interactors}
@section Tracing
@node Tracing
@cindex{tracing}
A common problem is to create some graphical objects and an interactor 
but to discover that nothing happens when you try to interact with
the program. If you know what interactor is not functioning, then
you can trace its behavior using the function
@example
inter:Trace-Inter @emph{interactor}@ref{function}
@cindex{trace-inter}
@end example
This function enables some debugging printouts in the interactors 
package that should help you determine what is wrong. A set of
things to trace is maintained internally, so you can call
@code{inter:trace-inter} several times to trace several things.
In addition to interactors, the parameter can be one of:
@itemize
@code{t} --- trace everything.

@code{NIL} --- untrace everything, same as calling @code{inter:untrace-inter}.

@code{:window} --- trace things about interactor windows such as
@code{create} and @code{destroy} operations.

@code{:priority-level} --- trace changes to priority levels.

@code{:mouse} --- trace @code{set-interested-in-moved} and @code{ungrab-mouse}.

@code{:event} --- show all events that come in.

@code{:next} --- start tracing when the next interactor runs, and trace
that interactor.

@code{:short} --- report only the name of the interactor that runs, so that
the output is much less verbose. This is very useful if you suspect that more
than one interactor is accidentally running at a time.
@end itemize
Tracing any interactor will turn on @code{:event} tracing by default. Call
@code{(inter:untrace-inter :event)} (see below) to stop @code{:event} tracing.

Just typing
@example
(inter:trace-inter)
@end example
will print out the interactors currently being traced.

@example
inter:Untrace-Inter @emph{interactor}@ref{function}
@cindex{untrace-inter}
@end example
can be used to selectively stop tracing a single interactor or
other category. You can also
pass @code{t} or @code{nil}, or no argument to @code{untrace} to stop all tracing:
@example
(inter:untrace-inter)
@end example


@section Describing Interactors
@node Describing Interactors
If you are not debugging a particular interactor, there are a few
ways to proceed other than wading through a complete interactor trace.
First, you can find out what interactors are active by calling:
@example
gd:Look-Inter &optional @emph{interactor-or-object} @emph{detail}@ref{function}
@cindex{look-inter}
@end example

The parameter @emph{interactor-or-object} can be:

@itemize
NIL to list all active interactors (see below),

an interactor to describe,

a window, to list all active interactors on that window,

an interactor priority-level, to list all active interactors on that level,

a graphical object, to try to find all interactors that affect that object,

@code{:next} to wait and describe the next interactor that runs
@end itemize

With no arguments (or NIL as an argument), @code{look-inter} will print all
active interactors
(those with their @code{:active} and @code{:window} slots set to something)
sorted by priority level @cindex{priority level}:
@example
* (look-inter)
Interactors that are :ACTIVE and have a :WINDOW are:
Level #k<RUNNING-PRIORITY-LEVEL>: 
Level #k<HIGH-PRIORITY-LEVEL>: #k<DEMO-GROW::INTER2> 
Level #k<NORMAL-PRIORITY-LEVEL>: #k<MYTYPER> #k<MYMOVER> #k<DEMO-GROW::INTER3>
 #k<DEMO-GROW::INTER4> #k<DEMO-GROW::INTER1>
--> NIL
@end example

If @emph{detail} is 1, @code{look-inter} will show the @code{:start-event} and 
@code{:start-where} of each active interactor:
@example
* (look-inter 1)
Interactors that are :ACTIVE and have a :WINDOW are:
Level #k<RUNNING-PRIORITY-LEVEL>: 
Level #k<HIGH-PRIORITY-LEVEL>: #k<DEMO-GROW::INTER2> 
Level #k<NORMAL-PRIORITY-LEVEL>: #k<MYTYPER> #k<MYMOVER> #k<DEMO-GROW::INTER3>
 #k<DEMO-GROW::INTER4> #k<DEMO-GROW::INTER1>
#k<DEMO-GROW::INTER2> (MOVE-GROW-INTERACTOR)
   starts when :LEFTDOWN (:ELEMENT-OF #k<AGGREGATE-164>)
#k<MYTYPER> (TEXT-INTERACTOR)
   starts when :RIGHTDOWN (:IN #k<MYTEXT>)
#k<MYMOVER> (MOVE-GROW-INTERACTOR)
   starts when :LEFTDOWN (:IN #k<MYRECT>)
#k<DEMO-GROW::INTER3> (MOVE-GROW-INTERACTOR)
   starts when :MIDDLEDOWN (:ELEMENT-OF #k<AGGREGATE-136>)
#k<DEMO-GROW::INTER4> (MOVE-GROW-INTERACTOR)
   starts when :RIGHTDOWN (:ELEMENT-OF #k<AGGREGATE-136>)
#k<DEMO-GROW::INTER1> (BUTTON-INTERACTOR)
   starts when :LEFTDOWN (:ELEMENT-OF-OR-NONE #k<AGGREGATE-136>)
--> NIL
@end example
To get information about a single interactor, pass
the interactor as a parameter:
@example
* (look-inter mymover)
#k<MYMOVER>'s :ACTIVE is T, :WINDOW is #k<MYWINDOW>
#k<MYMOVER> is on the #k<NORMAL-PRIORITY-LEVEL> level
#k<MYMOVER> (MOVE-GROW-INTERACTOR)
   starts when :LEFTDOWN (:IN #k<MYRECT>)
--> NIL
@end example

In some cases you need to know what interactor will affect a given
object (perhaps located using the @code{ident} function). This is
not possible in general since the object(s) an interactor
changes may be referenced by arbitrary application code. However,
if you use interactors in fairly generic ways, you can call
@code{look-inter} with a graphical object as argument to search
for relevant interactors:
@example
* (look-inter myrect)
#k<MYMOVER>'s :start-where is (:IN #k<MYRECT>)
--> NIL
* (look-inter mytext)
#k<MYTYPER>'s :start-where is (:IN #k<MYTEXT>)
--> NIL
@end example

The search algorithm used by look-inter is fairly simple:
the current value of @code{:start-where} is interpreted to see
if it could refer to the argument. Then the @code{:feedback-obj}
and @code{:obj-to-change} slots are examined for an exact match
with the argument. If formulas are encountered, only the current
value is considered, so there are a number of ways in which
@code{look-inter} can fail to find an interactor.

@section Sizes of Objects
@node Sizes of Objects

@cindex{size}
Several functions are provided to help make size measurements of 
Opal objects and aggregates.
@example
gd:ObjBytes @emph{object}@ref{function}
@end example
will measure the size of a single Opal object or interactor in bytes.

@example
gd:AggBytes @emph{aggregate} &optional @emph{verbose}@ref{function}
@end example
will measure the size of an Opal aggregate and all of its
components in bytes. The first
argument may also be a list of aggregates, a window, or a list
of windows. For example, to compute the total size of all graphical
objects, you can type this:
@example
(aggbytes (windows))
@end example
The output will include various statistics on size according
to object type. Sizes are printed in bytes, and
the returned value will be the total size in 
bytes. The size information @emph{does not} include any interactors
because interactors can exist independent of the 
aggregate hierarchy. 
The optional @emph{verbose} flag defaults to @code{t}; setting
it to nil will reduce the detail of the printed information.

@example
gd:InterBytes &interactor @emph{window} @emph{verbose}@ref{function}
@end example
will report size information on the interactors whose @code{:window}
slot @emph{currently} 
contains the specified window. If the @emph{window} parameter is
omitted, @code{t} or @code{nil}, then the size of all interactors is
computed. (Use @code{objsize} for a single interactor.)  Note that
an interactor may operate in more than one window and that interactors
can follow objects from window to window. As with
@code{aggbytes}, the @emph{verbose} flag defaults to @code{t}; setting
it to nil will reduce the detail of the printed information.

@example
gd:*Avoid-Shared-Values*@ref{variable}
@end example
@cindex{*avoid-shared-values*}
Normally, @code{aggbytes} does not consider the fact that list
structures may be shared, so shared storage is counted multiple
times. To avoid this (at the expense of using a large hash table),
set @code{avoid-shared-values} to @code{t}.

@example
gd:*Avoid-Equal-Values*@ref{variable}
@end example
@cindex{*avoid-equal-values*}
To measure the potential for sharing, set this variable to @code{t}.
This will do hashing using @code{#'equal} so that equal values will
be counted as shared instead of @code{#'eq}, which
measures actual sharing.

@example
gd:*Count-Symbols*@ref{variable}
@end example
@cindex{*count-symbols*}
Ordinarily, storage for object names is not counted as part of the
storage for objects. By setting this variable for true, the
sizes reported by @code{objbytes} and @code{aggbytes} will include
this additional symbol storage overhead.

@b{Note:} Size information for an object includes the size of
any attached formulas. At present, only objects and cons cells
are counted. Storage for structures (other than KR
schema), strings, and arrays is @emph{not} counted. 


@ref{References}

@chapter Demonstration Programs for Garnet
@node Demonstration Programs for Garnet

by Brad A. Myers,
Andrew Mickish

@value{DATE}

@section Abstract
@node Abstract

This file contains an overview of the demonstration programs distributed
with the Garnet toolkit. These programs serve as examples of what Garnet
can do, and also of how to write Garnet programs.




@section Introduction
@node Introduction
Probably the best way to learn about how to code using the Garnet
Toolkit is to look at example programs. Therefore, we have provided a
number of them with the Toolkit release. In addition, you can load and run
the demos to see what kinds of things Garnet can do. 

The ``best'' example program is @code{demo-editor}, which is included in this
technical report. The other example programs serve mainly to show how
particular special features of Garnet can be used.

Unfortunately, many of the demonstration programs were implemented before
important parts of the Garnet Toolkit were implemented. For example, many
of the demos do not use Aggregadgets and Aggrelists. These
particular demos are
@emph{not} good examples of how we would code today. Hopefully, we will soon
re-code all of these old demos using the newest features, but for the time
being, you will probably only want to look at the code of the newer demos.

This document provides a guide to the demo programs, what they are supposed
to show, and whether they are written with the latest style or not.


@section Loading and Compiling Demos
@node Loading and Compiling Demos
@anchor{loadingandcompilingdemos}

@cindex{Compiling demos}
If for some reason the demos were not compiled during the standard installation
procedure discussed in the Overview Manual, you can compile just the demos
by executing (garnet-load "demos-src:demos-compiler"). This will generate
new binaries for the demos, which will need to be copied from the
@code{src/demos/} directory into your @code{bin/demos} directory.

Normally, the demonstration programs are @emph{not} loaded by the standard
Garnet loader. The best way to view the demos is to load the
@code{garnet-loader} as usual and then load the Demos Controller:
@example
(garnet-load "demos:demos-controller")
(demos-controller:do-go)
@end example

This will load the controller itself, but not any of the demos. It will
display a window with a set of check buttons in it. Just click with the mouse
on a button, and the corresponding demo will be loaded and started.
Clicking on the check box again will stop the demo. Clicking again will
restart it (but not re-load it). An instruction window will appear at the
bottom of the screen with the instructions for the last demo started.

The @code{demos-controller} application features the @code{gg:mouseline} gadget.
When you keep the mouse still over one of the x-buttons for about 2 seconds,
a window will pop up with a short description of the corresponding demo.
For more information about this gadget, see the appropriate section of the
Gadgets Manual.

Using the @code{demos-controller} causes each demo file to be loaded as it is
needed. If you wanted to load @emph{all} of the demos at once (whether you
eventually planned to use the @code{demos-controller} or not), you could set
@code{user::load-demos-p} to be T before loading @code{garnet-loader}, or
execute @code{load Garnet-Demos-Loader}.

All of the demos described here are in the sub-directory @code{demos}.

@section Running Demo Programs
@node Running Demo Programs
@cindex{running demos}
@cindex{starting demos}
@cindex{stopping demos}
@cindex{do-go}
@cindex{do-stop}

To see a particular demo program, it is not necessary to use the Demos
Controller described in section @ref{loadingandcompilingdemos}.
Instead, the file can be loaded and executed by itself.

Almost all of the demonstration programs operate the same way. Once a file
@code{demo-}@emph{xxx} is loaded, it creates a package called @code{demo-}@emph{xxx}.
In this package are two procedures -- @code{do-go} to start the demo and
@code{do-stop} to stop it. Therefore, to begin a demo of @emph{xxx}, you would
type: @code{(demo-@emph{xxx}:do-go)}. The @code{do-stop} procedure destroys the
window that the demo is running in. You can load and start as many demos
as you like at the same time. Each will run in its own separate window. 

The @code{do-go} procedure will print instructions in the Lisp window about
how to operate the demonstration program.

Demos for the individual gadgets are all in the @code{garnet-gadgets} package
and have unique names. Section @ref{gadgetdemos} describes how to see
these demos.


@section Double-Buffered Windows
@node Double-Buffered Windows
@cindex{double-buffered windows}

All the demos can take advantage of the Opal feature for double-buffered
windows. The @code{do-go} routine for each demo has an optional
@code{:double-buffered-p} argument that defaults to NIL. For instance, to
run @code{demo-3d} on a double-buffered window, say:
@code{(demo-3d:do-go :double-buffered-p T)}
and to run it normally, say:
@code{(demo-3d:do-go)}


@section Best Examples
@node Best Examples

@subsection GarnetDraw
@node GarnetDraw
@cindex{Garnetdraw}
@cindex{Drawing program}
There a useful utility called @code{GarnetDraw} which is a
relatively simple drawing program written using Garnet. Since the file format
for storing the created objects is simply a Lisp file which creates
aggregadgets, you might be able to use GarnetDraw to prototype
application objects (but Lapidary is probably better for this).

GarnetDraw uses many features of Garnet including gridding, PostScript
printing, selection of all objects in a region, moving and growing of multiple
objects, menubars, and the @code{save-gadget} and @code{load-gadget} dialog boxes.
The editing functions like Cut, Copy, and Paste are
implemented using the @code{Standard-Edit} module from @code{garnet-gadgets},
and objects can be cut and pasted between @code{GarnetDraw} and @code{Gilt}
(since they share the same clipboard). Accelerators are defined for the
menubar commands, like @code{META-x} for Cut and
@code{META-v} for Paste.

GarnetDraw works like most Garnet programs: select in the palette
with any button, draw in the main window with the right button, and select
objects with the left button. Select multiple objects with shift-left or
the middle mouse button. Change the size of objects by pressing on black
handles and move them by pressing on
white handles. The line style and color and filling color can be
changed for the selected object and for further drawing by clicking on
the icons at the bottom of the palette.
You can also edit the shape of polylines:
create a polyline, select it, and choose "Reshape" from the "Edit" menu.

@subsection Demo-Editor
@node Demo-Editor
@anchor{demoeditor}
@cindex{demo-editor}
Probably the best example program is the sample graphics editor in the
file @code{demo-editor.lisp}.
It demonstrates many of the basic components when building a Garnet
application. This demo automatically loads and uses the
@code{text-button-panel}, @code{graphics-selection}, and @code{arrow-line}
gadgets.


@subsection Demo-Arith
@node Demo-Arith
@cindex{demo-arith}
@cindex{Postscript in demo-arith}
@cindex{Gestures in demo-arith}

@code{Demo-arith} is a simple visual programming interface for constructing
arithmetic expressions. It uses constraints to solve the expressions.
There are buttons for producing PostScript output from the picture.
Also, you can create new objects using gestures by dragging with the
middle mouse button (rather than selecting them from the palette).
The instructions are printed when the program is started.



@subsection Demo-Grow
@node Demo-Grow
@anchor{demogrow}
@cindex{demo-grow}
@cindex{graphics-selection}
@code{Demo-grow} shows how to use the @code{graphics-selection} gadget.
It uses the same techniques as in @code{demo-editor} (section @ref{demoeditor}).


@subsection Multifont and Multi-Line Text Input
@node Multifont and Multi-Line Text Input
@cindex{text-interactor}
@cindex{multi-line text input}
@cindex{multifont text input}
@cindex{demo-text}

@code{Demo-text} shows how multi-line, multi-font text input can be handled. 
It does not use Aggregadgets or any gadgets, but none are necessary.


@subsection Demo-Multifont
@node Demo-Multifont
@cindex{demo-multifont}

To see how to effectively use the multifont text object, along with its
interactors, examine the @code{demo-multifont} demo. Most of the code
is actually a good demonstration of how to use the @code{menubar} and
@code{motif-scrolling-window-with-bars} gadgets, but the
@code{multifont-text} objects and interactors are in there. Features
demonstrated include word wrap and how to changing the fonts with the special
multifont accelerators.

The @code{lisp-mode} feature of @code{multifont-text} is also shown in this
demo. Select "Toggle Lisp Mode" from the "Edit" menu, and type in a lisp
expression (like a @code{defun} definition). As you hit return, the next line
will be automatically indented according to standard lisp conventions. Hitting
the tab key will re-indent the current line.


@subsection Creating New Objects
@node Creating New Objects
@cindex{creating new objects}
@cindex{demo-twop}
@cindex{two-point-interactor}

@code{Demo-twop} shows how new lines and new rectangles can be input. It
uses the same techniques as in @code{demo-editor} (section @ref{demoeditor}).

@subsection Angles
@node Angles
@cindex{Angle-Interactor}
@cindex{demo-angle}
@cindex{gauge}
There are two programs that demonstrate how to use the angle interactor.
@code{Demo-angle} contains circular gauges (but see the @code{gauge}
gadget, section @ref{gadgetdemos}), as
well as a demonstration of how to use the ``angle-increment''
parameter to the angle @code{:running-action} procedure.

@cindex{demo-clock}
@cindex{clock}
@code{Demo-clock} shows a clock face with hands that can be rotated with the
mouse.


@subsection Aggregraphs
@node Aggregraphs
@cindex{aggregraphs}
@cindex{demo-graph}
The @code{demo-graph} file is an example of many features of Aggregraphs.


@subsection Scroll Bars
@node Scroll Bars
@cindex{scroll bars}
Although sliders and scroll bars are provided in the Garnet Gadget set
(the @code{gadgets} subdirectory), the file @code{demo-scrollbar} contains
some alternative scroll bar objects. The Macintosh scroll bar in this demo
was written in the old Garnet style, but there are new versions of scroll bars
in the OpenLook, Next, and Motif style.

To see the demo of all four scroll bars, use the functions
@code{demo-scrollbar:do-go} and @code{demo-scrollbar:do-stop} as usual. There
are also functions that display the scroll bars individually called
@code{mac-go}, @code{open-go}, @code{next-go}, and @code{motif-go}.


@subsection Menus
@node Menus
@cindex{demo-menu}
@code{Demo-menu} shows a number of different kinds of menus that can be
created using Garnet. All of them were implemented using Aggregadgets and
Aggrelists.


@subsection Animation
@node Animation
@cindex{animation}

@cindex{demo-animator}
@code{Demo-animator} uses background animation processes to move several objects
in a window. One of the objects is a walking figure which moves across the 
screen by rapidly redrawing a pixmap.

@cindex{demo-fade}
@code{Demo-fade} shows a simple animation for the Garnet acronym.

@code{Demo-logo} performs the same animation as @code{demo-fade}, but it
also includes the Garnet logo.


@subsection Garnet-Calculator
@node Garnet-Calculator

@cindex{garnet-calculator}
@cindex{demo-calculator}
@cindex{calculator}
The @code{garnet-calculator} has the look and feel of @code{xcalc}, the calculator
supplied by X windows, but it is more robust. The calculator is a
self-contained tool, and can be integrated inside a larger Garnet application.

You can load the demo with @code{(garnet-load "demos:garnet-calculator")}.
To run it, execute @code{(garnet-calculator:do-go)}.
@sp 1

@cindex{start-calc}
@cindex{stop-calc}
@example
garnet-calculator:Start-Calc &key @i{double-buffered-p} @ref{function}

garnet-calculator:Stop-Calc @i{app-object} &optional (@i{destroy-app-object?} T) @ref{function}
@end example

The function @code{start-calc} creates and returns a calculator
"application object" that can be used by a larger interface, and this object
should be passed as the @emph{app-object} parameter to @code{stop-calc}.




@subsection Browsers
@node Browsers
@cindex{browser-gadget}
@cindex{demo-schema-browser}
@cindex{demo-file-browser}
The files @code{demo-schema-browser} and @code{demo-file-browser} show two
uses of the @code{browser-gadget}.


@subsection Demo-Virtual-Agg
@node Demo-Virtual-Agg
@cindex{Demo-Virtual-Agg}

To show off an example of virtual-aggregates, load Demo-Virtual-Agg and say:

@example
(demo-virtual-agg:do-go :num-dots 1000)
@end example

@code{Demo-virtual-agg:do-go} takes a single optional keyed parameter
@code{:num-dots} which tells how many circles should appear in a window.
The default is 1000.

The first 1000 circles are read in from circles.data in the
@code{user::Garnet-DataFile-PathName} directory (because that's
faster) and the rest are chosen randomly. A '.' is printed out for
every ten circles.

You will also see a little star in the upper left on the screen, in front
of the @code{virtual-aggregate}, and a big gray rectangle underneath the
@code{virtual-aggregate}. These are just to show that the update
algorithm is working reasonably well.

@vtable @code
Clicking with the left button creates a new circle (of random radius and
    color) where you clicked.

Clicking with the right button "destroys" the top-most circle underneath
    where you clicked, or beeps if there was nothing under there.

Clicking on the little star and dragging moves the little star.

Clicking shift-middle causes the circle underneath the cursor to change
to a different random color. (This shows off @code{change-item}.)

Clicking shift-right causes the entire @code{virtual-aggregate}
to disappear or reappear.
@end vtable


@subsection Demo-Pixmap
@node Demo-Pixmap
@cindex{demo-pixmap}

This new demo shows a two-dimensional @code{virtual-aggregate} in action.
Here, the @code{virtual-aggregate} is a 50 X 50 array of 5 X 5 rectangles.
Each rectangle can be colored from the color palette, and the pattern of
colored rectangles is reflected in a pixmap.

You can load a pixmap into the demo (e.g., from the directory
@code{Garnet-Pixmap-PathName}), edit the pixmap with the color palette and
virtual-aggregate, and then save the pixmap to a new file. You can also
generate PostScript files from this demo, though you have to have a Level 2
printer (that defines the PostScript function @code{colorimage}) to print
a color pixmap image.



@subsection Demo-Gesture
@node Demo-Gesture
@cindex{demo-gesture}
@code{Demo-gesture} is an example of how the new gesture-interactor can be used
in an interface. In this demo, you can create perfect circles and
rectangles by drawing rough approximations with the mouse, which are
interpreted by the gesture recognizer. Gestures may also be used to copy
and delete the shapes you have created.

@subsection Demo-Unidraw
@node Demo-Unidraw
@cindex{demo-unidraw}
@code{Demo-Unidraw} is a gesture-based text editor, which allows you to enter
characters with freehand drawing using the mouse. The gestures that
this demo understands are comprised of a shorthand alphabet devised by
David Goldberg at Xerox Parc. The gesture patterns are shown in the middle
of the demo window, and the canvas for drawing gestures is at the bottom.
As the demo recognizes the gestures you draw, it selects the corresponding
gesture and puts the new character in the text window.


@subsection Gadget Demos
@node Gadget Demos
@cindex{gadgets}
@anchor{gadgetdemos}

@cindex{demo-gadgets}
@cindex{demo-motif}
There are separate demo programs of some of the gadgets in the files
@code{demo-gadgets} and @code{demo-motif}. Each of these packages export the
usual @code{do-go} and @code{do-stop} procedures, and can be found in the
@code{demos} directory.

Other good examples are the Garnet Gadgets, stored in the @code{gadgets}
sub-directory. These were @emph{all} written using the latest
Garnet features. At the end of almost all gadget files is a small demo
program showing how to use that gadget. Since all the gadgets are
in the same package (@code{garnet-gadgets}), the gadget demos all have
different names. They are:
@itemize
@code{Arrow-line-go, Arrow-line-stop}
@cindex{arrow-line-go}
- to demonstrate arrow-lines

@code{Error-gadget-go, Error-gadget-stop}
@cindex{error-gadget}
@cindex{query-gadget}
@cindex{error-gadget-go}
- to demonstrate both the error gadget and the query gadget

@code{Gauge-go, Gauge-stop}
@cindex{gauge}
@cindex{gauge-go}
- to demonstrate circular gauges

@code{H-scroll-go, H-scroll-stop}
@cindex{H-scroll-go}
- to demonstrate standard horizontal scroll bars

@code{H-slider-go, H-slider-stop}
@cindex{H-slider-go}
- to demonstrate standard horizontal sliders

@code{Labeled-box-go, Labeled-box-stop}
@cindex{Labeled-Box-go}
- to demonstrate labeled text-type-in objects

@code{Menu-go, Menu-stop}
@cindex{Menu-go}
- to demonstrate a standard menu

@code{Menubar-go, Menubar-stop}
@cindex{Menubar-go}
- to demonstrate pull-down menus

@code{Motif-Check-Buttons-go, Motif-Check-Buttons-stop}
@cindex{Motif-Check-Buttons-go}
- to demonstrate Motif style check buttons

@code{Motif-Error-Gadget-go, Motif-Error-Gadget-stop}
@cindex{motif-error-gadget}
@cindex{motif-query-gadget}
@cindex{motif-error-gadget-go}
- to demonstrate both the motif error gadget and the motif query gadget

@code{Motif-Gauge-go, Motif-Gauge-stop}
@cindex{Motif-Gauge-go}
- to demonstrate the Motif style gauge

@code{Motif-H-Scroll-go, Motif-H-Scroll-stop}
@cindex{Motif-H-Scroll-go}
- to demonstrate Motif style horizontal scroll bars

@code{Motif-Menu-go, Motif-Menu-stop}
@cindex{Motif-Menu-go}
- to demonstrate the Motif style menus

@code{Motif-Menubar-go, Motif-Menubar-stop}
@cindex{Motif-Menubar-go}
- to demonstrate the Motif style menubar, with accelerators

@code{Motif-Option-Button-go, Motif-Option-Button-stop}
@cindex{motif-option-button-go}
- to demonstrate the Motif style version of this popup menu gadget, whose
button changes labels according to the menu selection

@code{Motif-Radio-Buttons-go, Motif-Radio-Buttons-stop}
@cindex{Motif-Radio-Buttons-go}
- to demonstrate Motif style radio buttons

@code{Motif-Scrolling-Labeled-Box-go, Motif-Scrolling-Labeled-Box-stop}
@cindex{Motif-Scrolling-Labeled-Box-go}
- to demonstrate the Motif style text-type-in field

@code{Motif-Scrolling-Window-With-Bars-go, Motif-Scrolling-Window-With-Bars-stop}
@cindex{Motif-Scrolling-Window-go}
- to demonstrate the Motif style scrolling window gadget

@code{Motif-Slider-go, Motif-Slider-stop}
@cindex{Motif-Slider-go}
- to demonstrate the vertical Motif slider

@code{Motif-Text-Buttons-go, Motif-Text-Buttons-stop}
@cindex{Motif-Text-Buttons-go}
- to demonstrate Motif style text buttons

@code{Motif-Trill-go, Motif-Trill-stop}
@cindex{motif-trill-go}
- to demonstrate the Motif style trill device

@code{Motif-V-Scroll-go, Motif-V-Scroll-stop}
@cindex{Motif-V-Scroll-go}
- to demonstrate the Motif vertical scroll bar

@code{Mouseline-go, Mouseline-stop}
@cindex{mouseline-go}
- to demonstrate the mouseline and "balloon help" string

@code{Multifont-Gadget-go, Multifont-Gadget-stop}
@cindex{multifont-gadget-go}
- to demonstrate the gadget which is a conglomeration of a multifont-text,
a focus-multifont-textinter, and a selection-interactor

@code{Option-Button-go, Option-Button-stop}
@cindex{option-button-go}
- to demonstrate this kind of popup menu gadget, whose button label changes
according to the menu selection

@code{Popup-Menu-Button-go, Popup-Menu-Button-stop}
@cindex{popup-menu-button-go}
- to demonstrate this kind of popup menu gadget, whose button label is fixed
and may be a bitmap or other object

@code{Prop-Sheet-For-Obj-go, Prop-Sheet-For-Obj-stop}
@cindex{prop-sheet-for-obj-go}
- to demonstrate how prop-sheets can be used to change slot values of Garnet
objects

@code{Radio-Buttons-go, Radio-Buttons-stop}
@cindex{Radio-Buttons-go}
- to demonstrate radio buttons

@code{Scrolling-Input-String-go, Scrolling-Input-String-stop}
@cindex{Scrolling-Input-String-go}
- to demonstrate the scrolling input string gadget

@code{Scrolling-Labeled-Box-go, Scrolling-Labeled-Box-stop}
@cindex{Scrolling-Labeled-Box-go}
- to demonstrate the standard scrolling labeled box

@code{Scrolling-Menu-go, Scrolling-Menu-stop}
@cindex{Scrolling-Menu-go}
- to demonstrate the scrolling menu gadget

@code{Scrolling-Window-go, Scrolling-Window-stop}
@cindex{Scrolling-Window-go}
- to demonstrate the standard scrolling window

@code{Scrolling-Window-With-Bars-go, Scrolling-Window-With-Bars-stop}
@cindex{Scrolling-Window-go}
- to demonstrate the scrolling window with attached vertical and horizontal
scroll bars

@code{Text-Buttons-go, Text-Buttons-stop}
@cindex{Text-Buttons-go}
- to demonstrate buttons with labels inside

@code{Trill-go, Trill-stop}
@cindex{Trill-go}
- to demonstrate the trill-device gadget

@code{V-scroll-go, V-scroll-stop}
@cindex{V-scroll-go}
- to demonstrate standard vertical scroll bars

@code{V-slider-go, V-slider-stop}
@cindex{V-slider-go}
- to demonstrate standard vertical sliders

@code{X-Buttons-go, X-Buttons-stop}
@cindex{X-Buttons-go}
- to demonstrate X buttons


@end itemize
Each of these has its own loader file, named something like
@emph{xxx}@code{-loader} for gadget @emph{xxx}. See the Gadgets manual for a
table of loader file names.



@subsection Real-Time Constraints and Performance
@node Real-Time Constraints and Performance
The program @code{demo-manyobjs} was written as a test of how fast the
system can evaluate constraints. The @code{do-go} procedure takes an
optional parameter of how many boxes to create. Each box is composed of
four Opal objects.


@section Old Demos
@node Old Demos

@subsection Moving and Growing Objects
@node Moving and Growing Objects

The best example of moving and growing objects is @code{demo-grow} (section
@ref{demogrow}).

@cindex{demo-moveline}
@cindex{move-grow-interactor}
In addition, @code{demo-moveline} shows how the @code{move-grow-interactor} can
be used to move either end of a line.

@subsection Menus
@node Menus

@cindex{demo-3d}
@code{Demo-3d} shows some menus and buttons where the item
itself moves when the user presses over it, in order to simulate a floating
button.



@section Demos of Advanced Features
@node Demos of Advanced Features

@subsection Using Multiple Windows
@node Using Multiple Windows

@cindex{demo-multiwin}
@cindex{Multiple Windows}
@cindex{windows}
@cindex{demo-multiwin}
@code{Demo-multiwin} shows how an interactor can be used to move objects
from one window to another. For more information, see the Interactors manual.

@subsection Modes
@node Modes
@cindex{Active slot}
@cindex{demo-mode}
@cindex{modes}

@code{Demo-mode} shows how you can use the @code{:active} slot of an interactor
to implement different modes. For more information, see the Interactors manual.

@subsection Using Start-Interactor
@node Using Start-Interactor

@cindex{demo-sequence}
@cindex{start-interactor}
@code{Demo-sequence} shows how to use the @code{inter:start-interactor}
function to have one interactor start another interactor without waiting
for the second one's start event. Another example of the use of
@code{inter:start-interactor} is in @code{demo-editor} (section
@ref{demoeditor}) to start editing the text label after drawing a box.
For more information on @code{start-interactor}, see the Interactors manual.


@chapter A Sample Garnet Program
@node A Sample Garnet Program


by Brad A. Myers

@value{DATE}

@section Abstract
@node Abstract

This file contains a sample program written using the Garnet Toolkit. The
program is a simple graphical editor that allows the user to create boxes
and arrows.



@section Introduction
@node Introduction
The program in this file is implemented using the Garnet Toolkit, and is
presented as an example of how to write programs using the toolkit. The
program implements a graphical editor that allows the user to create boxes
with textual labels which can be connected by lines. The lines have
arrowheads, and go from the center of one box to the center of another.
The boxes can be moved or changed size, and the arrows stay attached
correctly. The boxes or lines can also be deleted, and the labels can be
edited.

The sample program is in the file @code{demo-editor.lisp}, and a source and
binary (compiled) version should be available in the @code{demos}
sub-directory of the Garnet system files.

This graphical editor shows the use of:
@itemize
Constraints: to keep the arrows centered,
to keep the name labels at the tops of boxes, etc.

Opal objects: roundtangles, cursor-text, windows.

Interactors: to choose which drawing mode (@code{menu-interactor}), to edit
the text strings (two @code{text-interactor}s), and to create new objects
(@code{two-point-interactor}).

Toolkit widgets: @code{Text-button-panel} (a form of menu),
@code{graphics-selection} (to show
which object is selected and allow it to be moved), and @code{arrow-line}s.
These widgets have built in Opal objects and Interactors.

Aggregadgets: to group the roundtangle and label string.

Creating instances from prototypes (creating the new boxes and arrows).
@end itemize

This code is about 365 lines long, including comments, and took me two
hours to code and one hour to debug. I did not use any higher-level Garnet
tools to create it (it was all coded directly in Lisp).

@section Loading the Editor
@node Loading the Editor

After loading @code{Garnet-loader}, either of the following commands
will load the editor:

@example
(garnet-load "demos:demo-editor")        @emph{; To load the compiled version}
@end example
or
@example
(garnet-load "demos-src:demo-editor")    @emph{; To load the interpreted version, which}
                                         @emph{; may make experimenting/debugging easier}
@end example



@section User Interface
@node User Interface

A snap shot of the editor in use is shown in Figure @ref{SampleFig}.
@float Figure, fig:ex2
@center @image{toolkitpic, 5.5in}
@caption{A Sample Garnet Application. The code for this application is
listed at the end of this technical report.}
@anchor{SampleFig}
@end float

The user interface is as follows. The menu at the top determines the
current mode. When the roundtangle is outlined, the user can draw new
boxes, and when the arrow is outlined, the user can draw new arrows. 
Press with either the left or right mouse buttons over one to change modes.

To create a new roundtangle, press with the @emph{right} button in the
workspace window (on the right) and hold down. Drag to the desired size
and then release. Next, type in the new name. Various editing characters
are supported during typing, including:
@vtable @code
@code{^h, delete, backspace}: delete previous character.

@code{^d}: delete next character.

@code{^u}: delete entire string.

@code{^b, left-arrow}: go back one character.

@code{^f, right-arrow}: go forward one character.

@code{^a, home}: go to the beginning of the string.

@code{^e, end}: go to the end of the string.

@code{^y, insert}: insert the contents of the X cut buffer into the string at the
current point.
@end vtable
When finished typing, press RETURN or any mouse button to stop.

To create a new arrow, when in arrow mode, press with the @emph{right} button over
a roundtangle and release over a different roundtangle. An arrow will be
drawn starting at the center of the first roundtangle and going to the
center of the other one.

Press with the @emph{left} button on a roundtangle or an arrow to select it.
Press on the background to cause there to be no selection. Press and
release on the ``Delete'' button to delete the selected object.

If a roundtangle is selected, you can move it by pressing on a small white
square with the left button and dragging to the new position and releasing.
You can change its size by pressing with the left button on a black square.
While the dotted outline box is displayed, you can abort the operation by
moving outside the window and releasing, or by hitting ^G (control-G).

To change the string of a label, press on the label with the left button
and begin typing. When finished typing, press RETURN or any mouse button
to stop, or press ^G to abort the editing and return to the original string.

@section Overview of How the Code Works
@node Overview of How the Code Works

The next section contains the actual code for the demo editor. This
section presents some the parts of the design and serves as a guide to the
code. 

The standard ``Garnet style'' is to @code{USE-PACKAGE} the @code{KR} package,
and directly reference all the other Garnet packages, so this is how the
code is written. Functions such as @code{create-instance, s-value,
o-formula, formula, gv,} and @code{gvl} are defined in @code{KR}.

The first part of the code creates @emph{prototypes} of the basic items that
the user will create: arrow lines and labeled boxes. When the editor is
running, the code will create an @emph{instance} of one of these
prototypes to get a new set of objects to be displayed. The arrow line
object is composed of one @code{arrow-line} from the Garnet-Gadget set, with
some special @emph{constraints} on its end-points. The arrow-line is
parameterized by the two objects it is connected to. These two objects are
kept in slots of the arrow-line: @code{:from-obj} and @code{:to-obj}.
The constraints on the end-points of the arrow-line are
expressed as @emph{formulas} that cause the arrow to go from the center of the
object stored in the @code{:from-obj} slot of the arrowline, to the center of
the object in the @code{:to-obj} slot. 

The labeled box is more complicated. It is composed of two parts: a
rounded-rectangle (``roundtangle'') and a label. An @emph{AggreGadget} is
used to compose these together. The boundaries of the roundtangle are
defined by the values in the @code{:box} slot, since the standard
@code{Move-Grow-Interactor} modifies objects by setting this slot. The label
string is constrained to be centered at the top of the roundtangle. The
actual string used is stored both at the top level AggreGadget, and in the
text object, so formulas are set up to keep these two @code{:string} slots
having the same value.

The next function (@code{create-mode-menu}) creates the top menu that
contains a label object and an arrow object. A feedback rectangle is also
created to show what the current mode is. This feedback rectangle has
formulas that keep it over whatever mode object is selected.
An interactor is then created to allow the user to choose the mode.

The main command menu is created using @code{create-menu}, which simply
creates an instance of a @code{garnet-gadget:text-button-panel} in the
correct place. The functions to be executed are @code{delete-object} and
@code{do-quit}, and these are defined next. The only trick here is that if a
labeled box is deleted, the lines to it are also deleted. For quit,
destroying a window automatically destroys all of its contents. 

Creating a new object is fairly straightforward. The interactor is queried
to find out whether to create a line or a box, and the appropriate kind of
object is then created. Lines can only start or end in boxes, so the
appropriate boxes are found. To appear in a window, the newly created
objects must be added to an @emph{aggregate} which is attached to the window,
Here, the aggregate found by looking in the @code{:objs-aggregate} slot of
the interactor.

Another important feature of the @code{Create-New-Obj} procedure is that if
the object being created is a box, then it starts an interactor to allow
the user to type the text label.

The top-level, exported procedure, @code{do-go}, starts everything up by
creating a window,
a sub-window to be the work area, and top-level aggregates for both
windows. Another aggregate will hold the user-created objects. The
@code{selection} object will show which object is selected, and also allow
that object to be moved or grown (if it is not a line). Two text editing
interactors are then created. One is used when a new object is created to
have the user type in the initial name. This one is started explicitly
using @code{Start-interactor} in @code{Create-New-Object}. The other
interactor is used when the user presses on the text label of an object to
edit the name.

Finally, the interactor to create new objects is defined. This one is a
little complex, because it needs to decide whether to use a line or
rectangle feedback based on the current mode.

The last step is to add the top level aggregates to the windows and call
@code{update} to get the objects to appear. If you are running Allegro, Lucid,
Lispworks, CMUCL, or MCL Common Lisp, they will begin operating by
themselves, but under other Common Lisps, the @code{Main-Event-Loop} call
is needed to get the interactors to run. The
@code{Exit-Main-Event-Loop} function in @code{Do-Quit} causes 
@code{Main-Event-Loop} to exit.


@section The Code
@node The Code
@example
@include demo-editor.texi
@end example

@chapter Gilt Reference: A Simple Interface Builder for Garnet
@node Gilt Reference: A Simple Interface Builder for Garnet


by Brad A. Myers

@value{DATE}

@section Abstract
@node Abstract

Gilt is a simple interface layout tool that helps the user design dialog
boxes. It allows the user to place pre-defined Garnet gadgets in a window
and then save them to a file. There are two versions: one for Garnet
look-and-feel gadgets and one for Motif look-and-feel gadgets.




@section Introduction
@node Introduction

@cindex{Gilt}
This document is the reference manual for the @emph{Gilt} tool, which
is part of the Garnet User Interface Development System @cite{GarnetIEEE}.
Gilt stands for the @b{G}arnet @b{I}nterface @b{L}ayout @b{T}ool, and is
a simple interface builder for constructing dialog boxes. A dialog box is
a collection of @emph{gadgets}, such as menus, scroll bars, sliders, etc.
Gilt supplies a window containing many of the built-in Garnet gadgets (see
Figure @ref{gadgetwindow}), from
which the user can select the desired gadgets and place them in the work
window. Gilt does @emph{not} allow constraints to be placed on objects or for
new gadgets or application-specific objects to be created.

There are two sets of gadgets in Gilt. Each allows you to create dialog boxes
with a consistent look-and-feel. The standard Garnet gadgets are shown in
Figure @ref{gadgetwindow}, and the Motif style gadgets are in Figure
@ref{motifgadgetwindow}). Both versions operate the same way. You can
toggle between the standard and Motif gadget palettes by selecting
"@code{Load Other Gadgets}" from the main Gilt menubar.



@float Figure, fig:ex2
@center @image{giltgarnetgadgets, 5.5in}
@caption{The Gilt gadget window for the Garnet look and feel. All of
the gadgets that can be put into the window are shown. The check
boxes are selected.}
@anchor{GadgetWindow}
@end float

@float Figure, fig:ex2
@center @image{giltmotifgadgets, 5.5in}
@caption{The Gilt gadget window for the Motif look and feel.}
@anchor{motifgadgetwindow}
@end float

There is a more powerful interactive design tool in Garnet called Lapidary
@cite{garnetLapidary}. Lapidary allows new gadgets to be constructed
from scratch, and allows application-specific graphics to be created
without programming. However, Lapidary does not support the placement of
the existing Garnet gadgets.

@section Loading Gilt
@node Loading Gilt

Gilt is @emph{not} automatically loaded when you load Garnet. After Garnet
is loaded, to load Gilt do:
@cindex{Garnet-Gilt-Loader}
@example
(load Garnet-Gilt-Loader)
@end example

There is only one version of Gilt, but you can specify what set of gadgets
should appear in the palette when the windows appear. This is determined
by a required parameter to @code{do-go}. To start Gilt, do:

@cindex{Starting Gilt}
@cindex{Do-Go (Gilt)}
@example
(gilt:do-go :motif) 
@r(or)
(gilt:do-go :garnet)
@end example

@cindex{Stopping Gilt}
@cindex{Quitting Gilt}
@cindex{Do-Stop (Gilt)}
Gilt can be stopped by selecting "@code{Quit}" from the menubar, or by executing
@code{(gilt:do-stop)}.


@section User Interface
@node User Interface

Gilt displays three windows: The gadgets window, the main command
window, and the work window. The main command window is shown in Figure
@ref{commandwindow}. Figure @ref{workwindow} shows an example session
where the work window contains gadgets with the Garnet look-and-feel.
The two types of gadget palette windows are shown in Figures
@ref{gadgetwindow} and @ref{motifgadgetwindow}.

For the Garnet look and feel, examples
are in Figures @ref{GadgetWindow}, @ref{CommandWindow} and
@ref{WorkWindow}. Figure @ref{motifgadgetwindow} shows the Gadget
window for the Motif look and feel.

@float Figure, fig:ex2
@center @image{giltcommands, 5.5in}
@caption{The Gilt Command window. The "Edit" menu from the menubar provides
control over all properties of the gadgets in the work window and provides
dialog boxes for precise positioning. Switching between "Build" and
"Run" mode allows you to test the gadgets as you build the interface.
Text boxes display the position and dimension of the selected gadget,
whose name appears at the bottom of the command window.}
@anchor{CommandWindow}
@end float

@float Figure, fig:ex2
@center @image{giltworkwin, 5.5in}
@caption{The Gilt Work window showing a sample dialog box being
created using the Garnet look and feel.}
@anchor{WorkWindow}
@end float

@subsection Gadget Palettes
@node Gadget Palettes

The single version of Gilt allows you to place Motif or Garnet look-and-feel
gadgets into your window (you can mix and match if you want). To switch
back and forth, use the "@code{Load Other Gadgets}" command in the "@code{File}"
menu of the Gilt menubar. You can only see one gadget window at a time.
The dialog boxes for Gilt itself use only the Motif look and feel.


@subsection Placing Gadgets
@node Placing Gadgets

When you press with any mouse button on a gadget in the gadgets palette window
(see Figures @ref{GadgetWindow} or @ref{motifgadgetwindow}),
that gadget becomes selected. Then, when you press with the @emph{right}
mouse button in the work window, an instance of that gadget will be created.
Some gadgets, such as the scroll bars, have a variable size in one or more
dimensions, so for those you need to press the right button down, drag out
a region, and release the button.

The gadgets supplied for the @emph{Garnet} look and feel are (from top to
bottom, left to right in Figure @ref{GadgetWindow}):
@cindex{Gadgets in Gilt}
@itemize
Menubar: a pull-down menu,

Text-button-panel: for commands,

Scrolling-menu: when there are many items to choose from,

Option-button: a popup-menu which changes the label of the button according to
the selected item,

Popup-menu-button: a popup-menu which does not change labels,

OK-Cancel: A special gadget to be used when you want the standard OK and
Cancel behavior (see section @ref{okcancel}),

X-button-panel: for settings where more than one is allowed,

Radio-button-panel: for settings where only one is allowed,

Menu: a menu with an optional title,

H-scroll-bar: for scrolling horizontally,

H-slider: for entering a number in a range,

V-scroll-bar: for scrolling vertically,

V-slider: for entering a number in a range,

OK-Apply-Cancel: Similar to OK-Cancel, but supports Apply (like OK,
but don't remove window),

Gauge: another way to enter a number in a range,

Trill-device: enter a number either in a range or not,

Labeled-box: enter any string; box grows if string is bigger,

Scrolling-labeled-box: enter a string; box has a fixed size and string
scrolls if too big,

Text: for decoration,

Multifont-text: for decoration,

Rectangle: for decoration,

Line: for decoration,

Bitmap: for decoration,

Pixmap: for decoration.
@end itemize


The gadgets supplied for the @emph{Motif} look and feel are (from top to
bottom, left to right in Figure @ref{motifgadgetwindow}):

@itemize
Motif-Menubar: a pull-down menu

Motif-Text-button-panel: for commands,

Motif-Menu: a menu with an optional title,

Motif-Scrolling-Menu: when there are many items to select from,

Motif-Check-button-panel: for settings where more than one is allowed,

Motif-Radio-button-panel: for settings where only one is allowed,

Motif-OK-Cancel: A special gadget to be used when you want the standard OK and
Cancel behavior (see section @ref{okcancel}),

Motif-OK-Apply-Cancel: similar to OK-Cancel, but supports Apply,

Motif-Option-Buton: a popup-menu whose button's label changes according to the
selection

Motif-V-scroll-bar: for scrolling vertically,

Motif-V-slider: for entering a number in a range,

Motif-H-scroll-bar: for scrolling horizontally,

Motif-trill-device: for selecting from a range of numbers,

Motif-Gauge: another way to enter a number in a range,

Motif-Scrolling-labeled-box: enter a string; box has a fixed size and string
scrolls if too big,

Pixmap: for decoration

Bitmap: for decoration

Rectangle: for decoration,

Line: for decoration,

Motif-Box: A gadget that resembles a raised (or depressed) rectangle, used to
achieve a Motif style effect. Set the @code{:depressed-p} parameter.

Text: for decoration,

Multifont-text: for decoration,

Motif-Background: a special rectangle that helps achieve the Motif effect.
It always moves to the back of the window, and can only be selected at the
edges.
@end itemize

In addition to the standard gadgets, Gilt supplies a text string, a
line, a rectangle and a bitmap. These are intended to be used as
decorations and
global labels in your dialog boxes. They have no interactive behavior.

The Motif version also provides a background rectangle. This is a
special rectangle which you should put behind your objects to make the
window be the correct color. Note: to select the motif-background
rectangle, press at the edge of the window (the edge of the background
rectangle). You might want to select the rectangle to delete it or
change its color (using the properties menu).


@subsection Selecting and Editing Gadgets
@node Selecting and Editing Gadgets

When you press with the left mouse button on a gadget in the work window,
it will become selected, and will show four or twelve selection handles.
The objects
that can change size (such as rectangles and scroll bars) display
black and white selection handles, and the objects that cannot change
size (such as buttons) only show white selection handles.@footnote{You can
indirectly change the size of buttons by setting offsets and sizes in the
property sheet, however.}
If you press on a
@emph{white} handle and drag, you can change the object's position. If you
press on a @emph{black} handle, you can change it's size (see Figure
@ref{handlesfig}). 

@float Figure, fig:ex2
@center @image{gilthandles, 5.5in}
@caption{Pressing on a black selection handle causes the object to
grow, and pressing on a white one causes it to move.}
@anchor{Handlesfig}
@end float


If you press over an object with either the @emph{middle} mouse button or
hold down the keyboard shift key while hitting the left button, then
that object is added to the selection set (so
you can get multiple items selected). If you press with middle or
shift-left over an item that is @emph{already} selected, then just that item
becomes de-selected. If you press with the left button in the
background (over no objects), all objects are deselected. While
multiple objects are selected, you can move them all as a group by
pressing on the selection handle of any of them.
Since Gilt uses the multi-selection gadget, it supports selecting
all objects in a region (hold down the left button and sweep out a
region), and growing multiple selected objects (if they are growable,
then press on a black handle at the outside of the set of objects).

To explicitly set the size or position of the selected object (when
only one is selected), you can use
the number fields in the Command Window (see Figure @ref{CommandWindow}).
Simply press with the left button in one of these fields and type a new
number. When you hit @code{return}, the object will be updated. These fields
are a handy way to get objects to be evenly lined up (but also see the
"@code{Align}" command).


@section Editing Strings
@node Editing Strings

Editing the strings of most gadgets is straightforward: select the
gadget (to get the selection handles around it) and then click in a
string to get the string cursor, and then type the new string, and hit
@code{return} when done. If you make the string empty (e.g., by typing
@code{control-u}),
and hit @code{return}, that button of the gadget will be removed. If you
edit the last item of the gadget and hit @code{control-n} instead of @code{return},
then a new item will be added to the gadget. The strings can also be
edited by editing the @code{:items} property in the property sheet that
appears from the @code{Properties} command.

To edit string labels, simply click to select them, and then click
again with the left button to begin editing. The fonts of
multifont strings can be edited using the keyboard commands described
in the "Multifont" section of the Opal Manual.

To edit the strings in a pop-up menu, like a menubar or an option
button, click once with the left button to select the gadget, and then
click again to pop-up the submenu. You can now click in the submenu
to edit any of the items. Use control-n in the last item to add new
items or control-u and return to remove items. To edit the top-level
labels of a menubar, you need to click the left button three times:
once to select the gadget, once to bring up the submenu, and a third
time to begin editing. Click outside to make the popped-up menu
disappear. 

The editing operations supported for regular text (and labels) are:
@anchor{editingcommands}
@vtable @code
@code{^h, delete, backspace}: delete previous character.

@code{^w, ^backspace, ^delete}: delete previous word.

@code{^d}: delete next character.

@code{^u}: delete entire string.

@code{^b, left-arrow}: go back one character.

@code{^f, right-arrow}: go forward one character.

@code{^a}: go to beginning of the current line.

@code{^e}: go to end of the current line.

@code{^y}: insert the contents of the X cut buffer into the string at the
current point.

@code{^c}: copy the current string to the X cut buffer.

@code{enter, return, ^j, ^J}: Finished.

@code{^n}: Finished, but add a new item (if a list).

@code{line-feed}: Start a new line (if editing a multi-line text).

@code{^g}: Abort the edits and return the string to the way it was before
editing started.
@end vtable

If the item is a member of a list, such as a menu item or a radio button,
then if the string is empty, that item will be removed. If the string is
terminated by a @code{^n} (control-n) instead of by a return, and if this is the
last item, then a new item will be added. The items can also be changed in
the properties dialog box for the gadget (see below). 

Some strings cannot be edited directly, however. This includes the
labels of sliders and gauges, and the indicators in scroll bars. To
change these values, you have to use the property sheets. Also,
for gadgets that have strings as their @emph{values}, such as the text input
field and scrolling-text input field, you can only set the value
strings by going into Run mode. Note, however, that the values are
not saved with the gadget (see section @ref{usinggiltdbs}).

To change the bitmap picture of a bitmap object, specify the name of
the new bitmap using the "@code{Properties...}" command.


@section Commands
@node Commands

There are many commands in Gilt, and the command menu is a menubar
at the top of the main window. The menubar implementation allows you to
give commands using keyboard shortcuts when the mouse is in the main
Work Window.
The particular shortcuts are listed on the sub-menus of the main
menubar.

The commands are:
@vtable @code
@code{Cut} --- remove the selected item(s) but save them in the clipboard
so they can later be pasted.

@code{Copy} --- copy the selected item(s) to the clipboard so they can
later be pasted. 

@code{Paste} --- place a copy of the items in the clipboard onto the window.

@code{Duplicate} --- place a duplicate of the selected items onto the window. 
(See section @ref{duplicating-objects}.)

@code{Delete} --- delete the selected objects and don't put them into
clipboard. This operation can be undone with the @code{Undo Last Delete}
command. (See section @ref{deleting-objects}.)

@code{Delete All} --- delete all the objects in the window. This
operation can be undone with the @code{Undo Last Delete} command.
(See section @ref{deleting-objects}.)

@code{Undo Last Delete} --- undoes the last delete. All the deletes are
saved, so this command can be executed multiple times to bring back
objects deleted earlier. (See section @ref{deleting-objects}.)

@code{Select All} --- select all the objects in the window (including the
background object).

@code{To Top} --- make the selected objects not be covered by any other objects.
(See section @ref{to-top}.)

@code{To Bottom} --- make the selected objects be covered by all other objects.
(See section @ref{to-top}.)

@code{Properties...} --- bring up the properties window. (See section
@ref{giltpropertiessec}).

@code{Align} --- bring up the dialog box to allow aligning of the selected
objects with respect to the first of the objects selected.
(See section @ref{align}.)
@end vtable

Many of these commands are now implemented with the functions in the
@code{Standard-Edit} mechanism, described in the Gadgets Manual.


@subsection To-Top and To-Bottom
@node To-Top and To-Bottom
@anchor{to-top}

@cindex{To Top (in Gilt)}
@cindex{To Bottom (in Gilt)}
The selected object or objects can be made so they are not covered by
any objects using
the "@code{To Top}" command in the Gilt Command Window. The objects can be
made to be covered by all other objects by selecting the "@code{To
Bottom}" command.


@subsection Copying Objects
@node Copying Objects
@anchor{duplicating-objects}
@cindex{Duplicate (in Gilt)}

The "@code{Duplicate}" command in the Command Window causes the selected
object or objects to
be duplicated. The new object or objects will have all the same
properties as the
original, but the original and new objects can be subsequently edited
independently without affecting the other object
(the new object is a copy, not an @emph{instance} of
the original). The copy is placed at a fixed offset below and to the right
of the original, and is selected, so it can subsequently be moved.


@subsection Aligning Objects
@node Aligning Objects
@anchor{align}

@cindex{Align... (in Gilt)}

The Align function allows you to neatly line up a set of objects, and
to adjust their sizes to be the same. Figure @ref{alignfig} shows the
dialog box that appears when the "@code{Align...}" command is selected. Align
adjusts the present positions of objects only; it does not set up
constraints. Therefore, you can freely move objects after aligning them.

@float Figure, fig:ex2
@center @image{alignfig, 5.5in}
@caption{The Align dialog box, after the user has specified that
the selected objects should be aligned and centered in a column and be
adjusted to be the same width.}
@anchor{alignfig}
@end float

To use Align, you first select two or more objects in the workspace
window (remember, to select more than one object, press on the objects
with the middle mouse button or hold down the shift key while hitting
the left button). The @emph{first} object you select is the reference
object, and the other objects will be adjusted with respect to that
first object. For example, if you want to make objects be the same width,
then the width will be that of the first selected object. You should
not change the selection while the Align dialog box is visible.

Aligning in a column or row also adjusts the spacing between objects
to be all the same. The spacing used between the objects is the average
space between the objects before the command is given.

If a line is selected, then it is made to be exactly horizontal if
"Column" is specified, or vertical if "Row" is selected. The size of
lines can also be adjusted using the width and height buttons. If both
"Same Width" and "Same Height" are selected for a line, then an error
message is given. 

If the "Same Width" and/or "Same Height" buttons are pressed, and one
of the selected objects other than the first cannot change size, then
an error message is presented. All other selected objects are still
adjusted, however.


@subsection Deleting Objects
@node Deleting Objects
@anchor{deleting-objects}

@cindex{Delete Selected (in Gilt)}
@cindex{Delete All (in Gilt)}
@cindex{Undo Last Delete (in Gilt)}
Choosing the "@code{Delete Selected}" command in the Gilt Command Window will
remove the selected object or objects from the work window. Selecting
the "@code{Undo Last Delete}"
command will bring the object back. Selecting "@code{Delete All}" removes all
the objects from the work window. "@code{Undo Last Delete}" will bring all of
the objects back. All of the deleted objects are kept in a queue, so the undo
command can be executed repeatedly. Note that this is not a general Undo;
only undoing of deletes is supported.


@subsection Properties
@node Properties
@anchor{giltpropertiessec}
@cindex{Properties... (in Gilt)}

Each type of gadget has a number of properties. 
First select the object in the workspace window, and then select the
"@code{Properties...}" command (in the Gilt Command Window).
The window for the properties will appear below the selected object, but then
can be moved. You should not change the selection while the
properties dialog box is visible.

If the selected object is a rectangle,
line or string, then special dialog boxes are available so you can
change the color, filling-style, font, etc. These were created using Gilt.

The general property sheet lists all of the
properties that you can change, and will look something like Figure
@ref{propsheet}. You can press in the value (right) side of any entry
and then type a new value (using the same editing commands as in
section @ref{editingcommands}). You can move from field to field
using the tab key (after pressing with the left mouse button in a
field to start with). When finished setting values, hit the "OK"
button to cause the values to be used and the property sheet to
disappear, or hit the "Apply" button to see the results and leave the
property sheet visible. If you hit "Cancel", the changes will not
affect the object, and the property sheet will go away.

You can select multiple items and bring
up a property sheet on all of them. The property sheet will show the
union of all properties of all objects. If multiple objects have the
same property name, then the value of the property for the first
object selected is shown. 

When you edit the value of a property and then hit return (or when you
hit OK for properties that pop up dialog boxes), the property sheet
will immediately set that property into all objects for which the
property is defined. Thus, you can change the @code{:foreground-color}
of all the objects by executing @code{Select All}, bringing up the
@code{Properties...}, and then editing the foreground-color property.
If you start to edit a property but change your mind, hit
@code{Control-G} if text editing or @code{Cancel} in a dialog box. The
@code{Done} button hides the property sheet.

The left, top, width and height number boxes displayed in the main
Gilt window will now also work on multiple objects. When multiple
objects are selected, they show the values for the bounding box of all
the objects, and when you edit one and hit RETURN, that value is
applied to all objects for which it is settable.

For a complete explanation of what the fields of each
gadget do, see the Gadgets Manual.

@float Figure, fig:ex2
@center @image{giltpropsheet, 5.5in}
@caption{The property sheet that appears for a particular X-Button-Panel.}
@anchor{propsheet}
@end float

Some of the fields of these property sheets are edited in a special way. The
@code{DIRECTION} field must be either @code{:VERTICAL} or @code{:HORIZONTAL}, so
the field shows these names, and you can press with the left button to pick
the desired value. Fields that represent fonts show a special icon,
and if you click on it, the special font dialog box will appear.
However, the font is not changed in the object until the "OK" or
"Apply" buttons are hit on @emph{both} the font dialog box and the main
property sheet.

@cindex{Known-as (in Gilt)}
The field named @code{KNOWN-AS} should be set for
all gadgets that programs will want to know the values of, and will be the
name of the slot that holds the object (so it should be a keyword, e.g.,
@code{:myvalue}). The @code{SELECT-FUNCTION} slot can contain a function to be
called at run time when the gadget is used. Note that you might want to
specify the package name on the front of the function name. However, if
you are going to have OK-Cancel or OK-Apply-Cancel in the dialog box, you
probably do not want to supply selection functions, since selection
functions are called when the gadget is used, not when OK is hit (see
section @ref{using}).

If the property sheet thinks any value is @emph{illegal}, the value will
be displayed in italics after a return or tab is hit, and Gilt will
beep. You can edit the value, or just leave it if the value will
become defined later (e.g., if the package is not yet defined).

Unfortunately, however, the error checking of the values typed into
the property sheets is not perfect, so be careful to check all the values
before hitting OK or Apply. If a bad value is set into the gadget,
Gilt will crash. You can usually recover from this by setting the
field back to a legal value in the Lisp window. For example, if
@code{:gray-width} got a bad value, you might type:
@example
(kr:s-value user::*gilt-obj* :gray-width 3)
(opal:update-all)
(inter:main-event-loop)
@end example
@cindex{*gilt-obj*}
@cindex{gilt-obj}

@subsection Saving to a file
@node Saving to a file

@cindex{Save... (in Gilt)}
When the "@code{Save...}" command is selected from the Command window, Gilt
pops up the dialog box shown in Figure @ref{Savedialogbox}.

@float Figure, fig:ex2
@center @image{savedialog, 5.5in}
@caption{The dialog box that appears when the Save command is chosen.}
@anchor{Savedialogbox}
@end float

The only field you need to fill in is the "@code{Filename}" field, which tells
the name of the file that should be written. Simply press with the
left button in the field and begin typing. This is a
scrollable field, so if the name gets too long, the text will scroll
left and right. You might also want to use the window manager's cut
buffer (^Y) if you
can select the string for the file in a different window. Pressing
with the mouse button again will move the cursor, so you need to hit
@code{return} or @code{^G} to stop editing the text field.

All the objects in the work window will be collected together in a
single Garnet ``aggregadget'' when written to the file. The
"@code{Top-level Gadget name}" field allows you to give this gadget a
name. This is usually important if you want to use the gadget in some
interface, so you can have a name for it. If you press the "@code{Export
Top-level Gadget}" button, then an export line will be added to the
output file.

As described below in section @ref{Using}, there is a simple function for
displaying the created gadget in a window. If you want this window to
have a special title, you can fill this into the "@code{Window Title}" field.
The current position and size of the workspace window is
used to determine the default size and position of the dialog box
window when it is popped up, so you should change the workspace
window's size and position (using the standard window manager
mechanisms) before hitting OK in the Save dialog box. 

If you want the gadget to be defined in a Lisp package other than @code{USER},
then you can fill this into the "@code{Package name}" field.

Finally, if you have included the special OK-Cancel gadget in your
workspace window, then the "@code{Function-for-OK name}" field will be
available. Type here the name of the function you want to have called
when the OK button is hit. The parameters to this function are
described in section @ref{Using}.

After filling in all the fields, hit "OK" to actually save the file, or
"Cancel" to abort and not do the save.

If you have already read or saved a file, then the values in the Save
dialog box will be based on the previous values. Otherwise, the
system defaults will be shown.

@b{Note: There is no protection or confirmation required before
overwriting an existing file.}


@subsection Reading from a file
@node Reading from a file

@cindex{Read... (in Gilt)}
You can read files back into Gilt using the "@code{Read...}" command.
This displays the dialog box shown in Figure @ref{readdialogbox}.
Press with the left mouse button in the "@code{Filename}" field and type
the name of the file to be read, then hit return.

@float Figure, fig:ex2
@center @image{readdialog, 5.5in}
@caption{The dialog box that appears when the Read command is hit.}
@anchor{readdialogbox}
@end float

If there are objects already in the workspace window, then you have
the option of adding the objects in the file to the ones already in
the work window using the "@code{Add to existing objects}" option, or else
you can have the contents of the workspace window deleted first using
the "@code{Replace existing objects}" option. If you use the "@code{Replace}"
option, then the window size is adjusted to the size specified when
the file was written. Also, reading a file using the replace option puts the
previous contents of the workspace window in the delete stack so
that they can be retrieved using the "@code{Undo Last Delete}" command.

Output produced from the GarnetDraw utility program can be read into Gilt,
which would allow more elaborate decorations to be added to a dialog box.
But in general, only files written with Gilt can be read with Gilt.


@subsection Value and Enable Control
@node Value and Enable Control

A sophisticated module for modifying the values of gadgets in the Gilt
work-window has been added, along with a corresponding module to modify
when a gadget should be active (or grayed-out). These are called
the @code{Value Control} and @code{Enable Control} modules, and can be invoked
from the "Control" submenu in the Gilt menubar.

These modules implement the ideas discussed in @cite[GiltDemo].
The paper includes examples of how to use this feature, but
a full set of documentation is still pending. If there is sufficient demand
for documentation of this module, we will supply an addendum to this manual
(direct requests to @code{garnet@@cs.cmu.edu}).


@section Run Mode
@node Run Mode

@cindex{Run (in Gilt)}
@cindex{Build (in Gilt)}

To try out the interface, just click on the button in the command
window labeled "Run". This will grey out most of the commands, and
allow the gadgets in the work window to execute as they will for the
end user (except that application functions will not be called). To
leave run mode, simply press on the "Build" button.


@section Hacking Objects
@node Hacking Objects

@cindex{*gilt-obj*}
@cindex{gilt-obj}
Gilt does not provide all options for all objects and gadgets. If you
want to change other properties of objects that are not available from
the property sheets, you could hit the HELP key while the mouse is positioned
over the object to bring up the Inspector (see the Debugging manual, starting
on page @value{debug} for details).

You can also access the selected object directly from
Lisp. If one object is selected, its name is printed in the command
window. Also the variable @code{user::*gilt-obj*} is set with the single
selected object. If multiple objects are selected, then
@code{user::*gilt-obj*} is set with the list of objects selected.
You can go into the Lisp listener window, and type
Garnet commands to affect the selected object (e.g., @code{s-value} some
slots), and call @code{(opal:update-all)}. This
technique can also be used to add extra slots to objects. The
changes you make will be saved with the object when it is written.



@section Using Gilt-Created Dialog Boxes
@node Using Gilt-Created Dialog Boxes
@anchor{usinggiltdbs}

There are various ways to use Gilt-created collections of gadgets in
an application.

The file that Gilt creates is a normal Lisp text file that creates the
appropriate Garnet objects when loaded. The file should be compiled
along with your other application files, in order to provide better
performance.


@subsection Pop-up dialog box
@node Pop-up dialog box
@anchor{popupdialogbox}
@anchor{okcancel}

@cindex{OK-Cancel gadget (in Gilt)}
@cindex{OK-Apply-Cancel gadget (in Gilt)}
@cindex{Pop-Up Dialog Boxes (from Gilt)}

Probably the easiest way to use a set of gadgets is as a pop-up dialog
box. The application should be sure to @emph{load} the file that Gilt
created before calling the functions below.

When Gilt writes out the gadgets, it does @emph{not} save the values as
the initial defaults. Therefore, if you want to have default values
for any gadgets, you need to set them from your program. This should
be done @emph{before} the window is
displayed using the function:
@cindex{Set-Initial-Value (in Gilt)}
@example
gilt:Set-Initial-Value @emph{top-gadget gadget-name value}@ref{function}
@end example
The @code{top-gadget} is the top-level gadget name specified in the
"@code{Top-level Gadget name}" field of the Save dialog box. The
@code{gadget-name} is the name of the particular gadget to be
initialized. This name will be a keyword, and will have been
specified as the @code{KNOWN-AS} property of the gadget using the
gadget's property sheet (which appears when you hit the
"@code{Properties...}" command). The @code{value} is the value to be used as
the default, in the appropriate format for that gadget.

Next, the Gilt function @code{show-in-window} can be used to display the
dialog box in a window: 
@cindex{Show-In-Window (in Gilt)}
@example
gilt:Show-In-Window @emph{top-gadget} &optional @emph{x y modal-p}@ref{function}
@end example
The @emph{top-gadget} is the gadget name used in the Save dialog box.
The size of the window is determined by the size of the workspace
window when the file was written. The position of the window will
either be the position when written, or it can be specified as the
@emph{x} and @emph{y} parameters, which are relative to the screen's
upper-left corner. When the @emph{modal-p} parameter is T, then interaction in
all other Garnet windows will be suspended until the window goes away (e.g.,
when the user clicks the "OK" button). If you want the window relative to a
position in another window, the function @code{opal:convert-coordinates} is
useful.

The function @code{show-in-window-and-wait} performs the same function
as @code{show-in-window}, but it waits for the user to click on an OK or
Cancel button before returning (@code{show-in-window} returns
immediately after bringing up the window).
@cindex{Show-In-Window-And-Wait (in Gilt)}
@example
gilt:Show-In-Window-And-Wait @emph{top-gadget} &optional @emph{x y modal-p}@ref{function}
@end example
When the user clicks on the OK button, this function will return the
values of all the gadgets in the dialog box in the form of
@code{gilt:gadgets-values}, which is:
@example
((:FILENAME "/usr/bam/garnet/t1.lisp") (:VAL 49) (:BUTTON "Start"))
@end example
where the keywords are the names (@code{:known-as} slot) of the gadgets.
If the user hits Cancel, then @code{show-in-window-and-wait}
returns NIL. Apply does not cause the dialog box to go away, so you
might want to supply an OK-Function for the dialog box.

If selection functions were specified in the gadget's select-function
slot using the "@code{Properties...}" command, then these functions are
called immediately when the gadgets are used.

If the dialog box has an OK-Cancel or OK-Apply-Cancel gadget in it,
then the function
specified in the "@code{Function-For-OK name}" field of the Save dialog
box will be called when the user hits the OK or Apply buttons. This function
is parameterized as:
@cindex{Function-For-OK (in Gilt)}
@example
(lambda (top-gadget values)
@end example
The @code{top-gadget} is the same as above. The @code{values} parameter
will be a list containing pairs of all the gadget names of gadgets
which have names, and
the value of that gadget. Again, the names are the keywords supplied
to the @code{KNOWN-AS} property. For example, @code{values} might
contain:
@example
((:FILENAME "/usr/bam/garnet/test1") (:REINITIALIZE NIL))
@end example

The function
@cindex{Value-Of (in Gilt)}
@example
gilt:Value-Of @emph{gadget-name values}@ref{function}
@end example
can be used to return the value of the specific gadget named
@code{gadget-name} from the values list @code{values}. For example, if
@code{v} is the above list, then @code{(gilt:value-of :filename v)} would
return @code{"/usr/bam/garnet/test1"}. 

After the Function-For-OK is called, the dialog box window is made
invisible if OK was hit, and left in place if Apply was hit. If
Cancel was hit, then the window is simply
made invisible. If @code{show-in-window} is called again on the same
dialog box, the old window is reused, saving time and space.

To destroy the window associated with a gadget, use the function:
@cindex{Destroy-Gadget-Window (in Gilt)}
@example
gilt:Destroy-Gadget-Window @emph{top-gadget}@ref{function}
@end example
This does @emph{not} destroy the @code{top-gadget} itself. Note that
destroying the top-gadget while the window is displayed will not
destroy the window. However, destroying the window explicitly (using
@code{opal:destroy}) @emph{will} destroy both the window and the gadget.

@section Using Gilt-Created Objects in Windows
@node Using Gilt-Created Objects in Windows
@anchor{using}

If you want to use the gilt-created gadgets inside of an application
window, you only need to create an instance of the top-gadget, which
is the top-level gadget name specified in the
"@code{Top-level Gadget name}" field of the Save dialog box. The
instance will have the same position in the application window as it had
in the Gilt workspace window. If you use the
standard Gilt OK-Cancel gadget, it will make the application 
window be invisible when the OK or Cancel buttons are hit. If you do
not want this behavior, then you need to create your own OK-Cancel
buttons.

The @code{set-initial-value} described above can still be used for gilt
gadgets in application windows. In addition, the function
@cindex{Gadget-Values (in Gilt)}
@example
gilt:Gadget-Values @emph{top-gadget}@ref{function}
@end example
can be used to return the values list of all gadgets with names. The
return value is in the form of the @code{values} parameter passed to the
Ok-Function. 



@section Hacking Gilt-Created Files
@node Hacking Gilt-Created Files

Since the file that Gilt creates is a normal text file, it is possible
to edit it with a normal text editor. Some care must be taken when
doing this, however, if you want Gilt to be able to read the file back
in for further editing. (If you do not care about reading the files
back in, then you can edit the file however you like.)

The simplest changes are to edit the values of slots of the objects.
These edits will be preserved when the file is read in and written
back out. Be sure not to change the value of the @code{:gilt-ref} slot.

When Gilt saves objects to a file, it sets the @code{:constant} slot of
all the gadgets to T. If you expect to ever change any properties of
widgets in the dialog boxes when they are being used by an
application, then you should hand-edit the Gilt-generated file to
change the constant value (typically by @code{:except}ing the slots you
plan to change dynamically). (Gilt reads in the file using
@code{with-constants-disabled}, so the defined constant slots will not
bother Gilt.)

If you want to create new objects, then these can be put into the top
level aggregadget definition. 
You should follow the convention of having a @code{:box} (or
@code{:points}) slot and
putting the standard constraints into the @code{:left} and @code{:top}
fields (or @code{:x1, :y1, :x2} and @code{:y2}). For example, to add a
circle, the following code might be
added into the top-level aggregadget's @code{:parts} list:
@example
    (:mycircle ,opal:circle
      (:box (50 67 30 30))
      (:left ,(o-formula (first (kr:gvl :box))))
      (:top ,(o-formula (second (kr:gvl :box))))
      (:width 30)
      (:height 30))
@end example
@cindex{gilt-ref slot (in Gilt)}
If you do not supply a @code{:gilt-ref} field, Gilt will allow
the user to move the object around, but not
change its size or any other properties. For some objects, it might
work to specify the @code{:gilt-ref} slot as @code{"TYPE-RECTANGLE"},
@code{"TYPE-LINE"} or @code{"TYPE-TEXT"}.

If you add extra functions or comments to the file, they will @emph{not}
be preserved if the file is written out and read in. Similarly,
interactors added to the top level gadget will not be preserved. 

@ref{References}

@chapter C32 Reference: A Constraint Editor
@node C32 Reference: A Constraint Editor


by Dario Giuse

@value{DATE}

@section Abstract
@node Abstract

C32 is an object and constraint editor for Garnet objects. It allows
Garnet objects to be viewed and edited using a spreadsheet-like interface.
New values can be installed in the slots of an object directly, or constraints
can be defined among the objects.




@section Overview of C32
@node Overview of C32

@anchor{c32}

@cindex{Spreadsheet in C32}
C32 @cite[C32] is an object and constraint editor for Garnet objects. It
allows Garnet objects to be viewed and edited using a spreadsheet-like
interface. Each object is viewed in a panel, where each row corresponds
to a slot in the object. The value of a slot can be changed directly, by
editing the value shown in the corresponding row. Constraints can be
edited textually in separate formula-editing windows.

C32 can be used as a stand-alone tool to create and edit Garnet objects.
It is possible, for example, to edit an existing object by typing its name
in the title of a C32 panel, or by pointing and clicking on an object with
the mouse. In addition, C32 is integrated with Lapidary, which uses it
for several editing tasks that used to be handled specially.

Because it uses the spreadsheet paradigm, C32 is highly structured. Each
object is represented as a panel, and all panels are organized
horizontally in one long window. A horizontal scroll bar allows different
panels to be displayed in the window. Panels that contain more than 12
slots are displayed with a vertical scroll bar, so more slots can be made
visible as desired.

C32 keeps the display of each panel up to date. When a slot is modified
using C32, the values displayed for other dependent slots are modified
accordingly. Even if objects are changed from outside C32 (using the Lisp
listener or the mouse, for example), their corresponding panels are always
kept up to date.



@section Loading C32
@node Loading C32

To load C32, you load the file "garnet-c32-loader" and then type
@example
(c32:do-go)
@end example
Note that if you are using Lapidary, you do not need to load C32 explicitly;
Lapidary does it automatically.

The function @code{(c32:do-go)} creates two windows: the C32 Commands
window, which contains the main commands used to control C32, and the
spreadsheet window. Initially, the spreadsheet window contains a single,
empty panel whose title reads "Object name:". The title of this panel can
be edited to the name of an object, which is then displayed in the panel.

The full syntax for @code{do-go} is as follows:

@defun c32:do-go &key (startup-objects nil) (test-p nil) (start-event-loop-p t)

If <startup-objects> is specified, it should be a list of Garnet objects.
When C32 is started, it creates a panel for each object in the list, plus
the empty panel. If <test-p> is specified, a little test window is
created with a few objects in it. C32 can then be used to edit the
objects in the window. Setting <start-event-loop-p> to NIL cause C32 to
start up with the main-event loop not running.
@end defun



@section The Spreadsheet Window
@node The Spreadsheet Window

@cindex{C32 panels}
The spreadsheet window contains a list of panels, each displaying a Garnet
object. Figure @ref{c32-spreadsheet} shows the spreadsheet window with a
panel for a @code{label-text} object and the empty panel. Each panel
consists of a vertical scroller (using for displaying more slots), a
title, and up to 12 rows. Each row displays the contents of a slot.

@float Figure, fig:ex2
@center @image{c32-spreadsheet, 5.5in}
@caption{C32 Spreadsheet Window with two panels.}
@anchor{c32-spreadsheet}
@end float

The title of each panel shows the name of the object displayed in the
panel. The title can be edited by clicking the left mouse button over it,
and then using the normal Garnet text editing commands. Type Return to go
ahead, and ^G if you do not want to make the change. Entering the name of
a different object in a panel's title causes the panel to display the new
object. If the object does not exist, C32 will ask you if you wish to
actually create a new object. Setting the title of a panel to be empty
causes the panel to be removed from the spreadsheet window; the object
being displayed is unaffected, however. Setting the title of the empty
panel to an object's name causes a new panel to be created for the object.
@cindex{creating objects}

The left half of each row displays the name of the slot. The names of
local slots are shown in a roman face; the names of inherited slots are
shown in italics. Slots that contain a formula are indicated by an "F" on
a dark circle. If the formula was inherited, this is indicated by an
"I" inside a circle, next to the formula symbol. The right half of each
row displays the value of the slot. If the value is inherited, an "I"
inside a circle is shown at the far right of the row.

At any time, you can have a primary selection and a secondary selection.
The primary selection is shown by a dark background, and is used for the
majority of C32 operations that require a slot or an object. You may
change the primary selection by clicking the left mouse button over a slot
name, i.e., in the left side of a row. The secondary selection is shown
by a gray outline around a slot, and is used for operations that require
two slots. You may change the secondary selection by clicking the middle
mouse button over a slot name. Both primary and secondary selections are
toggles, and can be eliminated by clicking over them.

Panels allow you to modify objects, as well as displaying them. The value
of a slot can be edited by editing its text: first click on the value (in
the right half of the row) to get a text cursor, and then use the normal
Garnet text editing commands. When you type Return, the slot is set to
the new value and the object is modified (type ^G if you do not want to
make the change). Note that the package shown in the Commands Window is
used when reading the value you type in. Setting the package
appropriately ensures that you do not have to type package qualifiers for
every function and symbol.

The last row of a panel is always empty. Clicking in its left-hand half
allows you to add a slot to the object, or to display a slot that is
currently not shown. When you click, you start editing an (initially
empty) slot name. If the slot is currently not shown, its current value
is displayed. If the slot is not present, it is created. Its initial
value is inherited, if possible; otherwise, it is set to NIL. You may
then edit the value (in the right-hand side). As a special shortcut, it
is also possible to enter a slot name and a value together; just type the
slot name, a space, and then the value.

The formula associated with a slot can also be edited using the
spreadsheet window. Click on the "F" symbol; this pops up a window that
allows the formula to be edited, as explained below. This mechanism also
let you create formulas for slots that do not yet contain one: simply
click on the place where the "F" symbol would be, and a new formula window
will appear. You may then type the text for the new formula. Note that
editing the value of a slot that contains a formula is equivalent to doing
an @code{s-value} on the slot with the new value: the old value is
temporarily replaced, but the formula is unaffected.


@section Editing Formulas
@node Editing Formulas

@cindex{editing formulas in C32}
Formulas can be edited in special editing windows. When you click on the
"F" symbol of a slot in the spreadsheet window, a window is created in
which you can edit the textual representation of the formula. If you
click on the "F" symbol and a window already displays that formula, the
window is simply moved to the front. If you click on the "F" symbol of a
slot that contains a value, the value is shown as the initial text for the
(yet to be created) formula.

Figure @ref{c32-formula} shows the C32 formula window for the
@code{:left} slot of the object shown in Figure @ref{c32-spreadsheet}.
A formula window contains a header, a vertical scroller, and a text
window. The header displays the name of the object and the slot upon
which the formula is installed, and contains five buttons. The
scroller allows you to examine different portions of long formulas.

@float Figure, fig:ex2
@center @image{c32-formula, 5.5in}
@caption{The C32 formula window for the :left slot.}
@anchor{c32-formula}
@end float



When the formula window is created, the text cursor is initially
positioned at the top left of the text. The cursor can be moved, and the
text can be edited, using the normal Garnet text editing operations. Note
that typing the abort character (^G) in a formula window has no effect;
click the Cancel button if you really want to abort the current changes to
the formula's text.

The five buttons in the header include the OK and Cancel button, plus
three buttons that can be used to reduce typing when the formula is being
edited. The "OK" button installs the expression currently displayed in the
formula window into the slot of the object, and hides the formula window.
If errors are detected (for example, because the syntax in the formula
expression is illegal), you will see an error message and the formula
window will remain on the screen. The "Cancel" button removes the window
without modifying the formula that is currently installed on the slot.

The "Insert Function" button pops up a menu with the names of functions
that are commonly used in formulas. In addition to @code{floor}, @code{max},
and the like, the menu includes the functions from the @code{opal:gv-}
family. Select a function from the menu by clicking the left mouse button
over it; this will show the function's name in reverse video. Clicking on
the "Insert Function" button will now insert the selected function,
enclosed in parentheses, at the cursor position in the formula window.

The "Insert From Spread" button inserts a reference to the object and slot
that are currently selected in the spreadsheet window into the formula
being edited. C32 detects whether the selected object is the same as the
one that contains the formula, and if so, it generates a simple reference
using @code{gvl}.

The "Insert From Mouse" button is similar, except that it allows you to
select the target object using the control-left mouse button. The button
pops up a dialog box through which you may select an object. C32 will
attempt to guess a slot; for example, if you click @code{control-left} on
the left part of a string, it will insert the @code{:left} slot. If C32
cannot guess any slot, it leaves the slot name blank. When the
appropriate object (and possibly slot) is shown in the dialog box,
clicking the "Apply" button will insert a reference into the formula
window. Clicking the "OK" button will do the same, and hide the dialog
box as well.



@section The Commands Window
@node The Commands Window

This window contains a menu with C32 commands that apply to the
spreadsheet window, and is shown in Figure @ref{c32-commands}. Many of
the buttons in the Commands Window operate on the slot that is currently
selected in the spreadsheet window. The window also displays the current
package that is used by C32 to interpret Lisp values and expressions (for
example, when you type a value or a formula). The package can be changed
by editing the string in the box.

@float Figure, fig:ex2
@center @image{c32-commands, 5.5in}
@caption{The C32 Commands Window.}
@anchor{c32-commands}
@end float

The meaning of each group of buttons is explained below.

@section[Point To Object]

This button pops up a dialog box that allows an object to be added to the
spreadsheet window by pointing and clicking with the mouse. The dialog
box explains how to select objects (by clicking control-left) and how to
move from one object to another underneath it. Clicking control-left on
any Garnet object inserts the name of the object in the dialog box.

Once the name of the desired object is displayed in the dialog box, you
can click the Apply button (which creates a new panel displaying the
object), the OK button (which does the same thing and then hides the
dialog box), or the Cancel button.

@section[Showing references to other slots]

Three buttons are used to show references, i.e., dependencies among slots.
Clicking on the "Slots Using Me" button displays green arrows that
indicate what formulas (in objects currently shown in C32) use the
selected slot. The arrows originate on the Formula symbol of the
dependent slots, and point to the value portion of the selected slot. If
a dependent slot belongs to another object, and that object is shown in a
panel, the arrow is drawn to the other panel.

Clicking on the "Slots I Use" button of a slot that contains a formula
shows red arrows from the formula symbol to all the slots (currently shown
in C32) upon which the formula depends. These arrows are heavier than the
ones discussed previously, and they point to the slot side, rather than
the value side.

Clicking on the "Clear References" button eliminates all currently
displayed reference arrows. This operation does not alter any internal
value, of course.


@section[Deleting, hiding, and showing slots]

The "Hide Slot" button causes the selected slot to be eliminated from the
C32 panel. The value of the slot in the object is unaffected. The "Show
All Slots" button causes all slots in the selected object to be displayed
in the panel.

The "Delete Slot" is used to delete the currently selected slot from the
actual object. Care should be taken, because this is a destructive
operation. Trying to delete some of the most important slots prompts for
confirmation.


@section[Copy Formula]


@cindex{generalizing formulas}
The "Generalize Formula" button allows a function to be created by
generalizing the formula associated with the current slot. Generalizing a
formula means that a function is created in which hard-wired references to
objects and slots are replaced by parameters. The function can then be
used as a more general expression, for example inside other formulas.
This button pops up a dialog box that allows you to type the name of the
function to be created, and to select names for object and slot
references. When you click OK, the definition of the new function is
printed in the Lisp listener window.


@cindex{copying formulas in C32}
The "Copy Formula" button copies the formula installed on the
secondary-selected slot to the slot that corresponds to the primary
selection. A box pops up to make sure this is what you want to do.


@section[Quit]

This button causes C32 to destroy all its windows and exit. If C32 was
started up from Lapidary, however, the windows are simply temporarily
hidden, so that C32 can start up faster the next time.



@section C32 Internals
@node C32 Internals

@cindex{slots-to-show slot}
The list of slots to be displayed in a panel is kept in the
@code{:slots-to-show} slot of Garnet objects. In most cases, this slot is
inherited. If you are creating new types of objects, you may want to set
the @code{:slots-to-show} slot appropriately in the prototype, so that C32
will display only relevant slots when it shows an instance in a panel.

It is probably a good idea not to try to edit the contents of the
@code{:slots-to-show} slot using C32 itself.

The current version of C32 is not very optimized; redisplaying and
scrolling panels, in particular, is rather inefficient. We hope to make
its performance better in the next release.


@ref{References}


@chapter Lapidary Reference
@node Lapidary Reference

by Brad T. Vander Zanden,
David Bolt

@value{DATE}

@section Abstract
@node Abstract

This document describes the features and operations provided by Lapidary,
a graphical interface builder that allows a user to pictorially specify
all graphical aspects of an application and interactively create much
of the behavior. Lapidary allows a user to draw most of Opal's objects,
combine them into aggregadgets, align them using iconic constraint
menus or custom constraints, and create behaviors by entering appropriate
parameters in dialog boxes representing each of Garnet's interactors, or
by demonstrating the appropriate behavior for feedback objects.




@section Getting Started
@node Getting Started


@cindex{Run Lapidary}
@cindex{Start Lapidary}
To load Lapidary, type @t((load garnet-lapidary-loader)) after Garnet has
been loaded, or type @t((defvar load-lapidary-p t)) before Garnet
is loaded, and Garnet will automatically load Lapidary when the Garnet loader
file is invoked. To start Lapidary, type @t((lapidary:do-go)). 
This will cause Lapidary to come up in its initial state 
with the following windows:

@itemize

editor-menu: This menu contains a set of functions that deal with aggregadgets,
constraints, saving and restoring objects, deleting objects, 
and setting properties of objects.

shapes menu: This menu allows the designer to create opal graphical objects
and windows.

box-constraint menu: This menu allows the designer to attach constraints to
an object that control its left, top, width, and height.

drawing window: This window allows the designer to create new
objects or load objects from existing files.

@end itemize

@section Object Creation
@node Object Creation
Lapidary allows new objects to be created from scratch,
loaded from pre-defined gadgets files, or created directly in Garnet
and then linked to a Lapidary window. The shapes menu displays the
primitive graphical objects that can be created in Lapidary.

@float Figure, fig:ex2
@center @image{shapes, 5.5in}
@caption{Shapes menu}
@end float

@cindex{line}
@cindex{rectangle}
@cindex{roundtangle}
@cindex{circle}
@cindex{text}
@cindex{text}
@cindex{multi-text}
@cindex{window}
@cindex{bitmap}
@cindex{aggrelist}
The first six geometric shapes can be created by selecting the 
appropriate menu-item
and sweeping out the item in a drawing window with the right mouse button down.
Feedback corresponding to the selected shape will be shown as the 
object is swept out. Properties  such as line-style, filling-style, and 
draw-function can be set from the corresponding property menus (see 
section @ref{Properties}). 

To create a single line of text, select text and then click where 
you want the text to start. A cursor will
appear and one line of text can be entered from the keyboard. For more 
than one line of text use multi-text. Single-line text can be terminated
with either a mouse click or by hitting RETURN but, multi-line text
can only be terminated by a mouse click. 

To create a window, select the @t(window) menu-item and Lapidary will
create a new window. Since, new windows initially have the same
size and location as the draw window,
they must be moved in order to expose the original draw window.

Bitmaps can be loaded by selecting the @t(bitmap) menu-item. Lapidary
brings up a dialog box that allows the user to enter the name of an image file 
and the window that the bitmap should be placed in. The window name
is obtained from the title border that surrounds a window or the name
that appears in the icon for the window.

To create a horizontal or vertical list, first select a prototype 
object. Then select horizontal or vertical list and sweep out the list.
A property sheet will appear that can be used to set parameters that
control the list's appearance. A description of the parameters can 
be found in the chapter on aggregadgets and aggrelists.


@section Selecting Objects
@node Selecting Objects
@cindex{selecting objects}
@cindex{primary selection}
@cindex{secondary selection}
Lapidary permits two types of selections: primary selections and secondary
selections. 
Primary selections are denoted by black grow boxes that sprout around the
perimeter of an object; secondary selections are denoted by white grow
boxes. Most operations do not distinguish between these two types of 
selections and will operate in the same way on both types of selections. 
However, two operations, attaching a constraint to an object and
defining parameters for an object, do make this distinction.

Lapidary provides two types of selection modes (Figure 
@ref{lapidary-editor-menu}): a ``leaves'' mode
which causes Lapidary to select leaf
elements of an aggregate, and a ``top-level objects'' mode which causes
Lapidary to select top-level aggregates (objects that do not belong to an
aggregate will be selected in either mode). 
@cindex{aggregadget, selection}
To aid the user in determining whether they have selected a leaf or
aggregate element, Lapidary uses different types of selection
handles, rectangular handles for leaf elements 
and circular
handles for aggregates (Figure @ref{selection}).
If the object is too small to
accomodate 8 selection handles, either a thin or thick-lined arrow is used
to highlight the selection,
depending on whether the object is
a leaf or aggregate object (Figure @ref{selection}).

In either mode, additional
clicks over the selected object will cause Lapidary to cycle through
the aggregate hierarchy.
For example, when the
user clicks on the label shown in Figure @ref{aggregate-hierarchy}.a, 
and Lapidary is in ``top-level
objects'' mode, the entire list element is selected 
(Figure @ref{selection-techniques}.a). If the user
clicks on the label again, the label is selected 
(Figure @ref{selection-techniques}.b). Clicking once
more with the mouse causes the key-box to become selected (Figure
@ref{selection-techniques}.c). Finally, one more click causes the 
list element to be selected, at
which point the cycle repeats itself. In ``leaves'' mode, the label would be
the first object selected, then the key box, and finally the list element.

@float Figure, fig:ex2

@center @image{editor-win, 5.5in}
@caption{
The user can cause Lapidary to select leaves of aggregates or top-level
aggregates by choosing the appropriate selection mode in the editor
menu window.
}
@anchor{lapidary-editor-menu}

@end float


@float Figure, fig:ex2
@center @image{agg-hierarchy-a, 5.5in}
@center @image{agg-hierarchy-b, 5.5in}

@table @code
(a)
(b)
@end table

@caption{
A list element (a) and the objects used to build this list element (b).
}
@anchor{aggregate-hierarchy}
@end float

@float Figure, fig:ex2
@center @image{selection, 5.5in}

@table @code
(a)
(b)
(c)
@end table

@caption{
As the user repeatedly clicks the mouse button over an object, the selection
cycles through the aggregate hierarchy shown in Figure 
@ref{aggregate-hierarchy}. If Lapidary is in ``top-level objects'' mode, 
then the list element is initially
selected (a). A second click selects the label (b), and a third click 
selects the key-box (c). 
}
@anchor{selection-techniques}
@end float

Lapidary provides the usual range of selection 
operations found in drawing editors, select,
add to selection, deselect, remove from selection,
select/deselect in region. These operations are supported for
both primary and secondary selections.
In addition, Lapidary allows the user to select covered objects by pointing
at an already selected object and requesting that the object directly covered
by the selected object be selected.

Section @ref{mouse-commands} provides specific details on each of the
selection operations.

@float Figure, fig:ex2
@center @image{selections, 5.5in}
@caption{Different types of selection objects. Squares are for primitive
graphical objects, circles are for aggregadgets, and arrows are for objects
too small to accommodate grow boxes.}
@anchor{selection}
@end float

@section Mouse-Based Commands
@node Mouse-Based Commands
@cindex{mouse}
@anchor{mouse-commands}
Lapidary is primarily a mouse-based system so it is important to know which
mouse buttons correspond to which operation. 
These bindings are set in the file mouse-bindings.lisp and may be
edited. Currently the following operations can
be bound to mouse buttons (the pair following each entry shows the 
default and the variable that must be changed to modify the default):

@itemize

@cindex{primary selection}
Primary Selection (leftdown, *prim-select-one-obj*): The user can 
either point at a particular object
and make it the primary selection, or sweep out a rectangular region of the
screen and make all objects that @emph{intersect} the 
region be primary selections.
This operation causes the previous primary selections to be deselected. If the
mouse is not pointing at any objects, all primary selections are deselected.
Each successive mouse click over the same object 
moves the selection one level higher in
the aggregate
hierarchy, until the top-most level is reached, at which point the
selection process cycles back to a leaf (if the selection is initially a
top-level object, the next click cycles to the leaf).

@cindex{Secondary Selection}
Secondary Selection (middledown, *sec-select-one-obj*): Same as primary 
selection but makes a secondary selection.

@cindex{primary selection, deselect}
Deselect Primary Selection (control-leftdown, *primary-deselection-button*): 
This operation allows the user to deselect primary selections. The user
can either point at a specific object or sweep out a rectangular region, 
in which case all objects that intersect this region will be 
deselected (if they are primary selections).

@cindex{secondary selection, deselect}
Deselect Secondary Selection 
(control-middledown, *secondary-deselection-button*): Same as Deselect 
Primary Selection except secondary selections are deselected.

@cindex{primary select covered object}
Primary Select Covered Object (shift-control-leftdown,
*prim-push-sel-under-button*): This operation
allows the user to select covered objects. When the user points at a particular
area of the screen, Lapidary determines which object is currently selected,
and then deselects it and primary selects the first object that it covers. If
no object under the mouse is selected, Lapidary primary selects the top object.
If multiple objects under the mouse are selected, Lapidary finds the first
unselected object which is under a selected object, selects the unselected
object, and deselects the topmost selected object.
 
@cindex{secondary select covered object}
Secondary Select Covered Object (shift-control-middledown,
*sec-push-sel-under-button*): Same as Primary Select Covered Object except
a secondary selection is made.

@cindex{Primary Selection, add to}
Add to Primary Selection (shift-leftdown, *prim-add-to-select*): Same as
Primary Selection except previously selected objects remain selected.
Covered objects that are selected are 
automatically added to a selection, rather than causing
previously selected objects to be deselected. Multiple clicks with
the @t(Add to Primary Selection) button over the @emph{selection handles}
of a covered object will cause the selection to cycle through the
aggregate hierarchy (Figure @ref{covered-selection}).

@cindex{secondary selection, add to}
Add to Secondary Selection (shift-middledown, *sec-add-to-select*): Same
as add to primary selection but adds to secondary selection.

@cindex{Move}
Move Object (leftdown, *move-button*): This operation allows 
the user to move an
object around the window. The user must point at one of the eight ``grow''
boxes around the perimeter of box objects, or one of the three ``grow''
boxes attached to line objects or the arrow if the object is too 
small to contain grow boxes. If the object is a box object 
and the user points at one of
the corner boxes, the object can move in any direction, if the user points
at one of the side boxes, the object can move in only one direction (along
the x-axis if the left or right side is chosen and along the y-axis if the
top or bottom side is chosen). If the object is a line object, Lapidary will
attach the mouse cursor to the point designated by the grow box (either an
endpoint of the line or its midpoint) and move the line in any direction.
If the object is undersized so that the object does not have grow boxes but
instead is pointed at by an arrow, then pointing at the arrow will cause the
cursor to be attached to the northwest corner of the object and the object
can be moved in any direction.

@cindex{grow}
@cindex{resize}
Grow Object (middledown, *grow-button*): This operation allows
the user to resize an
object. The user must point at one of the eight ``grow''
boxes around the perimeter of the object if the object is a box, one of
the endpoint ``grow'' boxes attached to the object if the object is a line,
or the arrow that points at the object if the object is too small to contain
the grow boxes. If the object is a box object and
the user points at one of
the corner boxes, both the object's width and height can change, if the
user points 
at one of the side boxes, only one of the object's dimensions will change
(the width if the left or right side is chosen, the height if the top or
bottom side is chosen). If the object is a line object, Lapidary will
attach the mouse cursor to the point designated by the grow box and move
that endpoint while holding the other endpoint fixed.
If the object is undersized so that the object does not have grow boxes but
instead is pointed at by an arrow, then pointing at the arrow will cause the
cursor to be attached to the northwest corner of the object and the object's
width and height will both change.

@cindex{create object}
Object Creation (rightdown, *obj-creation-button*): The user sweeps out
a region of the screen and Lapidary creates the object selected
in the shapes menu.

@cindex{make copy}
Copy Object (shift-rightdown, *copy-button*):
This operation allows 
the user to create a copy of an object and position it in
a window (copies of an object can also be created using the
@t(make copy) command in the editor menu window, see
Section @ref{edit-commands} for details). 
The user must point at one of the eight ``grow''
boxes around the perimeter of box objects, or one of the three ``grow''
boxes attached to line objects or the arrow if the object is too 
small to contain grow boxes. 
The selected ``grow'' box 
constrains the initial movement of the new object (see @t(Move Object) for
a description of how the ``grow'' boxes constrain movement).

@cindex{make instance}
Instance Object (control-rightdown, *instance-button*):
This operation allows 
the user to create an instance of an object and position it in
a window (instances of an object can also be created using the
@t(make instance) command in the editor menu window, see
Section @ref{edit-commands} for details). 
The user must point at one of the eight ``grow''
boxes around the perimeter of box objects, or one of the three ``grow''
boxes attached to line objects or the arrow if the object is too 
small to contain grow boxes. 
The selected ``grow'' box 
constrains the initial movement of the new object (see @t(Move Object) for
a description of how the ``grow'' boxes constrain movement).

@cindex{text, edit}
Text Editing (rightdown, *obj-creation-button*): The user can edit 
a selected text object by pointing at it and clicking with the object
creation button. 
The user can use any text editing command described in the interactors
manual and clicks down on the mouse button to indicate that editing
is complete.

@end itemize

@float Figure, fig:ex2
@center @image{covered-selection, 5.5in}

@table @code
(a)
(b)
(c)
@end table

@caption{Selecting a covered object in ``leaves'' mode.
The label is covered by an xor feedback object, so the feedback object is
the initial selection (a). Clicking the @t(shift-control-leftdown) mouse button
pushes the selection down to the covered label (b). Clicking the
add to selection button (@t(shift-leftdown) over the feedback arrow
causes the selection to cycle up to the next level in the aggregate
hierarchy, in this case, the key-box (c).
}
@anchor{covered-selection}
@end float

@float Figure, fig:ex2
@center @image{duplicating-a, 5.5in}
@center @image{duplicating-b, 5.5in}
@center @image{duplicating-c, 5.5in}

@table @code
(a)
(b)
(c)
@end table

@caption{
Objects can be duplicated or instanced by clicking on one of the
selection handles (a), dragging the new object to the appropriate
location (b), and dropping it (c).
}
@anchor{duplicating}
@end float



@section Editor Menu Commands
@node Editor Menu Commands

@anchor{editor-menu}

The commands in Lapidary's pull down menu (Figure @ref{lapidary-editor-menu})
provide a set of commands for saving and restoring objects, manipulating
aggregadgets, applying constraints, and editing properties.

@section File
@node File
@cindex{save}
@itemize
@t(Save Gadget:) Objects are written out using @t(opal:write-gadget),
so the file contains
a series of create-instance calls. The value in the object's @t(:known-as)
slot is passed as the name parameter to create-instance. For example, if
the object's @t(:known-as) slot is @t(:white-rect) and the object is a
rectangle, the first line of the create-instance would be

@example
(create-instance 'white-rect opal:rectangle)
@end example

Primary selections are saved before secondary selections, so it is best to
make prototypes primary selections and instances of these prototypes secondary
selections. The user can also save an entire window by having no
objects selected and typing in the string that appears in a window's title
bar or icon in the corresponding area of the dialog box.

Lapidary looks at each saved object to determine if the object has any
links which Lapidary thinks should be parameters. If Lapidary finds any
such links, it pops up the link parameters dialog box and asks the user
if these links should be made into parameters (see Section @ref{parameters}).
Pressing either the @t(OK) or @t(CANCEL) buttons in the link parameters
dialog box allows Lapidary to continue. The @t(CANCEL) button in the
link parameters dialog box will not cause Lapidary to discontinue the save
operation, it will simply cause Lapidary to proceed to the next object.

@float Figure, fig:ex2
@center @image{saving, 5.5in}
@caption{Save file dialog box}
@anchor{save-dialog-box}
@end float

@t(Load Gadget:) Requests the name of a file and then loads it
(Figure @ref{load-dialog-box}).
Lapidary expects a variable named *Garnet-Objects-Just-Created* to
be initialized in the user package which contains the names of
the created objects. If the user selects the option @t{Replace existing
objects}, then the objects in the loaded file will replace the current
objects in the drawing window. If the user selects the option 
@t{Add to existing objects}, then the objects in the file will be
added to the existing objects in the window.

@float Figure, fig:ex2
@center @image{loading, 5.5in}
@caption{Load file dialog box}
@anchor{load-dialog-box}
@end float

@cindex{add gadget}
@t(Add Gadget:) Users may create objects in the lisp listener and then link
them to a Lapidary window. @t(add-gadget) pops up a
dialog box that requests the name of the object to be added
and the name of a window to place the object in (Figure @ref{add-gadget-fig}).
The name of
the object should be the one used in the call to create-instance.
For example, the object created by
@t{(create-instance 'my-gadget opal:rectangle)} is named ``my-gadget''.
The name of the window should be the name that appears in the
window's title bar or in its icon.

@float Figure, fig:ex2
@center @image{add-gadget, 5.5in}
@caption{Add gadget dialog box}
@anchor{add-gadget-fig}
@end float

The user has the option of either adding the object itself or an
instance of the object to Lapidary. If the user decides to add the
object itself and the object has instances, Lapidary will pop up
a warning box indicating that editing this object could have unintended
consequences on other applications that use this object. For example,
it is better to add an instance of a garnet gadgets text button rather
than the actual button defined in the gadgets package, since editing the
actual button is likely to cause Lapidary to fail 
(Lapidary uses garnet gadgets text buttons).

@cindex{quit}
@cindex{exit}
@cindex{stop}
@t(Quit:) Allows the user to exit Lapidary. It is suggested that before
rebooting Lapidary, that the user create a new lisp listener and reload
Garnet.

@end itemize


@section Edit
@node Edit
@cindex{Edit}
@anchor{edit-commands}
@itemize
@cindex{make instance}
@t(Make Instance:) Creates an instance of the selected object. The selected
object is the new object's prototype.

@cindex{make copy}
@t(Make Copy:) Creates a copy of the selected object. The value of each 
slot in the selected object will be copied to the new-object. 
The new object will have the same prototype as the selected object, 
and thus will inherit from the selected object's prototype rather
than the selected object.

@cindex{delete object}
@t(Delete Object:) Destroys all selected objects. 

@cindex{delete window}
@t(Delete Window:) Pops up a dialog box and asks the user to input 
the name of a window that appears in a window's title bar or icon. 
Lapidary then destroys the window.

@end itemize


@section Properties
@node Properties
@cindex{Properties}
@anchor{Properties}

Lapidary contains four property menus that control an object's line-style,
filling-style, draw-function, and font.
The line-style and filling-style menus (Figures @ref{shade-menu} and
@ref{line-menu}) provide a set of commonly used
styles, an ``Other'' option which prompts the user for the name of a style,
and a ``Constraint'' option that allows the user to enter a custom constraint
that defines the style (see Section @ref{constraints} for information
on how to enter a custom constraint).
The color button pops up a color menu that allows the user to select a
pre-defined color or create a new color by mixing hues of red, green,
and blue.

@itemize
@cindex{filling style}
@t(Filling Style:) Allows the user to set the filling style of selected 
objects. 

@float Figure, fig:ex2
@center @image{filling-properties, 5.5in}
@caption{Filling styles that can be attached to objects in Lapidary}
@anchor{shade-menu}
@end float

@cindex{line style}
@t(Line Style:) Allows the user to set the line style of selected objects.

@float Figure, fig:ex2
@center @image{line-properties, 5.5in}
@caption{Line styles that can be attached to objects in Lapidary}
@anchor{line-menu}
@end float

@cindex{draw function}
@t(Draw Function:) Allows the user to set the draw 
function of all selected objects. The Opal chapter describes draw
functions in more detail.

@float Figure, fig:ex2
@center @image{draw-function, 5.5in}
@caption{Draw functions that can be attached to objects in Lapidary}
@anchor{draw-menu}
@end float

@cindex{name object}
@t(Name Object:) Requests a name from the user (no quotes should
be used), converts it to a keyword, and stores it in the :known-as slot
of the selected object (if there is more than one selected object, Lapidary
will rename the last object the user selected; name object does
not distinguish between primary and secondary selections).
Lapidary also creates a link with this name in the object's parent
that points to this object. When an object is saved, it will be assigned
this name.

@cindex{list properties}
@t(List Properties:) Brings up a property list for horizontal and vertical
lists. This property list allows the user to modify any of the customizable
slots of an aggrelist. The list of customizable slots can be found in
the Aggrelists chapter.

@cindex{text properties}
@t(Text Properties:) Allows the user to choose a standard Opal font,
to request a font from one of the directories on the user's font path,
to request a font from an arbitrary directory, or to enter a custom
constraint that determines the font (Figure @ref{text-menu}).
It also allows the user to enter a custom constraint that determines the
string of a text object.

@float Figure, fig:ex2
@center @image{text-properties, 5.5in}
@caption{Lapidary's text properties menu}
@anchor{text-menu}
@end float

@cindex{parameters}
@anchor{parameters}
@t(Parameters:) Allows the user to specify that
one or more slots in an object should be parameters
(Figure @ref{parameters-fig}). A slot that is a parameter will have
its value provided at run-time by the application.
To create parameters, the user must make both a primary and a secondary
selection. The primary selection is the object whose slots are being
made into parameters and the secondary selection is the object that
the parameters will retrieve their values from. Typically the secondary
selection will be the top-level aggregadget that contains the object,
since the top-level aggregadget is the only object that the application
should know about (an application should not be required to know the parts
of an aggregadget). For example, if a
label text object belongs to an aggregadget, the user might make the label
the primary selection and the aggregadget the secondary selection.
If the object is already at the top-level, then the
object should be both the primary and secondary selection.

@float Figure, fig:ex2
@center @image{parameters, 5.5in}
@caption{Parameters dialog box}
@anchor{parameters-fig}
@end float

To turn a slot into a parameter, select the text box next to the slot
and enter the name of the slot in the
secondary selection that the slot should retrieve its value from. 
In Figure @ref{parameters-fig}, the label's @t(string) slot
retrieves its value from list element's @t(value) slot,
and the @t(font) slot retrieves its value from the list element's
@t(font) slot. To
make the slot no longer be a parameter, make the slot's text box be blank.
Lapidary maintains a list of slots for each objects that can be turned
into parameters. If the user wants to parameterize a slot that is not
displayed in the parameters dialog box, the user can bring up C32 and
place a formula in the desired slot that retrieves its value from the
top-level aggregadget.

@float Figure, fig:ex2
@center @image{link-parameters, 5.5in}
@caption{Link parameters dialog box}
@anchor{link-parameters}
@end float

The link parameters button in the parameters dialog box allows the user
to specify links that should be parameters. 
Links are used by Lapidary-generated
constraints to indirectly reference other objects. For example, when
the user creates a constraint that attaches the endpoint of a line,
say @t(arrow1) to a rectangle, say @t(rect1),
Lapidary generates a link in
@t(arrow1) that points to @t(rect1). When a link references an object that
is not part of the primary selection's top-level aggregadget, Lapidary
guesses that this link should be a parameter and displays it in the
link parameters dialog box (Figure @ref{link-parameters}). For each such
link, Lapidary displays the value of the link, the slots that reference
the link, and a parameter name, if any, that the user has assigned to this
link. The user can change this parameter name by editing it, or can
indicate that this link should not be a parameter by making the parameter
name blank.


@float Figure, fig:ex2
@center @image{ParamItems, 5.5in}
@caption{Parameters dialog box for an Aggrelist}
@anchor{paramItems-fig}
@end float

To make a slot depend on an :items list in an aggrelist, make any
object in the aggrelist be a primary selection and make the
aggrelist be the secondary selection. Then enter :items in
the labeled box for any slot on the parameters menu that should get
its value from :items. For example, suppose the
prototype object for a list is a text object and
the string and font slots of the text object should retrieve their
values from the aggrelist's @t(:items) slot. To do this the user
makes the aggrelist the secondary selection and one
of the text objects in the aggrelist a primary selection. The user
then selects the @t(parameters) option, which
causes Lapidary to pop up the parameters menu. Typing :items in the
type-in fields next to the @t(font) and @t(string) slots creates
the necessary formulas that link these slots to the @t(:items) slot in
the aggrelist (Figure @ref{paramItems-fig}). The :items slot of
the aggrelist will now contain a list of the form 
((string1 font1) (string2 font2)...(stringN fontN)).

If the prototype object is an aggregadget (such as a labeled box that
contains a rectangle and a piece of text), then any of the parts of the
aggregadget, and the aggregadget itself, can have slots that depend on
the aggrelist's :items slot. This is done by parameterizing the parts
one at a time. For example, if the string slot of the text object and
the filling-style slot of the rectangle should be parameters, the user
could first select the rectangle and parameterize it, then select the
text object and parameterize it. Lapidary does not follow any easily
described rules in constructing the :items list (e.g., the string and
font values could easily have been reversed in the above list), so users
should look at the :items list Lapidary constructs before writing their own.

If a slotname besides
:items (e.g., :string) is entered in a type-in field, then the slot
is treated as an ordinary parameter, and all items in the list will
have a formula that accesses this slot in the aggrelist. For example,
if a list consists of rectangles, and the rectangles should all
have the line-style that is passed to the aggrelist, then
the user would select one of the rectangles and enter the an
appropriate name, such as @t(:line-style), next to the :line-style
slot of the rectangle.


@end itemize


@section Arrange
@node Arrange
@cindex{arrange}
@itemize
@cindex{bring to front}
@t(Bring to Front:) Brings the selected objects to the front
of their aggregadget (i.e., they will cover all other objects in their 
aggregadget). If multiple objects are selected, it brings the objects to the
front in their current order.

@cindex{send to back}
@t(Send to Back:) Sends the selected objects to the back of their
aggregadget (i.e., they will be covered by all other objects in their
aggregadget). If multiple objects are selected, it sends the objects 
to the back in their current order.

@cindex{aggregadget, make}
@t(Make Aggregadget:) Creates a new aggregadget and adds all 
selected objects (both primary and secondary selections) to it. 
The selected objects must initially belong to the same aggregadget or else
Lapidary will print an error message and abort the operation.
The @t(:left) and @t(:top) slots of the
objects added to the aggregadget are constrained to the aggregadget unless
they were already constrained (if the object is a line, the @t(:x1), @t(:y1),
@t(:x2), and @t(:y2) slots are constrained).
The constraints tie the objects to the northwest corner of the aggregadget
and use absolute offsets based on the current position of the objects.
Thus if an object is 10 pixels from the left side of the aggregadget (the
bounding box of the aggregadget is computed from the initial bounding
boxes of the objects), the object's @t(:left) slot will be constrained to be 10
pixels from the left side of the aggregadget.
If the object is a line, the object's endpoints will be tied to
the aggregadget's northwest corner by absolute fixed offsets.
These constraints cause the objects to move with the aggregadget
when the aggregadgets moves. 
If the user wants different constraints to apply, the user can primary
select an object, secondary select the aggregadget, and attach a different
constraint. The aggregadget derives its width and height
from its children, so the :width and :height slots of the children are not 
constrained to the aggregadget. Because the aggregadget computes
its width and height from its children, it is not permitted to resize
an aggregadget.

@cindex{ungroup}
@t(Ungroup:) Destroys selected aggregadgets and moves their components to the
aggregadgets' parents.

@end itemize


@section Constraints
@node Constraints
@cindex{constraints}
@itemize
@t(Line Constraints:) Brings up the line constraints dialog box 
@cindex{line constraints}
(Figure @ref{line-constraint}).

@t(Box Constraints:) Brings up the box constraints dialog box
(Figure @ref{box-constraint}) 
@cindex{box constraints}

@cindex{C32}
@t(C32:) Brings up C32. Each primary and secondary selection is displayed
in the spreadsheet, and additional Lapidary objects can be displayed using
the @t(Point to Object) command. While Lapidary is running, only objects in
Lapidary's drawing windows can be displayed in the spreadsheet. Nothing will
happen if the user attempts to execute the @t(Point to Object) command on
an object which is not in a Lapidary drawing window. The C32 chapter
describes how to use C32 and Section
@ref{custom-constraint} describes a number of modifications Lapidary makes
to C32.


@end itemize


@section Other
@node Other
@cindex{other, menu selection}
@itemize
@cindex{interactors}
@t(Interactors:) Displays a menu of interactors that the user
can choose to look at. Once the user selects an interactor, the information
from that interactor will be displayed in the appropriate interactor
dialog box (see Section @ref{interactors}) and the user is free to change it.
In addition, menu items are provided for the five Garnet-defined interactor
types: choice (encompassing both menu and button interactors), move/grow,
two-point, text, and angle. If the user has selected a set of objects, then the interactors menu will
contain all interactors associated with these objects.
Lapidary will display all interactors whose @t(:start-where) slot references
these objects, or whose @t(:feedback-obj) or @t(:final-feedback-obj) points
at these objects. If no objects are selected, then the interactors menu will contain all interactors
that have been created in Lapidary.

@cindex{clear  workspace}
@t(Clear Workspace:) Deletes all objects from Lapidary but does not destroy any
of the drawing windows.

@end itemize


@section Test and Build Radio Buttons
@node Test and Build Radio Buttons
@itemize
@cindex{test}
@t(Test:) Deactivates the Lapidary interactors that operate
on the drawing windows and activates all user-defined interactors. This allows
the user to experiment with the look-and-feel that the user has created.

@cindex{build}
@t(Build:) Deactivates all user-defined interactors and reactivates the Lapidary
interactors, allowing the user to modify the look-and-feel.
@end itemize



@section Creating Constraints
@node Creating Constraints

@cindex{constraints}
@anchor{constraints}

Lapidary provides two menus for creating constraints, one that deals with
``box'' constraints (constraints on non-line objects)
and one that deals with line constraints.
In addition, several of the property menus provide a custom constraint option
that allows the user to input a constraint that determines the property.
Each of the menus contains buttons labeled with tiny rectangular boxes that
indicate how an object will be positioned if the constraint associated with
that button is chosen. 
The rectangular boxes in the buttons are colored black to indicate that 
the primary object is the object that will be constrained, and 
the white rectangular
boxes positioned at the four corners of the rectangle in the box constraint
menu indicate that the secondary selection is the object that
will be referenced in the constraint.

The Box and Line Constraint dialog boxes, can be used separately from Lapidary
(see section @ref{constraint-gadget}). 

The constraint menus can display the current position and size of a primary
selection. By pressing the @t(Show Constraints) button in the constraint menus,
the user can see what types of constraints are on the slots of an object.
If two objects are selected, Lapidary will display the types of the 
constraints between the two objects.

@section Box Constraints
@node Box Constraints
@anchor{box-constraint-section}

The box constraint menu allows constraints to be attached to the @t(:left), 
@t(:top), @t(:width), and @t(:height) of an object (see Figure 
@ref{box-constraint}).
The user attaches constraints by first selecting the object to be constrained
(a primary selection) and the object to be referenced in the constraint
(a secondary selection). 
The user then selects the appropriate buttons in the box constraint menu.
The possible constraints for the @t(:left) slot are:


@float Figure, fig:ex2
@center @image{box-constraint-menu, 5.5in}
@caption{
The constraint menu for box-like objects on the left, and a
drawing window on the right. The white
rectangle in the drawing window is the object to be constrained and the gray
rectangle is the object to be referenced in the constraint.
The white rectangle is constrained to
be offset
from the right of the gray rectangle by 20 pixels, and
aligned at the top-inside of the gray rectangle.
The white rectangle's width is not constrained and it is 33% as tall
as the gray rectangle. If the gray rectangle
changes, the white one will be adjusted automatically.
}
@anchor{box-constraint}
@end float

@itemize

left-outside: The right side of the primary selection is aligned with the
left side of the secondary selection.

left-inside: The left side of the primary selection is aligned with the
left side of the secondary selection.

center: The center of the primary selection is aligned with the center
of the secondary selection.

right-inside: The right side of the primary selection is aligned with the
right side of the secondary selection.

right-outside: The left side of the primary selection is aligned with the
right side of the secondary selection.

@end itemize

The possible constraints for the @t(:top) slot are:

@itemize

top-outside: The bottom side of the primary selection is aligned with the
top side of the secondary selection.

top-inside: The top side of the primary selection is aligned with the
top side of the secondary selection.

center: The center of the primary selection is aligned with the center
of the secondary selection.

bottom-inside: The bottom side of the primary selection is aligned with the
bottom side of the secondary selection.

bottom-outside: The top side of the primary selection is aligned with the
bottom side of the secondary selection.

@end itemize

The only option for the @t(:width) slot is to constrain
the width of the primary selection to the width of the secondary selection
and the only option for the @t(:height) slot is to constrain the
height of the primary selection to the height of the secondary selection.
In addition, each of the four slots may have a custom constraint attached
to them (see Section @ref{custom-constraint}).
Each of the four slots also has an ``Unconstrain'' option that destroys the
constraint attached to that slot.

The constraints in the box constraint menu can be fine-tuned by entering
offsets for the constraints, and in the case of the size slots
(width and height), scale factors as well. 
When an object is centered with respect to another object, the offset
field changes to a percent field denoting an interval where 0% causes
the center point of the constrained object to be attached to the left or
top side of the object referenced in the constraint and 100% causes the
center point of the constrained object to be attached to the right or
bottom side of the object referenced in the constraint.
By default this percentage is 50.
The @t(Difference in pixels) and @t(Scale) factors cause the width and
height constraints to be computed as @emph{Scale * Dimension + Difference in pixels}.

Finally, each of the slots has a labeled box next to its name that allows
the user to type in an integer that will be placed in that slot.
If there is already a constraint in the slot, the constraint will not be
destroyed so the value will only temporarily
override the value computed by the constraint (the next time the constraint
is recomputed, the value will be lost). This operation works only when
there is one primary selection and no secondary selections.

@section Line Constraints
@node Line Constraints
@anchor{line-constraint-section}

The line constraint menu allows the endpoints of a line to be attached to
other objects or the @t(:left) and @t(:top) slots of a box object to be
constrained to the endpoint of a line (Figure @ref{line-constraint}).
The buttons on the box and line object in Figure @ref{line-constraint}
indicate the various locations where the endpoint of a line can be attached
to a box or line object or where a point of
a box can be attached to a line.
Thus the two endpoints of a line can be attached to any of the corners, sides,
or center of a box object and any of the corners, sides, or center of a box
object can be attached to the endpoints or center of a line.

@float Figure, fig:ex2
@center @image{line-constraint-menu, 5.5in}
@caption{
The constraint menu for line-like objects on the left, and a
drawing window on the right. The arrow in the drawing window is the
object to be constrained and the circle is the
object to be referenced in the constraint.
In the ``obj-to-constrain'' section
of the constraint
menu, the line feedback object has been rotated so that it has the
same orientation as the selected arrow, and the box feedback object
has been disabled (grayed-out). In the ``obj-to-reference'' section
the line feedback object has been disabled since the object to be
referenced in the constraint
is a box-like object. The darkened buttons on the right endpoint of
the line feedback object and the left corner of the box feedback object
indicate that the right endpoint of the arrow is attached to the left
corner of the circle.
}
@anchor{line-constraint}
@end float

The line object in the constraint menu is oriented in the same direction 
as the selected line in the 
drawing window, so that the user knows which endpoint is being constrained. 
The buttons with the blackened rectangles indicate the points that can be
constrained in the primary selection.
Similarly, the buttons with the white rectangles indicate the points in the
secondary selection that
the primary selection can be attached to.

The @t(Unconstrain) button at the bottom of the menu allows the user to
destroy the constraint on the selected point and the @t(Customize) button
allows the user to input a custom constraint (described in Section 
@ref{custom-constraint}). Finally the @t(x-offset) and @t(y-offset) labeled
boxes allow the user to enter offsets for the constraint.
All offsets are added to the value computed by the constraint. 
For example, an x-offset of 10 causes an endpoint constrained to the northwest
corner of a box object to appear 10 pixels to the right of that corner.

The end points of a line can be set directly by typing in values for
x1, y1, x2 and y2. This function is only active if there is a single line as 
the primary selection and no secondary selections.

@section Custom Constraints
@node Custom Constraints
@anchor{custom-constraint}

When the user selects the custom constraint option in any of the constraint or
property menus, Lapidary brings up the C32 spreadsheet and a formula window
for the desired slot. The user should enter a formula and press OK (or
cancel to stop the operation). Both the OK and cancel buttons in the formula
window will make C32 disappear.

Information on C32 can be found in the
C32 chapter. However, Lapidary modifies C32 in a number of ways that
are important for a user to know. First, it generates indirect references
to objects rather than direct references. A direct reference explicitly
lists an object in a constraint, whereas an indirect reference accesses
the object indirectly through a link. For example, @t{(gv rect1 :left)} is
a direct reference to @t(rect1), whereas
@t{(gvl :link0 :left)} is an indirect reference to @t(rect1) (this assumes
that a pointer to @t(rect1) is stored in @t(:link0)). If the
user always generates
references using the C32 functions @t(Insert Ref from Mouse) and
@t(Insert Ref from Spread), then Lapidary will automatically generate
indirect references and create appropriate link names. The user can
edit these link names by bringing up the parameters menu and hitting
the link parameters button (see Section @ref{parameters}).
However, if the user inserts the references by typing them in, then
the user should take care to use the @t(gvl) form and create the appropriate
links. When the formula is completed, Lapidary checks whether there are
any direct references in the formula and generates a warning if there are.
At this point the user has the option of editing the formula or continuing
with the formula as is. If the user chooses to leave direct references in
the formula, Lapidary may not be able to generalize it, so the formula may
behave strangely if it is inherited.

The second change Lapidary makes is in copying formulas. Lapidary copies
all the links that the formula references to the object which is receiving
the copied formula. If the
links should point to new objects, the user must manually change them
by selecting the @t(Show All Slots) option in C32 and editing the
appropriate links (the names of the links that need to be modified can be
found by looking at the formula).


@section The Constraint Gadget
@node The Constraint Gadget
@anchor{constraint-gadget}
@cindex{constraint-gadget}

The constraint menus have been bundled into a constraint gadget that can
be used independently of Lapidary. 
The constraint gadget provides two menus: a box constraint menu for specifying
box-type constraints (Figure @ref{box-constraint})
and a line constraint menu for specifying line-type
constraints (Figure @ref{line-constraint}). These menus operate as
described in Sections @ref{box-constraint-section} and
@ref{line-constraint-section}. The menus also provide
access to C32 through @t(customize) buttons.
The module can be loaded
independently of Lapidary with
@code{(garnet-load "lapidary:constraint-gadget-loader")} and
is exported from the gadgets package (garnet-gadgets).

@subsection Programming Interface
@node Programming Interface

The constraint gadget can be created (or made visible, if already created)
by executing one of the @code{-do-go} or @code{show-} functions described in
section @ref{Functions}. Certain slots of the gadget, described
in section @ref{cg-parameters}, are then set with the objects to be constrained.
When the user operates the buttons in the dialog box, constraints will be
set up among the indicated objects.


@subsection Slots of the Constraint Gadget
@node Slots of the Constraint Gadget
@anchor{cg-parameters}

The constraint gadget exports one object called @code{gg::*constraint-gadget*}.
This object contains four settable slots:

@vtable @code

@code{:obj-to-constrain} - The object which should be constrained. This
slot expects only one object ,  it will not take a list.

@code{:obj-to-reference} - The object which should be referenced in the
constraint. This slot expects only one object ,  it will
not take a list.

@code{:top-level-agg} - The top level aggregate containing constrainable
objects. If the aggregate associated with a window is
the top level aggregate, this slot may be left NIL (the
default). However, if, for example, the window contains an editor aggregate
and a feedback aggregate, then the @code{:top-level-agg} slot should
be set to the editor aggregate.

@code{:custom-function} - A function that is executed whenever a constraint
is attached to a slot. The function should
take three parameters: an object, a slot, and a formula. The function
is called after the formula has been installed on the slot, but before
the formula has been evaluated.
@emph{This function is not called when the user calls the c32 function and
provides a c32-custom-function as a parameter} (see Section @ref{functions}
for details on the c32-custom-function and its parameters). The function is not
called in this case since the constraint gadget does not install the
formula if the c32-custom-function is provided.
@end vtable

It is also possible to prevent either the box-constraint or line-constraint
menus from attaching a constraint to a
slot by adding the slot's name to a list in the @code{:do-not-alter-slots}
of an object. For example, to prevent a constraint from being attached
to the @code{:width} or @code{:height} slots of a text object, the list
@code{'(:width :height)} could be placed in the object's
@code{:do-not-alter-slots} slot.
If the user tries to attach a constraint to that slot, an error box
will be popped up indicating that a constraint cannot be attached to
that slot. C32 does not recognize the @code{:do-not-alter-slots}, and
therefore the box-constraint and line-constraint menus cannot prevent
the user from inserting a formula into a forbidden slot if a customize
button is chosen.



@subsection Exported Functions
@node Exported Functions

@anchor{Functions}

The following functions are exported from the constraint gadget module:

@cindex{box-constraint-do-go}
@cindex{line-constraint-do-go}
@example
gg:Box-Constraint-Do-Go @value{function}

gg:Line-Constraint-Do-Go @value{function}
@end example

These functions create the Box and Line Constraint dialog boxes. They should
@b{not} be executed multiple times, since there is only one
@code{constraint-gadget} object. If the user clicks on an ``OK'' button and makes
the dialog boxes invisible, then the following functions can be called to
make them visible again:

@cindex{show-box-constraint-menu}
@cindex{show-line-constraint-menu}
@example
gg:Show-Box-Constraint-Menu @value{function}

gg:Show-Line-Constraint-Menu @value{function}
@end example

These functions make the Box and Line Constraint dialog boxes visible. They
can only be called after the @code{-do-go} functions above have been called
to create the dialog boxes.

@example
gg:C32 &optional @emph{object  slot} @ref{function}
       &key @emph{left  top  c32-custom-function  prompt}
@end example

This function causes c32 to come up, with the @emph{object} displayed in the
first panel of the c32 window. The formula in @emph{slot} will be displayed in
c32's formula editing dialog box. The keyword parameters are as follows:
@sp 1

@vtable @code

@emph{left}, @emph{top} - Controls placement of query box that users
use to indicate that they are done with C32.


@emph{c32-custom-function} - A function to be executed when the user hits
the OK button in a formula window in C32. The function should
take three parameters: an object, a slot, and a formula.
If a custom function is provided, the formula will not be
installed in the slot (thus the function in :custom-function will
not be called, it must be called explicitly by the @emph{c32-custom-function}
if it should be executed). This
gives the @emph{c32-custom-function} an opportunity to defer the
installation of the formula. For example, in Lapidary, 
the user can create formulas that define the values of
various slots in an interactor, but until the user presses
the ``create-interactor'' or ``modify'' buttons, the
formulas should not be installed. Thus the Lapidary @code{c32-custom-function}
places the formulas on a queue, but does not install them.

The constraint gadget stores the links that this formula uses
in a meta-slot in the formula called @code{:links}.
Like the formula,
the links are not installed. That is, the link slots do
not exist (unless another formula already uses them). Because 
the links have not been installed, the constraint gadget stores
the links and the objects they point to in another meta-slot
in the formula called @code{:links-and-objs}. The contents of
this slot have the form (list (cons (link-name object))@+(*)).
Links that
already exist because another formula uses them will not be
on this list. 

The @code{c32-custom-function} or the application can 
install the links by calling
the c32 function @code{install-links} which takes a formula and
the object that the links should be installed in as arguments
(the object that is passed to @code{c32-custom-function} is the object
that should be passed to @code{install-links}). @code{install-links}
will create the links, and if the link points to an object
that is in the same aggregate as the object containing the
link, @code{install-links} will create a path to the reference
object and store it in the link 
slot. @code{install-links}
destroys the @code{:links-and-objs} slot, so the @code{c32-custom-function} or
application should take care to save the contents of this slot
if they need to make further use of this information.


@emph{prompt} - A text string that should be displayed in the query box
that appears when C32 is invoked. 

@end vtable

@example
gg:CG-Destroy-Constraint @emph{object  slot} @ref{function}
@end example

This function destroys a constraint created by the
constraint gadget. Required parameters are an object
and a slot.


@verbatim
@emph{destroy-constraint-support-slots}: destroys the slots in the :links,
:offset, and :scale slots of a formula (these are the
standard support slots created by the constraint gadget).
A slot is destroyed only if the formula is the only formula
that depends on this slot. Required parameters are:

		object: The object which contains the formula.
		formula: A formula.

		An optional parameter is:

		destroy-meta-info-p: If this parameter is true, the meta
			slots :links, :offset, and :scale are destroyed in
			the formula. This parameter defaults to nil.

@end verbatim

@example
gg:Valid-Integer-P @emph{gadget string} @ref{function}
@end example

@code{Valid-integer-p} determines if a string input by a Garnet gadget contains 
a valid integer. If it does not, the gadget's original value
is restored and an error message is printed. 



@sp 1
@cindex{install-links}
@example
c32::Install-Links @emph{formula  obj} @value{function}
@end example

This function is provided by c32, though it is not exported. As mentioned
above, it is useful for installing links when a custom function is provided
in c32. The @emph{formula} should have a @code{:links-and-objs} slot, whose value
should be a list of the form
((@emph{link-slot-name  object}) (@emph{link-slot-name object}) ...).
The @emph{obj} parameter names the object which the links should be installed
in.


@subsection Programming with Links
@node Programming with Links
@cindex{link slots}

Each constraint contains indirect references to objects rather than
direct references. The set of link names it uses to make these indirect
references is contained in the @code{:links} 
meta-slot of the formula and the name
of the offset slot it uses is contained in the @code{:offset} meta-slot. 
If the formula 
involves the width or height slots, there is also a @code{:scale} meta-slot,
containing the name of the scale slot that the formula uses.
The constraint gadget generates link and offset names by appending the
suffixes @code{-over} and @code{-offset} to the name of the slot that is being
constrained. For example, if the left slot is being constrained, the
link name will be @code{:left-over} and the offset name will be
@code{:left-offset}.
These slot names are stored in a formula's @code{:links} and @code{:offset} 
meta-slots.
For width and height slots, scale names are generated by appending the
suffix @code{-scale} to the slot name. Thus the scale slot for a height constraint
would be named @code{:height-scale}. When C32 generates link names, it generates
them by appending a number to the prefix @code{link-}. Thus it generates 
links such as @code{:link-0} and @code{:link-1}.

@verbatim
The rationale for storing slot names rather than actual values in a
formula's meta-slots is as follows:

@itemize

link slots: Storing the real objects pointed to by the constraint would
be difficult because of inheritance. When a formula was inherited,
it would have to change the object it was pointing to. If the names
of link slots are stored, it can use the link slot to get the real
object. The link slot presumably will have been made to point to
the appropriate object. Also, storing the name of the link slot
makes it easier for an application to change the link names in the
formula, if the application is so inclined.

offset and scale slots: Storing the names of the offset and scale slots
serves two purposes: 1) the application can immediately find out
what the constraint is calling the offset and scale slots and
change them if necessary (the user may not want to call an offset
slot, :left-offset); and 2) when an offset or scale changes, the
change only has to be made in one place rather than two places.
For feedback purposes, the application can retrieve the offset and
scale indirectly using the names of these slots.

@end verbatim



@subsection Custom Constraints
@node Custom Constraints
@anchor{custom}

When the user selects the custom constraint option in any of the constraint
menus, the constraint gadget brings up the C32 spreadsheet and a formula window
for the desired slot. The user should enter a formula and press OK (or
cancel to stop the operation). Both the OK and cancel buttons in the formula
window will make C32 disappear.

The constraint gadget modifies C32 in a 
number of ways that
are important for a user to know. First, it generates indirect references
to objects rather than direct references. A direct reference explicitly
lists an object in a constraint, whereas an indirect reference accesses
the object indirectly through a link. For example, @code{(gv RECT1 :left)} is
a direct reference to @code{RECT1}, whereas
@code{(gvl :link0 :left)} is an indirect reference to @code{RECT1} (this assumes
that a pointer to @code{RECT1} is stored in @code{:link0}). If the
user always generates
references using the C32 functions @code{Insert Ref from Mouse} and
@code{Insert Ref from Spread}, then the constraint 
gadget will automatically generate
indirect references and create appropriate link names. The user can
edit these link names by finding them in the spreadsheet and modifying them.
However, if the user inserts the references by typing them in, then
the user should take care to use the @code{gvl} form and create the appropriate
links. When the formula is completed, 
the constraint gadget checks whether there are
any direct references in the formula and generates a warning if there are.
At this point the user has the option of editing the formula or continuing
with the formula as is. If the user chooses to leave direct references in
the formula, the constraint gadget may not be 
able to generalize it, so the formula may
behave strangely if it is inherited.

The second change the constraint gadget makes 
is in copying formulas. The constraint gadget copies
all the links that the formula references to the object which is receiving
the copied formula. If the
links should point to new objects, the user must manually change them
by selecting the @code{Show All Slots} option in C32 and editing the
appropriate links (the names of the links that need to be modified can be
found by looking at the formula).


@subsection Feedback
@node Feedback

The user can determine which constraints are attached to an object by
selecting the object and an optional second object that the object may be
constrained to, and then
selecting the @code{Show Constraints} option. The appropriate constraint
buttons will be highlighted and the offset fields set to the correct
values. If only one object is selected, then all constraints that
the constraint menu can represent will be shown. For example, the box
constraint menu would display the constraints on the left, top, width,
and height slots. If there are two selections, a constrained object and
a reference object,
then only the constraints in the constrained object that depend on the
reference object are shown.



@section Interactors
@node Interactors

@cindex{interactors}
@anchor{interactors}

Lapidary provides a set of dialog boxes that allow a user to define new
interactors or modify existing ones. To create or modify an interactor,
select the @t(Interactors) command from the Lapidary editor menu. 
Lapidary will display a menu
listing Garnet-defined and user-defined interactors that may be viewed.
Select the desired interactor and Lapidary will display the appropriate
interactor dialog box.

All interactor dialog boxes have a number of standard items, including
a set of action buttons, a name box, a @t(:start-where) field, and buttons
for events. In addition, each dialog box allows the user to set the
most commonly changed slots associated with that interactor. Other slots may
be set using C32 (see section @ref{custom-constraint}).

The name field allows the user to type in a name for the interactor. The name 
is not used to name the interactor, but instead is converted to a keyword and
stored in the interactor's :known-as slot. If the interactor is saved, 
the user-provided name
will be placed in the name parameter field for create-instance. 


@section Action Buttons
@node Action Buttons
The action buttons permit the following types of operations:

@itemize

Create Instance: This operation creates an instance of the displayed interactor
and, if the user has modified any of the slot values, overrides the
values inherited from this interactor with the modified values. 
In addition, Lapidary examines the @t(:start-where) field of the
new interactor and if the
start-where includes an aggregadget, adds the interactor to the aggregadget's
behavior slot.

Modify: This operation stores any changes that the user has made to the 
interactor's slots in the interactor.

Destroy: This operation destroys the interactor.

Save: This operation prompts the user for a file name and then writes out
the interactor. 

C32: This operation brings up C32 and displays the interactor in the
spreadsheet window. The user can then edit any slot in the interactor.
Any changes the user makes will not be discarded by the @t(Cancel) button.
It is generally advisable to bring up the C32 menu only @emph{after} the
interactor has been created. (the one exception to this rule is when 
C32 appears as the result of pressing a formula button. If the user
enters a formula in the formula window, the formula will be installed 
in the instance). Otherwise the user will end up editing
the prototype for the interactor to be created, instead of the interactor
itself. The C32 chapter describes how to operate C32 and Section
@ref{custom-constraint} describes the modifications Lapidary makes to C32.

Cancel: This operation discards any changes the user has made to the dialog
box since the last create-instance or modify command.

@end itemize

@section Events
@node Events
@cindex{events}
Lapidary allows the user to define the start, stop, and abort events of
an interactor using event cards. Each card defines one event and a list
of events can be generated from a deck of cards. 
Each interactor dialog box contains buttons that pop up a window 
for each event that defines a start, stop or abort event.
A sample event card is shown in Figure @ref{cards}.
Selecting @t(Delete this event) will cause this event to be deleted.
However, Lapidary will not allow you to delete
an event card if it is the only one that exists. @t(Add an event)
causes a new event to be created.
@t(OK) makes the window disappear and generates the event list for the
desired event.

@float Figure, fig:ex2
@center @image{event-cards, 5.5in}
@caption{A sample event card deck}
@anchor{cards}
@end float

Any combination of @t(shift), @t(control), and @t(meta) can be selected,
but if the @t(any modifier) button is selected then the other 
modifier buttons will become unselected. 
The mouse actions and keyboard items are all mutually exclusive, so selecting
one will cause the previously selected item to be deselected. 
Events like #\Return can be generated by simply typing ``Return'' in the
@t(Specific keypress) box (quotes are not needed). 

@section :Start Where
@node :Start Where
Every interactor dialog box displays two commonly used start-wheres for an
interactor and allows the user to select an alternative one using the
@t(other) button (Figure @ref{choice-inter}).
If @t(other) is selected, a dialog box will appear which lists all
possible :start-where's. Once the desired start-where is selected, Lapidary
will incorporate the selected object in the drawing window into the
start-where if it is appropriate
(which it is in all cases but @t(t) and @t(nil)). If the start-where
requires a slot (which the @t(list) start-where's do), Lapidary will
request the name of a slot.

If the user wants a type restriction, then pressing the @t(type restriction)
button will cause Lapidary to request a type restriction. A type restriction
can be either an atom (e.g., opal:text) or a list of items
(e.g., (list opal:text opal:rectangle)). The type restriction button is
a toggle button so if it is already selected, selecting it again will cause
the type restriction to be removed. Also, selecting a new start-where will
cause the type restriction to be removed.


@section Formulas
@node Formulas
@cindex{formulas}
Selecting a formula button in any of the interactor dialog boxes causes
the interactor to be displayed in the C32 spreadsheet window and the
current value of the slot associated with the formula button to be displayed
in a C32 formula window. This value can then be edited into a formula. When
the @t(OK) button is pressed in the formula window, C32 disappears and
the formula is batched with the other changes that have been made to
the interactor since the last @t(Create Instance) or @t(Modify) command.
The formula is not actually installed until the @t(Create Instance) or
@t(Modify) buttons are selected. If the user selects @t(Cancel) in the
interactor dialog box, the formula will be discarded. The formula will also
be discarded if the user selects @t(Cancel) in the C32 formula window.

@section Specific Interactors
@node Specific Interactors
@subsection Choice Interactor
@node Choice Interactor
@cindex{choice interactor}

The choice interactor dialog box allows the user to create either a button
interactor or menu interactor, depending on whether the @t(menu) or
@t(button) radio button is selected (Figure @ref{choice-inter}).
The other slots that can be set using this dialog box are:

@float Figure, fig:ex2
@center @image{choice-inter, 5.5in}
@caption{Choice interactor dialog box}
@anchor{choice-inter}
@end float

@itemize

:start-where. If the user selects either @t(aggregadget of items) or
@t(single item) and there is a least one selection in a drawing window
(it may be either a primary or secondary selection), then start-where's
with @t(:element-of) and @t(:in-box) are generated with the selected
object.

:feedback-obj. Selecting the radio button associated with @t(interim feedback)
will cause the selected object in the Lapidary drawing windows to become
the interim feedback for this interactor. If this object is constrained to
one of the objects that satisfies the start-where or to a component of
one of these objects, Lapidary will automatically 
generalize the constraints so that the object can appear with any of the
objects in the start-where.

The user can also use the @t(by-demo) option to demonstrate interim feedback.
Lapidary will pop up an 
OK/Cancel box when an object that satisfies the start-where is selected.
The user can then use the various Lapidary menus to modify this object
so that it looks as it should when the object's @t(:interim-selected)
slot is set. 
Once the desired look is achieved, the user selects OK and
the changes will be installed so that the object looks like its original
self when it is not interim selected, and will look like the by-demo copy
when it is interim selected.

Lapidary implements the by-demo operation by comparing the values of
the following slots in the original object and the copied object:
@t{:left, :top, :width, :height, :visible, :draw-function,
:font, :string, :line-style, :filling-style, :x1, :x2, :y1, :y2}.

The last option the user can choose is @t(none) in which case nil will
be stored in the @t(:feedback-obj) slot. This will not undo the effects
of a by-demo operation since by-demo also places nil in the @t(:feedback-obj)
slot.


:final-feedback. The options for final feedback are identical to those
for @t(:feedback-obj). The by-demo changes
will appear when the object's @t(:selected) slot is set to @t(t).
Multiple final
feedback objects can be created by selecting several objects
and pressing the final feedback button. 
Lapidary will then bring up C32
and prompt the designer for a constraint that determines when to use each
kind of feedback object at run-time.

:final-function. The user can type in the name of a function that should
be called when the interactor completes.

:how-set. The user can set the @t(:how-set) slot by selecting a radio
button or entering numbers in the @t(increment-by) and (optionally)
@t(max value) fields.

@end itemize

@subsection Move/Grow Interactor
@node Move/Grow Interactor
@anchor{move-grow-sec}
@cindex{move/grow interactor}

The move/grow interactor dialog box (Figure @ref{lapidary-move-inter}) allows
the user to specify a move/grow interactor. The slots that can be set
using this dialog box are:

@itemize

:start-where. If the user selects either @t(Object to Press Over) or
@t(One of This Aggregate) and there is at least one selection in a drawing 
window (it may be either a primary or secondary selection), then start-where's
with :in-box and :element-of are generated with the selected object.

:line-p. This slot is set by the @t(Line) and @t(Box) buttons.
If a formula is selected, the formula should return @t(t) if
the interactor is moving/growing a line, and @t(nil) if it is moving/growing
a box object.

:grow-p. This slot is set by the @t(Grow) and @t(Move) buttons.
If a formula is selected, the formula should return @t(t) if
the interactor is growing an object, and @t(nil) if it is moving an object.

:min-length. Specifies a minimum length for lines.

:min-width. Specifies a minimum width for box objects.

:min-height. Specifies a minimum height for box objects.

:obj-to-change. The user can let the move/grow interactor modify the
object that satisfies the start-where, present an example object
to change to Lapidary or use a formula to compute the
object to change. 
This slot would be set if the interaction should start
over a feedback object such as selection handles, but should actually
move the object under the feedback object.

If the user presents an example object to change to Lapidary by
selecting an object and pressing the @t(Change this object) button,
Lapidary will automatically construct 
a formula so that the interactor changes the correct object at
run-time. For example, in Figure @ref{lapidary-move-inter}, the user
wants the move interactor to start over one of the selection handles,
but wants the object highlighted by the selection handles moved. The
user can specify that the interactor should start over the selection
handles by selecting the aggregate containing
the selection handles and pressing the @t(One of This Aggregate) radio
button in the move/grow dialog box. The user can specify that the object
highlighted by the selection handles at run-time should be the object 
changed by selecting the example object
that the selection handles currently highlight and pressing
the @t(Change this object) button in the move/grow dialog box.
Occasionally Lapidary may not be able to determine
from the start-where objects which object should be changed at run-time.
In this case Lapidary will give the user the choice of entering a formula
or of having the example object selected as the obj-to-change be the actual
object changed at run-time.


:final-function. The user can type in the name of a function that should
be called when the interactor completes.

:feedback-obj. An interim feedback object can be created by creating the 
desired object and
pressing the interim-feedback button. Constraints will be automatically
attached to the feedback object that cause it to move or grow appropriately,
and that make it visible/invisible at the appropriate times. 
If multiple objects are selected,
Lapidary will bring up C32
and prompt the designer for a constraint that determines when to use each
kind of feedback object at run-time.

:attach-point. Controls where the mouse will attach to the object.

@end itemize

The grow and move parameters allow the user to control which slots in
the object that is being grown or moved will actually be set. If a
formula is entered, it must return a value that can be used by the
slot :slots-to-set (see the Interactors chapter for more details on
this slot).

Example: To create an interactor that moves a box,

@enumerate
Create the box and leave it selected

Select interactors from the editor menu and then select move/grow  

In :start-where click on ``Object to Press Over''. This will 
cause the selected rectangle's KR name to be displayed.

Press the CREATE INSTANCE action button
@end enumerate

To test the interactor press test button in the editor menu and
drag it around.


@float Figure, fig:ex2
@center @image{move-behavior-a, 5.5in}
@center @image{move-inter, 5.5in}

@table @code 

(a)
(b)
@end table

@caption{
(a) The various parts for a move behavior; and (b) 
the dialog box for specifying the move/grow interactor.
The user can now directly select the obj-to-change and
Lapidary will create a formula that automatically selects
the correct object to change at run-time.
}
@anchor{lapidary-move-inter}
@end float


@subsection Two Point Interactor
@node Two Point Interactor
@cindex{two point interactor}

The two point interactor dialog box (Figure @ref{two-point-inter}) allows
a user to create a two point interactor. The slots that can be set
using this dialog box are:

@itemize

:start-where. If the user selects @t(Start Anywhere in Window) then a
start-where with @t(t) is generated. if the user selects
@t(Start in Box) and there is at least one selection in a drawing 
window (it may be either a primary or secondary selection), then a start-where
with :in-box is generated with the selected object.

:line-p. This slot is set by the buttons @t(Create Line) and 
@t(Create Non-Line). If a formula is selected, the formula should return 
@t(t) if
the interactor is creating a line, and @t(nil) if it is creating
a box object.

:min-length. Specifies a minimum length for lines.

:min-width. Specifies a minimum width for box objects.

:min-height. Specifies a minimum height for box objects.

:flip-if-change-side. Indicates whether a box may flip over when it is
being created.

:abort-if-too-small. Indicates whether the operation should be aborted
if the object is too small or whether an object of the minimum size
should be created.

:feedback-obj. An interim feedback object
can be created by creating the desired object and pressing the
interim-feedback button. Constraints will be automatically attached to
the feedback object that cause it to sweep out as the mouse cursor
is moved, and that make it visible/invisible at the appropriate times.
If multiple objects are selected, then
Lapidary will bring up C32
and prompt the designer for a constraint that determines when to use each
kind of feedback object at run-time.
If the standard feedback option is selected, a box or line feedback object
is automatically created according to whether a line or box is being created.

:final-function. The user can type in the name of a function that should
be called when the interactor completes.

@end itemize

Example: To create a two-point interactor with line feedback

1) select the interactors option from @t(other) in the editor menu
and then select two point interactor in the menu that pops up

2) click on Start Anywhere in Window

3) click on Create Line

4) click on Standard Feedback

5) click on CREATE INSTANCE

To test this interactor, enter test mode, press down on the left mouse button, and sweep out a line. No line will be created because a final function
was not provided.

@float Figure, fig:ex2
@center @image{TwoPoint, 5.5in}
@caption{Two point interactor dialog box}
@anchor{two-point-inter}
@end float


@subsection Text Interactor
@node Text Interactor
@cindex{text interactor}

The text interactor dialog box (Figure @ref{text-inter})
allows the user to create or modify a
text interactor and to edit the following slots:

@float Figure, fig:ex2
@center @image{text-inter, 5.5in}
@caption{Text interactor dialog box}
@anchor{text-inter}
@end float

@itemize

:start-where. If the user selects either @t(object to press over) or
@t(one of this aggregadget) and there is at least one selection in a drawing
window (it may be either a primary or secondary selection), then start-wheres
with @t(:in-box) and @t(:element-of) are generated with the selected
object.


:obj-to-change. The user can either let the text interactor modify the
object that satisfies the start-where or use a formula to compute the
object to change. Lapidary can construct a formula for this slot if
necessary (see section @ref{move-grow-sec}).

:feedback-obj. An interim feedback object
can be created by creating a text object and pressing the
interim-feedback button. Constraints will be automatically attached to
the feedback object that cause it to appear at the selected text object
and that make it visible/invisible at the appropriate times.
If multiple objects are selected, then
Lapidary will bring up C32
and prompt the designer for a constraint that determines when to use each
kind of feedback object at run-time.

:cursor-where-press. This slot is set by the buttons @t(where pressed)
and @t(at end of string). If @t(where pressed) is selected, the 
text editing cursor
will appear under the mouse cursor. If @t(at end of string) is selected,
the text editing cursor will always appear at the end of the string when
editing starts.

:final-function. The user can type in the name of a function that should
be called when the interactor completes.

@end itemize

@subsection Angle Interactor
@node Angle Interactor

The angle interactor dialog box (Figure @ref{angle-inter}) allows the user
to create and modify an angle interactor. The slots that can be set by
this dialog box are:

@itemize

:start-where. If the user selects @t(object to press over) 
and there is a least one selection in a drawing
window (it may be either a primary or secondary selection), then a start-where
with @t(:in-box) is generated. If the user selects @t(start anywhere in
window), then a start-where of @t(t) is generated.

:obj-to-change. The user can either let the angle interactor modify the
object that satisfies the start-where or use a formula to compute the
object to change.

:feedback-obj. An interim feedback object can be created by creating 
an object, selecting it,
and pushing the interim feedback button. 
The :angle slot of the object will be
set as the interactor is operated and the object will be made visible/invisible
as appropriate. To make the feedback object or the object that gets the final
angle change in response to changes in the :angle slot, custom constraints
must be created for the position and size slots. See the angle interactor
section in the Interactors chapter for sample constraints.
If multiple objects are selected, then
Lapidary will bring up C32
and prompt the designer for a constraint that determines when to use each
kind of feedback object at run-time.

:final-function. The user can type in the name of a function that should
be called when the interactor completes.

:center-of-rotation. This is the center of rotation for the interaction.
The user can either enter a list of @t{(x,y)}, enter a formula that
returns a list of @t{(x,y)} or select one of the standard locations for
the center of rotation by selecting the appropriate button.

@end itemize

@float Figure, fig:ex2
@center @image{Angle, 5.5in}
@caption{Angle interactor dialog box}
@anchor{angle-inter}
@end float


@section Getting Applications to Run
@node Getting Applications to Run


Lapidary-generated files consist of a set of create-instance
calls. The objects created are stored in a list and assigned to 
the variable *Garnet-Objects-Just-Created*. The top of a Lapidary-generated
file contains code to load the lapidary-functions.lisp file, which
provides functionality to support the created objects.





@chapter Hints on Making Garnet Programs Run Faster
@node Hints on Making Garnet Programs Run Faster

Brad A. Myers

@value{DATE}

@section Abstract
@node Abstract


This chapter discusses some hints about how to make Garnet programs
run faster. Most of these techniques should not be used until your
programs are fully debugged and ready to be shipped. 


@section Introduction
@node Introduction

An important goal of Garnet has been to create a system that is as
efficient as possible. For example, users should notice that version 2.2
is about two or three times faster than 2.1. Now that
people are writing large-scale systems using Garnet, a number of
things have been learned about how to make Garnet programs run faster.
This chapter collects a number of hints about how to write efficient
Garnet code. If you have ideas about how to make the underlying
Garnet system run faster, or new hints to add to this section, please
let us know.

The ideas in this chapter are aimed at producing the final production
version of your system. Therefore, we feel that you should not worry
about the comments here during early development. For example,
turning off the debugging and testing information is likely to make
your development more difficult. Also, declaring constants makes
changing code more difficult. Generally, you should get your system
to a fairly well-debugged state before applying these ideas.

Of course, the easiest way to make Garnet run faster is to get a
faster machine and/or more physical memory. With SPARC IIs and HP
Snakes becoming more prevalent, and 100 mip machines like the DEC
Alpha around the corner, we see expect that the next generation of
applications will have much less of a problem with achieving adequate
performance.

@section General
@node General
Ideas in this section are relevant to any code written in Lisp, not
just Garnet code. Some of these may seem obvious, but we have seen
code that violates many of them.

@itemize

Be sure to compile all your files.

The variable @code{user::*default-garnet-proclaim*}, which is defined in
@code{garnet-loader.lisp}, provides some default compiler optimization values
for Allegro, Lucid, CMU, LispWorks, and MCL lisp implementations. The default
gives you fast compiled code with verbose debugging help. You can @code{setf}
this variable before loading (and compiling) Garnet to override the default
proclamations, if you want to sacrifice debugging help for speed:
@example
(PROCLAIM '(OPTIMIZE (SPEED 3) (SAFETY 0) (SPACE 0)
	             (COMPILATION-SPEED 0)))
@end example

Fundamental changes in underlying algorithms will often overcome any
local tweaking of code. For example, changing an algorithm that
searches all the objects to one that has a pointer or a hash table to
the specific object can make an application practical for large
numbers of objects.

Use a fast Lisp system. We have found that Allegro Version 4.2 is
much faster than Allegro V3.x. Also, Allegro and Lucid are much
faster than KCL and AKCL on Unix machines.

Most systems have specialized commands and features for making smaller
and faster systems. For example, if you are using
Allegro, check out PRESTO, which tries to make the run-time image
smaller. One user reported that the "reorganizer" supplied with
Lucid, the CPU time used decreased about 10-20%, and the overall
time for execution dropped by about 30%.
We have found that the tracing tools supplied by vendors to
find where code is spending its time are mostly worthless, however.

Beware of Lisp code which causes CONS'ing. Quite often, the most
natural way to write Lisp code is the one that creates a lot of
intermediate storage. Unfortunately, this may result in severe
performance problems, as allocating and garbage-collecting storage is
among the slowest operations in Lisp. The recommendations below apply
to all of your code in general, but in particular to code that
may be executed often (such as the code in certain formulas which need
to be recomputed many times).

As a rule, mapping operations (like @code{mapcar}) generate garbage in most Lisp
implementations, because they create temporary (or permanent) lists of
results. Most mapping operations can be rewritten easily in terms of
DO, DOLIST, or DOTIMES.

Handling large numbers of objects with lists is generally expensive.
If you have lists of more than a few tens of objects, you should
consider using arrays instead. Arrays are just as convenient as lists,
and they require much less storage. If your application needs
variable numbers of objects, consider using variable-length arrays
(possibly with fill pointers).

Declare the types of your variables and functions (using DECLARE and
PROCLAIM). 

Some Lisp applications will give you warnings or notes about Lisp
constructs that are potentially inefficient. In CMU Common Lisp, for
example, setting SPEED to 3 and COMPILATION-SPEED to 0 generates a
number of messages about potentially inefficient constructs. Many
such inefficiencies can be eliminated easily, for example by adding
declarations to your code.

Wrap all lambdas in #' rather than just ' (in CLtL2 the # is no longer
optional). This 
comes up in Garnet a lot in final-functions for interactors and
selection-functions for gadgets. Note, in the @code{:parts} or
@code{:interactors} parts of aggregadgets or aggrelists, use @code{,#'}
(comma-number-quote) before lambdas and functions.

You can save an enormous amount of time loading software if you make images
of lisp with the software already loaded. For example, if you start lisp and
load Garnet, you can save an image of lisp that can be restarted later with
Garnet already loaded. We have simplified this procedure by providing the
function @code{opal:make-image}. If you want to make images by hand, you will
have to use @code{opal:disconnect-garnet} and @code{opal:reconnect-garnet}
to sever and restore lisp's connection with the X server. All of these
functions are documented in the Opal manual.

It may help to reboot your workstation every now and then. This will reset
the swap file so that large applications (like Garnet) run faster.
@end itemize



@section Making your Garnet Code Faster
@node Making your Garnet Code Faster
This section contains hints specifically about how to make Garnet code
faster.

@itemize
The global switch @code{:garnet-debug} can be removed from the
@code{*features*} list to cause all the debugging and demo code in Garnet to
be ignored during compiling and loading. This will make Garnet slightly
smaller and faster. The @code{:garnet-debug} keyword is pushed onto the
@code{*features*} list by default in @code{garnet-loader.lisp}, but you can
prevent this by setting @code{user::Garnet-Garnet-Debug} to NIL before compiling
and loading Garnet. Garnet will need to be recompiled with the new
@code{*features*} list, so that the extra code will not even get into the
compiled binaries. Of course, you will lose functions like
@code{inter:trace-inter}.

Turn off KR's type-checking by setting the variable @code{kr::*types-enabled*}
to NIL. Note: the speed difference may be imperceptible, since the type
system has been implemented very efficiently (operations are only about 2%
slower with type-checking).

If you have many objects in a window, and an interactor only works on a
small set of those objects, then the small set of objects should be in
their own aggregate or subwindow. This will cause Opal's @code{point-in-gob}
methods run faster, which identify the object that you clicked on. When
objects are arranged in an orderly aggregate hierarchy, then the
@code{point-in-gob} methods can reject entire groups of objects, without checking
each one separately, by checking whether a point is inside their
@emph{aggregate}'s bounding box. For example, in @code{demo-motif} the scroll bars
are in their own aggregate. Putting objects in a seperate subwindow is even
faster, since the coordinates of the click will only be checked against objects
in the same window as the click.

Use @code{o-formula}s instead of @code{formula}s. O-formulas are compiled
along with the rest of the file, whereas formulas are compiled at load-
or run-time, which is much slower.

Try not to use formulas where not really needed. For example, if the
positions of objects won't change, use expressions or numbers instead
of formulas to calculate them.

Try to eliminate as many interactors as possible. Garnet must
linearly search through all interactors in each window. To see how
many interactors are on your window, you can use
@code{(inter:print-inter-levels)}. If this is a long list, then try to
use one global interactor with a start-where that includes lots of
objects, rather than having each object have its own interactor. This
can even work if you have a lot of scattered gadgets. For example, if
you have a lot of buttons, you can use a button-panel and override the
default layout to individually place each button.

The @code{fast-redraw} property of graphical objects can be set to make
objects move and draw faster. This can be used in more cases than
with previous versions of Garnet, but it is still restricted. See the
fast-redraw section of the Opal manual.

Aggrelists are quite general, and have a lot of flexibility. If you
don't need this flexibility, for example, if your objects will always
be in a simple left-aligned column, it will be more efficient to place
the objects yourself, or create custom formulas.

If you are frequently destroying and creating new objects of the same
type, it is more efficient to just keep a list of objects
around, and re-using them. Allocating memory in Lisp is fairly
expensive.

If you are deleting a number of objects at the same time, first set
the window's @code{:aggregate} slot to NIL and update the window.
Then, when you are done destroying, set the aggregate back and update
again. For example, to destroy 220 rectangles on a Sparc, removing the
aggregate reduced the time from 11.8 to 2.4 seconds (80%)!
So your new code should be:
@example
;; @i{Code fragment to quickly destroy all the objects within an aggregate.}
(let ((temp-agg (kr:gv my-window :aggregate)))
  (when temp-agg
    ;; First, temporarily remove the aggregate:
    (kr:s-value my-window :aggregate NIL)
    (opal:update my-window)
    ;; Now do the actual destroying:
    (dolist (object (kr:get-values temp-agg :components))
      (opal:destroy object))
    ;; Finally, restore the aggregate:
    (kr:s-value my-window :aggregate temp-agg)
    (opal:update my-window)))
@end example

If you have objects in different parts of the same window changing at
the same time, it is often faster to call update explicitly after one
is changed and before the other. (This is only true if neither of the
objects is a fast-redraw object. Many of the built-in gadgets are
fast redraw objects for this reason, so this usually is not necessary
for built-in gadgets.)  The reason for this problem is that Garnet
will redraw everything in a bounding box which includes all the
changed objects. If the changed objects are in different parts of a
window, then everything in between will be redrawn also. Ways around
this problem include calling update explicitly after one of the
objects changes, making one of the objects be a fast redraw object if
possible, moving the objects closer together if possible (so there
aren't objects in between), or putting the objects in separate
subwindows if possible (subwindows are updated independently).

Conventional object-oriented programming relies heavily on message
sending. In Garnet, however, this technique is often less efficient
than the preferred Garnet programming style, which relies on slots and
constraints. Rather than writing methods to get values from certain
slots in an object, for example, consider accessing those slots directly and
having a formula compute their value. The Garnet style is more
efficient, since it avoid the message-sending overhead. Because
Garnet provides a powerful constraint mechanism, the functionality
that would normally be associated with a method can typically be
implemented in a formula.

If you use the same formula in multiple places, it is more efficient
to declare a formula prototype, and create instances of it. For
example:
@example
(defparameter leftform (o-formula (+ 10 (first (gvl :box)))))
;;@i{for every object}
(create-instance NIL @emph{<whatever>}
		 ...
		 (:left (formula leftform)))
@end example

If many objects in your scene have their own feedback objects, maybe
you can replace these with one global feedback object instead. The
button and menu interactors can take a @code{:final-feedback-obj}
parameter and will duplicate the feedback object if necessary.

If you have a lot of objects that become invisible and stay invisible
for a reasonable period if time, it might be better to remove them
from their aggregate rather than just setting their @code{:visible}
slot. There are many linear searches in Garnet that process all
objects in an aggregate, and each time it must check to see if the
objects are invisible.

It is slightly more efficient when you are creating a window at
startup, if you add all the objects to the top level aggregate
@emph{before} you add the aggregate to the window.

The use of double-buffering doesn't make your applications
run faster (they actually run a little slower), but it usually
@emph{appears} faster due to the lack of flicker. See the section in the
Opal manual on how to make a window be double-buffered.
@end itemize

@section Making your Binaries Smaller
@node Making your Binaries Smaller
This section discusses ways to make the run-time size of your
application smaller. This is important because when your system gets
big, it can start to swap, which significantly degrades performance.
We have found that many applications would be fast enough if they all
fit into physical memory, whereas when they begin swapping virtual
memory, they are not fast enough.

@itemize
Don't load the PostScript module or debugging code unless you need to.
Change the values of the appropriate variables in @code{garnet-loader},
or set the variables before loading Garnet. The values will not be overridden,
since they are defined with @code{defvar} in @code{garnet-loader}.

Declare constants where possible. This allows Garnet to throw away
formulas, which saves a lot of run-time space. All the built-in objects and
gadgets provide a @code{:maybe-constant} slot, which means that you can
use @code{(:constant T)} to make all the slots constant. 
The @code{:maybe-constant} will contain all of the slots discussed in the
manual as parameters to the object or gadget. Of course, the slots
that allow the widget to operate (e.g., the buttons to be pressed or
the scroll-bar-indicator to move) are not declared constant. 
Remember that only slots that don't change can be declared constant.
Therefore, if your gadget changes position or items or active or font after
creation, then you should @code{:except} the appropriate slots. For
example:
@example
(create-instance NIL gg:motif-radio-button-panel
  ;; @i{only the :active slot will change}
  (:constant '(T :except :active)) 
  (:left 10)(:top 30)
  (:items '("Start" "Pause" "Quit")))
@end example
Several functions are discussed in the Debugging Manual (starting on page
@value{debug}) that are very helpful in determining which slots should be
declared constant. The KR Manual describes the fundamentals of
constant declarations in detail.

Don't load gadget files you don't need. Most Garnet applications
(like the demos), load only the gadgets they need, if they haven't
been loaded already. This approach means that lots of gadgets you
never use won't take up memory.

Consider using @code{virtual-aggregates} if you have a lot of similar
objects in an interface, such as lines in a map or dots on a graph.
This will decrease storage requirements significantly. 

The variable @code{kr::store-lambdas} can be set to NIL to remove the
storage of the lambda expressions for compiled formulas. This will
save some storage, but it prevents objects from being stored to files.


@end itemize

